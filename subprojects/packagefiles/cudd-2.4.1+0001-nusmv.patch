diff -Nru a/cudd/cuddAddAbs.c b/cudd/cuddAddAbs.c
--- a/cudd/cuddAddAbs.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddAddAbs.c	2024-05-03 15:06:21.835159836 +0200
@@ -82,7 +82,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddAddAbs.c,v 1.15 2004/08/13 18:04:45 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddAddAbs.c,v 1.1.2.1 2010-02-04 10:41:15 nusmv Exp $";
 #endif
 
 static	DdNode	*two;
@@ -196,9 +196,9 @@
 /**Function********************************************************************
 
   Synopsis    [Disjunctively abstracts all the variables in cube from the
-  0-1 ADD f.]
+  FALSE-TRUE ADD f.]
 
-  Description [Abstracts all the variables in cube from the 0-1 ADD f
+  Description [Abstracts all the variables in cube from the FALSE-TRUE ADD f
   by taking the disjunction over all possible values taken by the
   variables.  Returns the abstracted ADD if successful; NULL
   otherwise.]
@@ -255,9 +255,9 @@
   DdNode * cube)
 {
     DdNode	*T, *E, *res, *res1, *res2, *zero;
-
+#warning [AMa] Rename variables?
     statLine(manager);
-    zero = DD_ZERO(manager);
+    zero = DD_FALSE(manager);
 
     /* Cube is guaranteed to be a cube at this point. */	
     if (f == zero || cuddIsConstant(cube)) {  
@@ -362,9 +362,10 @@
     DdNode	*T, *E, *res, *res1, *res2, *one, *zero;
 
     statLine(manager);
-    one = DD_ONE(manager);
-    zero = DD_ZERO(manager);
+    one = DD_TRUE(manager);
+    zero = DD_FALSE(manager);
 
+#warning [AMa] Here it may possible that 01 is required..
     /* Cube is guaranteed to be a cube at this point.
     ** zero and one are the only constatnts c such that c*c=c.
     */
@@ -468,9 +469,9 @@
   DdNode * cube)
 {
     DdNode	*T, *E, *res, *res1, *res2, *one;
-
+#warning [AMa] Rename variables
     statLine(manager);
-    one = DD_ONE(manager);
+    one = DD_TRUE(manager);
 
     /* Cube is guaranteed to be a cube at this point. */
     if (cuddIsConstant(f) || cube == one) {  
@@ -568,9 +569,9 @@
   DdNode * cube)
 {
     if (Cudd_IsComplement(cube)) return(0);
-    if (cube == DD_ONE(manager)) return(1);
+    if (cube == DD_TRUE(manager)) return(1);
     if (cuddIsConstant(cube)) return(0);
-    if (cuddE(cube) == DD_ZERO(manager)) {
+    if (cuddE(cube) == DD_FALSE(manager)) {
         return(addCheckPositiveCube(manager, cuddT(cube)));
     }
     return(0);
diff -Nru a/cudd/cuddAddApply.c b/cudd/cuddAddApply.c
--- a/cudd/cuddAddApply.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddAddApply.c	2024-05-03 15:06:21.835159836 +0200
@@ -92,7 +92,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddAddApply.c,v 1.17 2004/08/13 18:04:45 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddAddApply.c,v 1.1.2.1 2010-02-04 10:41:15 nusmv Exp $";
 #endif
 
 
@@ -171,8 +171,9 @@
     CUDD_VALUE_TYPE value;
 
     F = *f; G = *g;
-    if (F == DD_ZERO(dd)) return(G);
-    if (G == DD_ZERO(dd)) return(F);
+#warning [AMa] Here 0 and 1 should be used
+    if (F == DD_FALSE(dd)) return(G);
+    if (G == DD_FALSE(dd)) return(F);
     if (cuddIsConstant(F) && cuddIsConstant(G)) {
 	value = cuddV(F)+cuddV(G);
 	res = cuddUniqueConst(dd,value);
@@ -193,7 +194,7 @@
 
   Description [Integer and floating point multiplication. Returns NULL
   if not a terminal case; f * g otherwise.  This function can be used also
-  to take the AND of two 0-1 ADDs.]
+  to take the AND of two FALSE-TRUE ADDs.]
 
   SideEffects [None]
 
@@ -211,9 +212,10 @@
     CUDD_VALUE_TYPE value;
 
     F = *f; G = *g;
-    if (F == DD_ZERO(dd) || G == DD_ZERO(dd)) return(DD_ZERO(dd));
-    if (F == DD_ONE(dd)) return(G);
-    if (G == DD_ONE(dd)) return(F);
+#warning [AMa] Here 0 and 1 should be used, but doc says also TF
+    if (F == DD_FALSE(dd) || G == DD_FALSE(dd)) return(DD_FALSE(dd));
+    if (F == DD_TRUE(dd)) return(G);
+    if (G == DD_TRUE(dd)) return(F);
     if (cuddIsConstant(F) && cuddIsConstant(G)) {
 	value = cuddV(F)*cuddV(G);
 	res = cuddUniqueConst(dd,value);
@@ -254,7 +256,8 @@
 	if (cuddV(F) >= cuddV(G)) {
 	    return(F);
 	} else {
-	    return(DD_ZERO(dd));
+#warning [AMa] ??, think 0
+	    return(DD_FALSE(dd));
 	}
     }
     return(NULL);
@@ -284,8 +287,9 @@
 
     F = *f; G = *g;
     if (F == G) return(F);
-    if (F == DD_ZERO(dd)) return(G);
-    if (G == DD_ZERO(dd)) return(F);
+#warning [AMa] ??, think 0
+    if (F == DD_FALSE(dd)) return(G);
+    if (G == DD_FALSE(dd)) return(F);
     if (cuddIsConstant(G)) return(G);
     return(NULL);
 
@@ -317,8 +321,9 @@
     F = *f; G = *g;
     /* We would like to use F == G -> F/G == 1, but F and G may
     ** contain zeroes. */
-    if (F == DD_ZERO(dd)) return(DD_ZERO(dd));
-    if (G == DD_ONE(dd)) return(F);
+#warning [AMa] Here 0 and 1 should be used
+    if (F == DD_FALSE(dd)) return(DD_FALSE(dd));
+    if (G == DD_TRUE(dd)) return(F);
     if (cuddIsConstant(F) && cuddIsConstant(G)) {
 	value = cuddV(F)/cuddV(G);
 	res = cuddUniqueConst(dd,value);
@@ -352,9 +357,10 @@
     CUDD_VALUE_TYPE value;
 
     F = *f; G = *g;
-    if (F == G) return(DD_ZERO(dd));
-    if (F == DD_ZERO(dd)) return(cuddAddNegateRecur(dd,G));
-    if (G == DD_ZERO(dd)) return(F);
+#warning [AMa] Here 0 and 1 should be used
+    if (F == G) return(DD_FALSE(dd));
+    if (F == DD_FALSE(dd)) return(cuddAddNegateRecur(dd,G));
+    if (G == DD_FALSE(dd)) return(F);
     if (cuddIsConstant(F) && cuddIsConstant(G)) {
 	value = cuddV(F)-cuddV(G);
 	res = cuddUniqueConst(dd,value);
@@ -457,9 +463,9 @@
 
 /**Function********************************************************************
 
-  Synopsis    [Returns 1 if f &gt; g and 0 otherwise.]
+  Synopsis    [Returns TRUE if f &gt; g and FALSE otherwise.]
 
-  Description [Returns 1 if f &gt; g and 0 otherwise. Used in
+  Description [Returns TRUE if f &gt; g and FALSE otherwise. Used in
   conjunction with Cudd_addApply. Returns NULL if not a terminal
   case.]
 
@@ -474,15 +480,15 @@
   DdNode ** f,
   DdNode ** g)
 {
-
-    if (*f == *g) return(DD_ZERO(dd));
+#warning [AMa] Not shure about this, was 01, fix doc 
+    if (*f == *g) return(DD_FALSE(dd));
     if (*g == DD_PLUS_INFINITY(dd))
-	return DD_ZERO(dd);
+	return DD_FALSE(dd);
     if (cuddIsConstant(*f) && cuddIsConstant(*g)) {
 	if (cuddV(*f) > cuddV(*g)) {
-	    return(DD_ONE(dd));
+	    return(DD_TRUE(dd));
 	} else {
-	    return(DD_ZERO(dd));
+	    return(DD_FALSE(dd));
 	}
     }
 
@@ -563,9 +569,9 @@
 
 /**Function********************************************************************
 
-  Synopsis    [Disjunction of two 0-1 ADDs.]
+  Synopsis    [Disjunction of two FALSE-TRUE ADDs.]
 
-  Description [Disjunction of two 0-1 ADDs. Returns NULL
+  Description [Disjunction of two FALSE-TRUE ADDs. Returns NULL
   if not a terminal case; f OR g otherwise.]
 
   SideEffects [None]
@@ -582,7 +588,7 @@
     DdNode *F, *G;
 
     F = *f; G = *g;
-    if (F == DD_ONE(dd) || G == DD_ONE(dd)) return(DD_ONE(dd));
+    if (F == DD_TRUE(dd) || G == DD_TRUE(dd)) return(DD_TRUE(dd));
     if (cuddIsConstant(F)) return(G);
     if (cuddIsConstant(G)) return(F);
     if (F == G) return(F);
@@ -597,9 +603,9 @@
 
 /**Function********************************************************************
 
-  Synopsis    [NAND of two 0-1 ADDs.]
+  Synopsis    [NAND of two FALSE-TRUE ADDs.]
 
-  Description [NAND of two 0-1 ADDs. Returns NULL
+  Description [NAND of two FALSE-TRUE ADDs. Returns NULL
   if not a terminal case; f NAND g otherwise.]
 
   SideEffects [None]
@@ -616,8 +622,8 @@
     DdNode *F, *G;
 
     F = *f; G = *g;
-    if (F == DD_ZERO(dd) || G == DD_ZERO(dd)) return(DD_ONE(dd));
-    if (cuddIsConstant(F) && cuddIsConstant(G)) return(DD_ZERO(dd));
+    if (F == DD_FALSE(dd) || G == DD_FALSE(dd)) return(DD_TRUE(dd));
+    if (cuddIsConstant(F) && cuddIsConstant(G)) return(DD_FALSE(dd));
     if (F > G) { /* swap f and g */
 	*f = G;
 	*g = F;
@@ -629,9 +635,9 @@
 
 /**Function********************************************************************
 
-  Synopsis    [NOR of two 0-1 ADDs.]
+  Synopsis    [NOR of two FALSE-TRUE ADDs.]
 
-  Description [NOR of two 0-1 ADDs. Returns NULL
+  Description [NOR of two FALSE-TRUE ADDs. Returns NULL
   if not a terminal case; f NOR g otherwise.]
 
   SideEffects [None]
@@ -648,8 +654,8 @@
     DdNode *F, *G;
 
     F = *f; G = *g;
-    if (F == DD_ONE(dd) || G == DD_ONE(dd)) return(DD_ZERO(dd));
-    if (cuddIsConstant(F) && cuddIsConstant(G)) return(DD_ONE(dd));
+    if (F == DD_TRUE(dd) || G == DD_TRUE(dd)) return(DD_FALSE(dd));
+    if (cuddIsConstant(F) && cuddIsConstant(G)) return(DD_TRUE(dd));
     if (F > G) { /* swap f and g */
 	*f = G;
 	*g = F;
@@ -661,9 +667,9 @@
 
 /**Function********************************************************************
 
-  Synopsis    [XOR of two 0-1 ADDs.]
+  Synopsis    [XOR of two FALSE-TRUE ADDs.]
 
-  Description [XOR of two 0-1 ADDs. Returns NULL
+  Description [XOR of two FALSE-TRUE ADDs. Returns NULL
   if not a terminal case; f XOR g otherwise.]
 
   SideEffects [None]
@@ -680,10 +686,10 @@
     DdNode *F, *G;
 
     F = *f; G = *g;
-    if (F == G) return(DD_ZERO(dd));
-    if (F == DD_ONE(dd) && G == DD_ZERO(dd)) return(DD_ONE(dd));
-    if (G == DD_ONE(dd) && F == DD_ZERO(dd)) return(DD_ONE(dd));
-    if (cuddIsConstant(F) && cuddIsConstant(G)) return(DD_ZERO(dd));
+    if (F == G) return(DD_FALSE(dd));
+    if (F == DD_TRUE(dd) && G == DD_FALSE(dd)) return(DD_TRUE(dd));
+    if (G == DD_TRUE(dd) && F == DD_FALSE(dd)) return(DD_TRUE(dd));
+    if (cuddIsConstant(F) && cuddIsConstant(G)) return(DD_FALSE(dd));
     if (F > G) { /* swap f and g */
 	*f = G;
 	*g = F;
@@ -695,9 +701,9 @@
 
 /**Function********************************************************************
 
-  Synopsis    [XNOR of two 0-1 ADDs.]
+  Synopsis    [XNOR of two FALSE-TRUE ADDs.]
 
-  Description [XNOR of two 0-1 ADDs. Returns NULL
+  Description [XNOR of two FALSE-TRUE ADDs. Returns NULL
   if not a terminal case; f XNOR g otherwise.]
 
   SideEffects [None]
@@ -714,10 +720,10 @@
     DdNode *F, *G;
 
     F = *f; G = *g;
-    if (F == G) return(DD_ONE(dd));
-    if (F == DD_ONE(dd) && G == DD_ONE(dd)) return(DD_ONE(dd));
-    if (G == DD_ZERO(dd) && F == DD_ZERO(dd)) return(DD_ONE(dd));
-    if (cuddIsConstant(F) && cuddIsConstant(G)) return(DD_ZERO(dd));
+    if (F == G) return(DD_TRUE(dd));
+    if (F == DD_TRUE(dd) && G == DD_TRUE(dd)) return(DD_TRUE(dd));
+    if (G == DD_FALSE(dd) && F == DD_FALSE(dd)) return(DD_TRUE(dd));
+    if (cuddIsConstant(F) && cuddIsConstant(G)) return(DD_FALSE(dd));
     if (F > G) { /* swap f and g */
 	*f = G;
 	*g = F;
diff -Nru a/cudd/cuddAddFind.c b/cudd/cuddAddFind.c
--- a/cudd/cuddAddFind.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddAddFind.c	2024-05-03 15:06:21.835159836 +0200
@@ -77,7 +77,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddAddFind.c,v 1.8 2004/08/13 18:04:45 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddAddFind.c,v 1.1.2.1 2010-02-04 10:41:15 nusmv Exp $";
 #endif
 
 
@@ -209,7 +209,7 @@
 Cudd_addIthBit(
   DdManager * dd,
   DdNode * f,
-  int  bit)
+  ptrint  bit)
 {
     DdNode *res;
     DdNode *index;
@@ -268,15 +268,24 @@
 {
     DdNode *res, *T, *E;
     DdNode *fv, *fvn;
-    int mask, value;
+
+  /* NuSMV: add begin */
+    ptrint mask, value;
+    /* WAS: long mask, value; */
+  /* NuSMV: add end */
+
     int v;
 
     statLine(dd);
     /* Check terminal case. */
     if (cuddIsConstant(f)) {
-	mask = 1 << ((int) cuddV(index));
-	value = (int) cuddV(f);
-	return((value & mask) == 0 ? DD_ZERO(dd) : DD_ONE(dd));
+      /* NuSMV: add begin */
+	mask = 1 << ((ptrint) cuddV(index));
+	value = (ptrint) cuddV(f);
+        /* WAS: mask = 1 << ((long) cuddV(index));
+                value = (long) cuddV(f); */
+      /* NuSMV: add end */
+	return((value & mask) == 0 ? DD_FALSE(dd) : DD_TRUE(dd));
     }
 
     /* Check cache. */
diff -Nru a/cudd/cuddAddInv.c b/cudd/cuddAddInv.c
--- a/cudd/cuddAddInv.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddAddInv.c	2024-05-03 15:06:21.835159836 +0200
@@ -75,7 +75,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddAddInv.c,v 1.9 2004/08/13 18:04:45 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddAddInv.c,v 1.1.2.1 2010-02-04 10:41:15 nusmv Exp $";
 #endif
 
 
diff -Nru a/cudd/cuddAddIte.c b/cudd/cuddAddIte.c
--- a/cudd/cuddAddIte.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddAddIte.c	2024-05-03 15:06:21.835159836 +0200
@@ -83,7 +83,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddAddIte.c,v 1.15 2004/08/13 18:04:45 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddAddIte.c,v 1.1.2.1 2010-02-04 10:41:15 nusmv Exp $";
 #endif
 
 
@@ -91,13 +91,15 @@
 /* Macro declarations                                                        */
 /*---------------------------------------------------------------------------*/
 
-
 /**AutomaticStart*************************************************************/
 
 /*---------------------------------------------------------------------------*/
 /* Static function prototypes                                                */
 /*---------------------------------------------------------------------------*/
 
+/* NuSMV: added begin */
+static CUDD_VALUE_TYPE Cudd_type_error (DdManager* dd, CUDD_VALUE_TYPE);
+/* NuSMV: added end */
 static void addVarToConst (DdNode *f, DdNode **gp, DdNode **hp, DdNode *one, DdNode *zero);
 
 /**AutomaticEnd***************************************************************/
@@ -113,7 +115,7 @@
   Synopsis    [Implements ITE(f,g,h).]
 
   Description [Implements ITE(f,g,h). This procedure assumes that f is
-  a 0-1 ADD.  Returns a pointer to the resulting ADD if successful; NULL
+  a FALSE-TRUE ADD.  Returns a pointer to the resulting ADD if successful; NULL
   otherwise.]
 
   SideEffects [None]
@@ -143,11 +145,11 @@
 
   Synopsis    [Implements ITEconstant for ADDs.]
 
-  Description [Implements ITEconstant for ADDs.  f must be a 0-1 ADD.
+  Description [Implements ITEconstant for ADDs.  f must be a F-T ADD.
   Returns a pointer to the resulting ADD (which may or may not be
   constant) or DD_NON_CONSTANT. No new nodes are created. This function
   can be used, for instance, to check that g has a constant value
-  (specified by h) whenever f is 1. If the constant value is unknown,
+  (specified by h) whenever f is TRUE. If the constant value is unknown,
   then one should use Cudd_addEvalConst.]
 
   SideEffects [None]
@@ -162,21 +164,24 @@
   DdNode * g,
   DdNode * h)
 {
-    DdNode *one,*zero;
+    DdNode *_true,*_false;
     DdNode *Fv,*Fnv,*Gv,*Gnv,*Hv,*Hnv,*r,*t,*e;
     unsigned int topf,topg,toph,v;
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
 
     statLine(dd);
     /* Trivial cases. */
-    if (f == (one = DD_ONE(dd))) {	/* ITE(1,G,H) = G */
+    if (f == (_true = DD_TRUE(dd))) {	/* ITE(TRUE,G,H) = G */
         return(g);
     }
-    if (f == (zero = DD_ZERO(dd))) {	/* ITE(0,G,H) = H */
+    if (f == (_false = DD_FALSE(dd))) {	/* ITE(FALSE,G,H) = H */
         return(h);
     }
 
     /* From now on, f is known not to be a constant. */
-    addVarToConst(f,&g,&h,one,zero);
+    addVarToConst(f,&g,&h,_true,_false);
 
     /* Check remaining one variable cases. */
     if (g == h) { 			/* ITE(F,G,G) = G */
@@ -239,11 +244,11 @@
 
 /**Function********************************************************************
 
-  Synopsis    [Checks whether ADD g is constant whenever ADD f is 1.]
+  Synopsis    [Checks whether ADD g is constant whenever ADD f is TRUE.]
 
-  Description [Checks whether ADD g is constant whenever ADD f is 1.  f
-  must be a 0-1 ADD.  Returns a pointer to the resulting ADD (which may
-  or may not be constant) or DD_NON_CONSTANT. If f is identically 0,
+  Description [Checks whether ADD g is constant whenever ADD f is TRUE.  f
+  must be a FALSE-TRUE ADD.  Returns a pointer to the resulting ADD (which may
+  or may not be constant) or DD_NON_CONSTANT. If f is identically FALSE,
   the check is assumed to be successful, and the background value is
   returned. No new nodes are created.]
 
@@ -262,16 +267,20 @@
     DdNode *Fv,*Fnv,*Gv,*Gnv,*r,*t,*e;
     unsigned int topf,topg;
 
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
 #ifdef DD_DEBUG
     assert(!Cudd_IsComplement(f));
 #endif
 
     statLine(dd);
     /* Terminal cases. */
-    if (f == DD_ONE(dd) || cuddIsConstant(g)) {
+    if (f == DD_TRUE(dd) || cuddIsConstant(g)) {
         return(g);
     }
-    if (f == (zero = DD_ZERO(dd))) {
+    if (f == (zero = DD_FALSE(dd))) {
         return(dd->background);
     }
 
@@ -346,6 +355,10 @@
 {
     DdNode *res;
 
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     do {
 	dd->reordered = 0;
 	res = cuddAddCmplRecur(dd,f);
@@ -361,7 +374,7 @@
 
   Description [Returns 1 if f is less than or equal to g; 0 otherwise.
   No new nodes are created. This procedure works for arbitrary ADDs.
-  For 0-1 ADDs Cudd_addEvalConst is more efficient.]
+  For FALSE-TRUE ADDs Cudd_addEvalConst is more efficient.]
 
   SideEffects [None]
 
@@ -377,6 +390,10 @@
     DdNode *tmp, *fv, *fvn, *gv, *gvn;
     unsigned int topf, topg, res;
 
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     /* Terminal cases. */
     if (f == g) return(1);
 
@@ -392,7 +409,7 @@
     /* Check cache. */
     tmp = cuddCacheLookup2(dd,(DD_CTFP)Cudd_addLeq,f,g);
     if (tmp != NULL) {
-	return(tmp == DD_ONE(dd));
+	return(tmp == DD_TRUE(dd));
     }
 
     /* Compute cofactors. One of f and g is not constant. */
@@ -413,7 +430,7 @@
 
     /* Store result in cache and return. */
     cuddCacheInsert2(dd,(DD_CTFP) Cudd_addLeq,f,g,
-		     Cudd_NotCond(DD_ONE(dd),res==0));
+		     Cudd_NotCond(DD_TRUE(dd),res==0));
     return(res);
 
 } /* end of Cudd_addLeq */
@@ -444,32 +461,57 @@
   DdNode * g,
   DdNode * h)
 {
-    DdNode *one,*zero;
+    DdNode *_true,*_false;
     DdNode *r,*Fv,*Fnv,*Gv,*Gnv,*Hv,*Hnv,*t,*e;
     unsigned int topf,topg,toph,v;
-    int index;
+    int index = 0;
 
     statLine(dd);
     /* Trivial cases. */
 
+    /* NuSMV: added begin */
+    _true = DD_TRUE(dd);
+    _false = DD_FALSE(dd);
+
+    /* Added to take car of non 0/1 ADD inside NuSMV */
+    if (cuddIsConstant(f)) {
+
+      /* One variable cases. */
+      if (f == _true) {	/* ITE(TRUE,G,H) = G */
+        return(g);
+      }
+      if (f == _false) {	/* ITE(FALSE,G,H) = H */
+        return(h);
+      }
+
+      HANDLE_FAILURE(dd, f);
+      Cudd_type_error(dd, cuddV(f));
+    }
+#if 0
+    /* NuSMV: added end */
+    
     /* One variable cases. */
-    if (f == (one = DD_ONE(dd))) {	/* ITE(1,G,H) = G */
+    if (f == (_true = DD_TRUE(dd))) {	/* ITE(1,G,H) = G */
         return(g);
     }
-    if (f == (zero = DD_ZERO(dd))) {	/* ITE(0,G,H) = H */
+    if (f == (_false = DD_FALSE(dd))) {	/* ITE(0,G,H) = H */
         return(h);
     }
 
+    /* NuSMV: added begin */
+#endif
+    /* NuSMV: added end */
+
     /* From now on, f is known to not be a constant. */
-    addVarToConst(f,&g,&h,one,zero);
+    addVarToConst(f,&g,&h,_true,_false);
 
     /* Check remaining one variable cases. */
     if (g == h) {			/* ITE(F,G,G) = G */
         return(g);
     }
 
-    if (g == one) {			/* ITE(F,1,0) = F */
-        if (h == zero) return(f);
+    if (g == _true) {			/* ITE(F,1,0) = F */
+        if (h == _false) return(f);
     }
 
     topf = cuddI(dd,f->index);
@@ -478,11 +520,11 @@
     v = ddMin(topg,toph);
 
     /* A shortcut: ITE(F,G,H) = (x,G,H) if F=(x,1,0), x < top(G,H). */
-    if (topf < v && cuddT(f) == one && cuddE(f) == zero) {
+    if (topf < v && cuddT(f) == _true && cuddE(f) == _false) {
 	r = cuddUniqueInter(dd,(int)f->index,g,h);
 	return(r);
     }
-    if (topf < v && cuddT(f) == zero && cuddE(f) == one) {
+    if (topf < v && cuddT(f) == _false && cuddE(f) == _true) {
 	r = cuddUniqueInter(dd,(int)f->index,h,g);
 	return(r);
     }
@@ -542,6 +584,7 @@
 } /* end of cuddAddIteRecur */
 
 
+
 /**Function********************************************************************
 
   Synopsis    [Performs the recursive step of Cudd_addCmpl.]
@@ -559,18 +602,18 @@
   DdManager * dd,
   DdNode * f)
 {
-    DdNode *one,*zero;
+    DdNode *_true,*_false;
     DdNode *r,*Fv,*Fnv,*t,*e;
 
     statLine(dd);
-    one = DD_ONE(dd);
-    zero = DD_ZERO(dd); 
+    _true = DD_TRUE(dd);
+    _false = DD_FALSE(dd); 
 
     if (cuddIsConstant(f)) {
-        if (f == zero) {
-	    return(one);
+        if (f == _false) {
+	    return(_true);
 	} else {
-	    return(zero);
+	    return(_false);
 	}
     }
     r = cuddCacheLookup1(dd,Cudd_addCmpl,f);
@@ -637,3 +680,11 @@
     }
 
 } /* end of addVarToConst */
+
+/* NuSMV: added begin */
+static CUDD_VALUE_TYPE Cudd_type_error(DdManager* dd, CUDD_VALUE_TYPE f)
+{
+  dd->type_error_fun(dd, dd->err, f, dd->env_arg);
+  return(NULL);
+}
+/* NuSMV: added end */
diff -Nru a/cudd/cuddAddNeg.c b/cudd/cuddAddNeg.c
--- a/cudd/cuddAddNeg.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddAddNeg.c	2024-05-03 15:06:21.835159836 +0200
@@ -77,7 +77,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddAddNeg.c,v 1.11 2004/08/13 18:04:46 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddAddNeg.c,v 1.1.2.1 2010-02-04 10:41:15 nusmv Exp $";
 #endif
 
 
diff -Nru a/cudd/cuddAddOp.c b/cudd/cuddAddOp.c
--- a/cudd/cuddAddOp.c	1970-01-01 01:00:00.000000000 +0100
+++ b/cudd/cuddAddOp.c	2024-05-03 15:06:21.835159836 +0200
@@ -0,0 +1,1303 @@
+/**CFile***********************************************************************
+
+  FileName    [cuddAddOp.c]
+
+  PackageName [cudd]
+
+  Synopsis    [Apply function for ADDs and some operations on ADD.]
+
+  Description [Apply function for ADDs and some operations on ADD.]
+
+  Author      [Marco Roveri]
+
+  Copyright   [Copyright (C) 1998 by FBK-irst
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+
+  Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+
+  Neither the name of the University of Colorado nor the names of its
+  contributors may be used to endorse or promote products derived from
+  this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+  POSSIBILITY OF SUCH DAMAGE.]
+
+******************************************************************************/
+
+#include    "util.h"
+#include    "st.h"
+#include    "cuddInt.h"
+
+/*---------------------------------------------------------------------------*/
+/* Constant declarations                                                     */
+/*---------------------------------------------------------------------------*/
+
+
+/*---------------------------------------------------------------------------*/
+/* Structure declarations                                                    */
+/*---------------------------------------------------------------------------*/
+
+
+/*---------------------------------------------------------------------------*/
+/* Type declarations                                                         */
+/*---------------------------------------------------------------------------*/
+
+
+/*---------------------------------------------------------------------------*/
+/* Variable declarations                                                     */
+/*---------------------------------------------------------------------------*/
+
+#ifndef lint
+static char rcsid[] DD_UNUSED = "$Id: cuddAddOp.c,v 1.1.2.1 2010-02-04 10:41:15 nusmv Exp $";
+#endif
+
+
+/*---------------------------------------------------------------------------*/
+/* Macro declarations                                                        */
+/*---------------------------------------------------------------------------*/
+#define CUDD_ELSE_CNST (CUDD_VALUE_TYPE)(-100)
+
+/**AutomaticStart*************************************************************/
+
+/*---------------------------------------------------------------------------*/
+/* Static function prototypes                                                */
+/*---------------------------------------------------------------------------*/
+static CUDD_VALUE_TYPE Cudd_type_error (DdManager *, CUDD_VALUE_TYPE);
+static CUDD_VALUE_TYPE Cudd_fatal_error (DdManager *, const char *);
+/* NuSMV: add begin */
+static void cudd_addWalkLeavesRecur (DdManager *, void (*op)(void*, CUDD_VALUE_TYPE), DdNode *, st_table *, void*);
+/* WAS: static void cudd_addWalkLeavesRecur (void (*op)(CUDD_VALUE_TYPE), DdNode *, st_table *); */
+/* NuSMV: add end */
+static int addCheckPositiveCube (DdManager *manager, DdNode *cube);
+static DdNode * addAbstractRecur (DdManager * manager, CUDD_VALUE_TYPE (*op)(), DdNode * f, DdNode * cube, void* arg);
+
+/**AutomaticEnd***************************************************************/
+
+
+/*---------------------------------------------------------------------------*/
+/* Definition of exported functions                                          */
+/*---------------------------------------------------------------------------*/
+
+/**Function********************************************************************
+
+  Synopsis    [Applies op to the corresponding discriminants of f and g.]
+
+  Description [Applies op to the corresponding discriminants of f and g.
+  Returns a pointer to the result if successful; NULL otherwise.]
+
+  SideEffects [None]
+
+  SeeAlso     []
+
+******************************************************************************/
+DdNode *
+Cudd_addApply(
+DdManager       *dd,
+CUDD_VALUE_TYPE (*op)(),
+DdNode          *f,
+DdNode          *g,
+void            *arg)
+{
+    DdNode *res;
+
+    do {
+	dd->reordered = 0;
+	res = cudd_addApplyRecur(dd,op,f,g,arg);
+    } while (dd->reordered == 1);
+    return(res);
+
+} /* end of Cudd_addApply */
+
+/**Function********************************************************************
+
+  Synopsis    [Applies AND to the corresponding discriminants of f and g.]
+
+  Description [Applies logical AND to the corresponding discriminants
+  of f and g. f and g must have only FALSE or TRUE as terminal nodes. Returns
+  a pointer to the result if successful; NULL otherwise.]
+
+  SideEffects [None]
+
+  SeeAlso     []
+
+******************************************************************************/
+DdNode *
+Cudd_addAnd(
+DdManager *dd,
+DdNode    *f,
+DdNode    *g)
+{
+  DdNode *res;
+
+  do {
+    dd->reordered = 0;
+    res = cudd_addAndRecur(dd, f, g);
+  } while (dd->reordered == 1);
+  return(res);
+
+}
+
+/**Function********************************************************************
+
+  Synopsis    [Applies AND to the corresponding discriminants of f and g.]
+
+  Description [Applies logical AND to the corresponding discriminants
+  of f and g and stores the result in f. f and g must have only FALSE or TRUE
+  as terminal nodes.]
+
+  SideEffects [The result is stored in the first operand.]
+
+  SeeAlso     [Cudd_addAnd]
+
+******************************************************************************/
+void
+Cudd_addAccumulateAnd(
+DdManager * dd,
+DdNode **f,
+DdNode *g)
+{
+  DdNode *res;
+
+  res = Cudd_addAnd(dd,*f,g);
+  if ( res != NULL) {
+    cuddRef(res);
+    Cudd_RecursiveDeref(dd,*f);
+  }
+  *f = res;
+}
+
+/**Function********************************************************************
+
+  Synopsis    [Applies OR to the corresponding discriminants of f and g.]
+
+  Description [Applies logica OR to the corresponding discriminants of
+  f and g.  f and g must have only FALSE or TRUE as terminal nodes. Returns a
+  pointer to the result if successful; NULL otherwise.]
+
+  SideEffects [None]
+
+  SeeAlso     []
+
+******************************************************************************/
+DdNode *
+Cudd_addOr(
+DdManager *dd,
+DdNode    *f,
+DdNode    *g)
+{
+  DdNode *res;
+
+  do {
+    dd->reordered = 0;
+    res = cudd_addOrRecur(dd,f,g);
+  } while (dd->reordered == 1);
+  return(res);
+
+}
+
+/**Function********************************************************************
+
+  Synopsis    [Applies XOR to the corresponding discriminants of f and g.]
+
+  Description [Applies logical XOR to the corresponding discriminants
+  of f and g.  f and g must have only FALSE or TRUE as terminal
+  nodes. Returns a pointer to the result if successful; NULL
+  otherwise.]
+
+  SideEffects [None]
+
+  SeeAlso     []
+
+******************************************************************************/
+DdNode *
+Cudd_addXor(
+DdManager *dd,
+DdNode *f,
+DdNode *g)
+{
+    DdNode *res;
+
+    do {
+	dd->reordered = 0;
+	res = cudd_addXorRecur(dd,f,g);
+    } while (dd->reordered == 1);
+    return(res);
+
+}
+
+/**Function********************************************************************
+
+  Synopsis    [Applies NOT to the corresponding discriminants of f.]
+
+  Description [Applies logical NOT to the corresponding discriminants of f.
+  f must have only FALSE or TRUE as terminal nodes. Returns a pointer to the
+  result if successful; NULL otherwise.]
+
+  SideEffects [None]
+
+  SeeAlso     []
+
+******************************************************************************/
+DdNode *
+Cudd_addNot(
+DdManager * dd,
+DdNode * f)
+{
+  DdNode * res;
+  DdNode * _true = DD_TRUE(dd);
+
+  do {
+    dd->reordered = 0;
+    res = cudd_addXorRecur(dd,_true,f);
+  } while (dd->reordered == 1);
+  return(res);
+
+}
+
+/**Function********************************************************************
+
+  Synopsis    [Existentially abstracts all the variables in cube from f.]
+
+  Description [Abstracts all the variables in cube from f by applying
+  a given function over all possible values taken by the variables.
+  Returns the abstracted ADD.]
+
+  SideEffects [None]
+
+  SeeAlso     [Cudd_addExistAbstract]
+
+******************************************************************************/
+DdNode *
+Cudd_addAbstract(
+  DdManager * manager,
+  CUDD_VALUE_TYPE (*op)(),
+  DdNode * f,
+  DdNode * cube,
+  void* arg)
+{
+    DdNode *res;
+
+    if (addCheckPositiveCube(manager, cube) == 0) {
+        (void) fprintf(manager->err,"Error: Can only abstract cubes");
+        return(NULL);
+    }
+
+    do {
+	manager->reordered = 0;
+	res = addAbstractRecur(manager, op, f, cube, arg);
+    } while (manager->reordered == 1);
+    return(res);
+
+} /* end of Cudd_addAbstract */
+
+/**Function********************************************************************
+
+  Synopsis    [Applies IfThen to the corresponding discriminants of f and g.]
+
+  Description [Applies IfThen to the corresponding discriminants of f and g.
+  Returns a pointer to the result if successful; NULL otherwise.]
+
+  SideEffects [None]
+
+  SeeAlso     []
+
+******************************************************************************/
+DdNode *
+Cudd_addIfThen(
+DdManager *dd,
+DdNode    *f,
+DdNode    *g)
+{
+  DdNode * res;
+
+  do {
+    dd->reordered = 0;
+    res = cudd_addIfThenRecur(dd,f,g);
+  } while (dd->reordered == 1);
+  return(res);
+
+}
+
+/**Function********************************************************************
+
+  Synopsis    [Applies Else to the corresponding discriminants of f and g.]
+
+  Description [Applies Else to the corresponding discriminants of f and g.
+  Returns a pointer to the result if successful; NULL otherwise.]
+
+  SideEffects [None]
+
+  SeeAlso     []
+
+******************************************************************************/
+DdNode *
+Cudd_addElse(
+DdManager *dd,
+DdNode    *f,
+DdNode    *g)
+{
+  DdNode *res;
+
+  do {
+    dd->reordered = 0;
+    res = cudd_addElseRecur(dd,f,g);
+  } while (dd->reordered == 1);
+  return(res);
+}
+
+/**Function********************************************************************
+
+  Synopsis    [Applies IfThenElse to the corresponding discriminants of f,
+  g and h.]
+
+  Description [Applies IfThenElse to the corresponding discriminants of f,
+  g and h. Returns a pointer to the result if successful; NULL otherwise.]
+
+  SideEffects [None]
+
+  SeeAlso     []
+
+******************************************************************************/
+DdNode *
+Cudd_addIfThenElse(
+DdManager *dd,
+DdNode *f,
+DdNode *g,
+DdNode *h)
+{
+  DdNode *res_then, *res;
+
+  do {
+    dd->reordered = 0;
+    res_then = cudd_addIfThenRecur(dd,f,g);
+    if(res_then == NULL) return(NULL);
+    cuddRef(res_then);
+    res = cudd_addElseRecur(dd,res_then,g);
+    if(res == NULL) {
+      Cudd_RecursiveDeref(dd,res_then);
+      return(NULL);
+    }
+    cuddDeref(res_then);
+  } while (dd->reordered == 1);
+  return(res);
+}
+
+/**Function********************************************************************
+
+  Synopsis    [Computes the difference between two sets.]
+
+  Description [Computes the set difference between two sets.]
+
+  SideEffects [None]
+
+  SeeAlso     []
+
+******************************************************************************/
+
+DdNode *
+Cudd_addCubeDiff(
+DdManager * dd,
+DdNode * a,
+DdNode * b)
+{
+  DdNode * res;
+
+  do {
+    dd->reordered = 0;
+    res = cudd_addCubeDiffRecur(dd,a,b);
+  } while (dd->reordered == 1);
+  return(res);
+}
+
+/**Function********************************************************************
+
+  Synopsis    [Applies a generic function to constant nodes.]
+
+  Description [Applies a generic function (void)(*op)(CUDD_VALUE_TYPE) to
+  constants nodes of f.]
+
+  SideEffects [None]
+
+  SeeAlso     []
+
+******************************************************************************/
+
+void
+Cudd_addWalkLeaves(
+ /* NuSMV: add begin */
+DdManager* dd,
+ /* NuSMV: add end */
+void (*op)(void*, CUDD_VALUE_TYPE),
+DdNode * f,
+void* arg)
+{
+  st_table *tmp_table;
+
+  tmp_table = st_init_table(st_ptrcmp,st_ptrhash);
+  if (tmp_table == NULL) {
+    /* NuSMV: add begin */
+    fprintf(dd->err,"Cudd_addWalkLeaves: tmp_table == NULL\n");
+    /* WAS: fprintf(stderr,"Cudd_addWalkLeaves: tmp_table == NULL\n"); */
+    /* NuSMV: add end */
+    exit(1);
+
+  }
+  /* NuSMV: add begin */
+  cudd_addWalkLeavesRecur(dd, op,f,tmp_table, arg);
+  /* WAS: cudd_addWalkLeavesRecur(op,f,tmp_table); */
+  /* NuSMV: add end */
+  st_free_table(tmp_table);
+}
+
+static void
+cudd_addWalkLeavesRecur(
+ /* NuSMV: add begin */
+DdManager* dd,
+ /* NuSMV: add end */
+void (*op)(void*, CUDD_VALUE_TYPE),
+DdNode * f,
+st_table * tmp_table,
+void* arg)
+{
+ /* NuSMV: add begin */
+  ptrint mark;
+  /* WAS: long mark; */
+ /* NuSMV: add end */
+
+  if (st_lookup(tmp_table, (char *)f, (char **)((char*)&mark))) return;
+  if (st_insert(tmp_table, (char *)f, (char *)1) == ST_OUT_OF_MEM) {
+    /* NuSMV: add begin */
+    fprintf(dd->err,"cudd_addWalkLeavesRecur: ST_OUT_OF_MEM\n");
+    /* WAS: fprintf(stderr,"cudd_addWalkLeavesRecur: ST_OUT_OF_MEM\n"); */
+    /* NuSMV: add end */
+
+    exit(1);
+  }
+  if (cuddIsConstant(f)) {
+    op(arg, (CUDD_VALUE_TYPE)cuddV(f));
+  }
+  else {
+    /* NuSMV: add begin */
+    cudd_addWalkLeavesRecur(dd, op, (DdNode *)cuddT(f), tmp_table, arg);
+    cudd_addWalkLeavesRecur(dd, op, (DdNode *)cuddE(f), tmp_table, arg);
+    /* WAS:
+       cudd_addWalkLeavesRecur(op, (DdNode *)cuddT(f), tmp_table);
+       cudd_addWalkLeavesRecur(op, (DdNode *)cuddE(f), tmp_table);
+    */
+    /* NuSMV: add end */
+  }
+}
+
+/**Function********************************************************************
+
+  Synopsis    [Given an ADD, this function extracts its "constant" value.]
+
+  Description [Given an ADD, this function extracts its "constant" value.]
+
+  SideEffects [None]
+
+  SeeAlso     []
+
+******************************************************************************/
+CUDD_VALUE_TYPE
+Cudd_add_value(
+DdNode * fn)
+{
+  CUDD_VALUE_TYPE res;
+
+  if (cuddIsConstant(fn)) return((CUDD_VALUE_TYPE)cuddV(fn));
+  res = Cudd_add_value(cuddE(fn));
+  if (res == CUDD_ELSE_CNST)
+    res = Cudd_add_value(cuddT(fn));
+  return(res);
+}
+
+/*---------------------------------------------------------------------------*/
+/* Definition of internal functions                                          */
+/*---------------------------------------------------------------------------*/
+
+/**Function********************************************************************
+
+  Synopsis    [Performs the recursive step of Cudd_addApply.]
+
+  Description [Performs the recursive step of Cudd_addApply. Returns a
+  pointer to the result if successful; NULL otherwise.]
+
+  SideEffects [None]
+
+  SeeAlso     []
+
+******************************************************************************/
+DdNode *
+cudd_addApplyRecur(
+DdManager *dd,
+CUDD_VALUE_TYPE (*op)(),
+DdNode *f,
+DdNode *g,
+void   *arg)
+{
+    DdNode *res,
+	   *fv, *fvn, *gv, *gvn,
+	   *T, *E;
+    unsigned int ford, gord;
+    unsigned int index;
+
+    /*
+      Check for terminals. If it's the case then "op" is applied to
+      the operands f and gmay swap f and g.
+    */
+    if(cuddIsConstant(f) && cuddIsConstant(g)){
+      CUDD_VALUE_TYPE res_n;
+
+      res_n = ((CUDD_VALUE_TYPE (*)(CUDD_VALUE_TYPE, CUDD_VALUE_TYPE, void*))op)(cuddV(f),cuddV(g),arg);
+      if (res_n == NULL) return(NULL);
+      return(cuddUniqueConst(dd,res_n));
+    }
+
+    /* Check cache */
+    res = cuddCacheLookup2(dd,(DdNode * (*)())op,f,g);
+    if (res != NULL) return(res);
+
+    /* Recursive Step */
+    ford = cuddI(dd,f->index);
+    gord = cuddI(dd,g->index);
+    if (ford <= gord) {
+	index = f->index;
+	fv = cuddT(f);
+	fvn = cuddE(f);
+    } else {
+	index = g->index;
+	fv = fvn = f;
+    }
+    if (gord <= ford) {
+	gv = cuddT(g);
+	gvn = cuddE(g);
+    } else {
+	gv = gvn = g;
+    }
+
+    T = cudd_addApplyRecur(dd,op,fv,gv,arg);
+    if (T == NULL) return(NULL);
+    cuddRef(T);
+
+    E = cudd_addApplyRecur(dd,op,fvn,gvn,arg);
+    if (E == NULL) {
+	Cudd_RecursiveDeref(dd,T);
+	return(NULL);
+    }
+    cuddRef(E);
+
+    /* Necessary to have ROBDD */
+    res = (T == E) ? T : cuddUniqueInter(dd,(int)index,T,E);
+    if (res == NULL) {
+	Cudd_RecursiveDeref(dd, T);
+	Cudd_RecursiveDeref(dd, E);
+	return(NULL);
+    }
+    cuddDeref(T);
+    cuddDeref(E);
+
+    /* Store result */
+    cuddCacheInsert2(dd,(DdNode * (*)())op,f,g,res);
+
+    return(res);
+
+} /* end of cudd_addApplyRecur */
+
+/**Function********************************************************************
+
+  Synopsis    [Performs the recursive step of Cudd_addAnd.]
+
+  Description [Performs the recursive step of Cudd_addAnd. Returns a
+  pointer to the result if successful; NULL otherwise.]
+
+  SideEffects [None]
+
+  SeeAlso     []
+
+******************************************************************************/
+DdNode *
+cudd_addAndRecur(
+DdManager *manager,
+DdNode    *f,
+DdNode    *g)
+{
+    DdNode *fv, *fnv, *gv, *gnv;
+    DdNode *_true, *_false, *r, *t, *e;
+    unsigned int topf, topg, index;
+
+    _true  = DD_TRUE(manager);
+    _false = DD_FALSE(manager);
+
+    /* Terminal cases. */
+    if (f == _false || g == _false) return(_false);
+    if (f == g || g == _true) return(f);
+    if (f == _true) return(g);
+
+    HANDLE_FAILURE(manager, f); HANDLE_FAILURE(manager, g);
+
+    if (cuddIsConstant(f)) Cudd_type_error(manager, cuddV(f));
+    if (cuddIsConstant(g)) Cudd_type_error(manager, cuddV(g));
+
+    /* At this point f and g are not constant. */
+    if (f < g) { /* Try to increase cache efficiency. */
+	DdNode *tmp = f;
+	f = g;
+	g = tmp;
+    }
+
+    /* Check cache. */
+    r = cuddCacheLookup2(manager, Cudd_addAnd, f, g);
+    if (r != NULL) return(r);
+
+    topf = manager->perm[f->index];
+    topg = manager->perm[g->index];
+
+    /* Compute cofactors. */
+    if (topf <= topg) {
+	index = f->index;
+	fv = cuddT(f);
+	fnv = cuddE(f);
+    } else {
+	index = g->index;
+	fv = fnv = f;
+    }
+
+    if (topg <= topf) {
+	gv = cuddT(g);
+	gnv = cuddE(g);
+    } else {
+	gv = gnv = g;
+    }
+
+    t = cudd_addAndRecur(manager, fv, gv);
+    if (t == NULL) return(NULL);
+    cuddRef(t);
+
+    e = cudd_addAndRecur(manager, fnv, gnv);
+    if (e == NULL) {
+	Cudd_RecursiveDeref(manager, t);
+	return(NULL);
+    }
+    cuddRef(e);
+
+    if (t == e) { /* Necessary to have ROBDD */
+	r = t;
+    } else {
+      r = cuddUniqueInter(manager,(int)index,t,e);
+      if (r == NULL) {
+        Cudd_RecursiveDeref(manager, t);
+        Cudd_RecursiveDeref(manager, e);
+        return(NULL);
+      }
+    }
+    cuddDeref(e);
+    cuddDeref(t);
+    cuddCacheInsert2(manager, Cudd_addAnd, f, g, r);
+    return(r);
+}
+
+
+/**Function********************************************************************
+
+  Synopsis    [Performs the recursive step of Cudd_addOr.]
+
+  Description [Performs the recursive step of Cudd_addOr. Returns a
+  pointer to the result if successful; NULL otherwise.]
+
+  SideEffects [None]
+
+  SeeAlso     []
+
+******************************************************************************/
+DdNode *
+cudd_addOrRecur(
+DdManager *manager,
+DdNode    *f,
+DdNode    *g)
+{
+    DdNode *fv, *fnv, *gv, *gnv;
+    DdNode *_true, *_false, *r, *t, *e;
+    unsigned int topf, topg, index;
+
+    _true  = DD_TRUE(manager);
+    _false = DD_FALSE(manager);
+
+    /* Terminal cases. */
+    if (f == _true || g == _true) return(_true);
+    if (f == g || g == _false) return(f);
+    if (f == _false) return(g);
+
+    HANDLE_FAILURE(manager, f); HANDLE_FAILURE(manager, g);
+
+    if (cuddIsConstant(f)) Cudd_type_error(manager, cuddV(f));
+    if (cuddIsConstant(g)) Cudd_type_error(manager, cuddV(g));
+
+    /* At this point f and g are not constant. */
+    if (f < g) { /* Try to increase cache efficiency. */
+	DdNode *tmp = f;
+	f = g;
+	g = tmp;
+    }
+
+    /* Check cache. */
+    r = cuddCacheLookup2(manager, Cudd_addOr, f, g);
+    if (r != NULL) return(r);
+
+    /* Here we can skip the use of cuddI, because the operands are known
+    ** to be non-constant.
+    */
+    topf = manager->perm[f->index];
+    topg = manager->perm[g->index];
+
+    /* Compute cofactors. */
+    if (topf <= topg) {
+	index = f->index;
+	fv = cuddT(f);
+	fnv = cuddE(f);
+    } else {
+	index = g->index;
+	fv = fnv = f;
+    }
+
+    if (topg <= topf) {
+	gv = cuddT(g);
+	gnv = cuddE(g);
+    } else {
+	gv = gnv = g;
+    }
+
+    t = cudd_addOrRecur(manager, fv, gv);
+    if (t == NULL) return(NULL);
+    cuddRef(t);
+
+    e = cudd_addOrRecur(manager, fnv, gnv);
+    if (e == NULL) {
+	Cudd_RecursiveDeref(manager, t);
+	return(NULL);
+    }
+    cuddRef(e);
+
+    if (t == e) {  /* Necessary to have ROBDD */
+	r = t;
+    } else {
+      r = cuddUniqueInter(manager,(int)index,t,e);
+      if (r == NULL) {
+        Cudd_RecursiveDeref(manager, t);
+        Cudd_RecursiveDeref(manager, e);
+        return(NULL);
+      }
+    }
+    cuddDeref(e);
+    cuddDeref(t);
+    cuddCacheInsert2(manager, Cudd_addOr, f, g, r);
+    return(r);
+}
+
+/**Function********************************************************************
+
+  Synopsis    [Performs the recursive step of Cudd_addXor.]
+
+  Description [Performs the recursive step of Cudd_addXor. Returns a
+  pointer to the result if successful; NULL otherwise.]
+
+  SideEffects [None]
+
+  SeeAlso     []
+
+******************************************************************************/
+DdNode *
+cudd_addXorRecur(
+DdManager *manager,
+DdNode    *f,
+DdNode    *g)
+{
+    DdNode *fv, *fnv, *gv, *gnv;
+    DdNode *_true, *_false, *r, *t, *e;
+    unsigned int topf, topg, index;
+
+    _true  = DD_TRUE(manager);
+    _false = DD_FALSE(manager);
+
+    /* Terminal cases. */
+    if ((f == _true) && (g == _true)) return(_false);
+    if (f == _false) return(g);
+    if (g == _false) return(f);
+    if (f == g) return(_false);
+
+    HANDLE_FAILURE(manager, f); HANDLE_FAILURE(manager, g);
+
+    if (f < g) { /* Try to increase cache efficiency and simplify tests. */
+	DdNode *tmp = f;
+	f = g;
+	g = tmp;
+    }
+
+    /* Check cache. */
+    r = cuddCacheLookup2(manager, Cudd_addXor, f, g);
+    if (r != NULL) return(r);
+
+    /* Here we can skip the use of cuddI, because the operands are known
+    ** to be non-constant.
+    */
+    topf = cuddI(manager, f->index);
+    topg = cuddI(manager, g->index);
+
+    /* Compute cofactors. */
+    if (topf == topg){
+      if (cuddIsConstant(f) && (f != _true) && (f != _false))
+        Cudd_type_error(manager, cuddV(f));
+      if (cuddIsConstant(g) && (g != _true) && (g != _false))
+        Cudd_type_error(manager, cuddV(g));
+      index = f->index;
+      fv  = cuddT(f);
+      fnv = cuddE(f);
+      gv  = cuddT(g);
+      gnv = cuddE(g);
+    } else {
+      if (topf < topg) {
+        if (cuddIsConstant(f) && (f != _true) && (f != _false))
+          Cudd_type_error(manager, cuddV(f));
+	index = f->index;
+	fv = cuddT(f);
+	fnv = cuddE(f);
+	gv = gnv = g;
+      } else { /* topf > topg */
+        if (cuddIsConstant(g) && (g != _true) && (g != _false))
+          Cudd_type_error(manager, cuddV(g));
+	index = g->index;
+	fv = fnv = f;
+	gv = cuddT(g);
+	gnv = cuddE(g);
+      }
+    }
+
+    t = cudd_addXorRecur(manager, fv, gv);
+    if (t == NULL) return(NULL);
+    cuddRef(t);
+
+    e = cudd_addXorRecur(manager, fnv, gnv);
+    if (e == NULL) {
+	Cudd_RecursiveDeref(manager, t);
+	return(NULL);
+    }
+    cuddRef(e);
+
+    if (t == e) { /* Necessary to have RODD. */
+	r = t;
+    } else {
+      r = cuddUniqueInter(manager,(int)index,t,e);
+      if (r == NULL) {
+        Cudd_RecursiveDeref(manager, t);
+        Cudd_RecursiveDeref(manager, e);
+        return(NULL);
+      }
+    }
+    cuddDeref(e);
+    cuddDeref(t);
+    cuddCacheInsert2(manager, Cudd_addXor, f, g, r);
+    return(r);
+
+}
+
+/**Function********************************************************************
+
+  Synopsis    [Performs the recursive step of Cudd_addIfThen.]
+
+  Description [Performs the recursive step of Cudd_addIfThen. Returns a
+  pointer to the result if successful; NULL otherwise.]
+
+  SideEffects [None]
+
+  SeeAlso     []
+
+******************************************************************************/
+
+DdNode *
+cudd_addIfThenRecur(
+DdManager *dd,
+DdNode    *f,
+DdNode    *g)
+{
+  DdNode       *_true, *_false, *fv, *fnv, *gv, *gnv;
+  DdNode       *e, *t, *res;
+  unsigned int topf, topg;
+  int          index;
+
+  _true =  DD_TRUE(dd);
+  _false = DD_FALSE(dd);
+
+  if( f == _false ) return(cuddUniqueConst(dd, CUDD_ELSE_CNST));
+  if( f == _true  ) return(g);
+
+  HANDLE_FAILURE(dd, f); HANDLE_FAILURE(dd, g);
+
+  if( cuddIsConstant(f) ) Cudd_type_error(dd, cuddV(f));
+
+  /* Check cache */
+  res = cuddCacheLookup2(dd,Cudd_addIfThen,f,g);
+  if (res != NULL) return(res);
+
+  topf = cuddI(dd,f->index);
+  topg = cuddI(dd,g->index);
+
+  if(topf == topg) {
+    index = f->index;
+    fv  = cuddT(f);
+    fnv = cuddE(f);
+    gv  = cuddT(g);
+    gnv = cuddE(g);
+  } else {
+    if (topf < topg) {
+      index = f->index;
+      fv  = cuddT(f);
+      fnv = cuddE(f);
+      gv  = gnv = g;
+    } else { /* topf > topg */
+      index = g->index;
+      fv  = fnv = f;
+      gv  = cuddT(g);
+      gnv = cuddE(g);
+    }
+  }
+
+  t = cudd_addIfThenRecur(dd,fv,gv);
+  if (t == NULL) return(NULL);
+  cuddRef(t);
+
+  e = cudd_addIfThenRecur(dd,fnv,gnv);
+  if (e == NULL) {
+    Cudd_RecursiveDeref(dd,t);
+    return(NULL);
+  }
+  cuddRef(e);
+
+  res = (t == e) ? t : cuddUniqueInter(dd,index,t,e);
+  if (res == NULL) {
+    Cudd_RecursiveDeref(dd,t);
+    Cudd_RecursiveDeref(dd,e);
+    return(NULL);
+  }
+  cuddDeref(t);
+  cuddDeref(e);
+
+  /* Store result */
+  cuddCacheInsert2(dd,Cudd_addIfThen,f,g,res);
+
+  return(res);
+
+}
+
+/**Function********************************************************************
+
+  Synopsis    [Performs the recursive step of Cudd_addElse.]
+
+  Description [Performs the recursive step of Cudd_addElse. Returns a
+  pointer to the result if successful; NULL otherwise.]
+
+  SideEffects [None]
+
+  SeeAlso     []
+
+******************************************************************************/
+DdNode *
+cudd_addElseRecur(
+DdManager *dd,
+DdNode    *f,
+DdNode    *g)
+{
+  DdNode       *fv, *fnv, *gv, *gnv;
+  DdNode       *t, *e, *res;
+  unsigned int topf, topg;
+  int          index;
+
+  if (cuddIsConstant(f)) return(((cuddV(f) != CUDD_ELSE_CNST) ? f : g));
+
+  res = cuddCacheLookup2(dd,Cudd_addElse,f,g);
+  if (res != NULL) return(res);
+
+  topf = cuddI(dd,f->index);
+  topg = cuddI(dd,g->index);
+  if (topf == topg){
+    index = f->index;
+    fv  = cuddT(f);
+    fnv = cuddE(f);
+    gv  = cuddT(g);
+    gnv = cuddE(g);
+  } else {
+    if (topf < topg) {
+      index = f->index;
+      fv  = cuddT(f);
+      fnv = cuddE(f);
+      gv  = gnv = g;
+    } else { /* topf > topg */
+      index = g->index;
+      fv  = fnv = f;
+      gv  = cuddT(g);
+      gnv = cuddE(g);
+    }
+  }
+
+  t = cudd_addElseRecur(dd,fv,gv);
+  if (t == NULL) return(NULL);
+  cuddRef(t);
+
+  e = cudd_addElseRecur(dd,fnv,gnv);
+  if (e == NULL) {
+    Cudd_RecursiveDeref(dd,t);
+    return(NULL);
+  }
+  cuddRef(e);
+
+  res = (t == e) ? t : cuddUniqueInter(dd,index,t,e);
+  if (res == NULL) {
+    Cudd_RecursiveDeref(dd,t);
+    Cudd_RecursiveDeref(dd,e);
+    return(NULL);
+  }
+  cuddDeref(t);
+  cuddDeref(e);
+
+  /* Store result */
+  cuddCacheInsert2(dd,Cudd_addElse,f,g,res);
+
+  return(res);
+
+}
+
+/**Function********************************************************************
+
+  Synopsis    [Performs the recursive step of Cudd_addCubeDiff.]
+
+  Description [Performs the recursive step of Cudd_addCubeDiff.
+  Returns a pointer to the result if successful; NULL otherwise.]
+
+  SideEffects [None]
+
+  SeeAlso     []
+
+******************************************************************************/
+
+DdNode *
+cudd_addCubeDiffRecur(
+DdManager * dd,
+DdNode    * f,
+DdNode    * g)
+{
+  DdNode       * t,  * e , * res;
+  DdNode       * tf, * tg;
+  unsigned int topf, topg;
+  DdNode       * _false = DD_FALSE(dd);
+  DdNode       * _true  = DD_TRUE(dd);
+
+  if ((f == _false) || (g == _false))
+    Cudd_fatal_error(dd, "cudd_addCubeDiff: f == FALSE || g == FALSE");
+  if(f == _true) return(f);
+
+  topf = cuddI(dd,f->index);
+  topg = cuddI(dd,g->index);
+
+  if (topf < topg) {
+    e = _false;
+    cuddRef(e);
+    tf = cuddT(f);
+    t = cudd_addCubeDiffRecur(dd, tf, g);
+    if (t == NULL) {
+      cuddDeref(e);
+      return(NULL);
+    }
+    cuddRef(t);
+    res = (t == e) ? t : cuddUniqueInter(dd,f->index, t, e);
+    if (res == NULL) {
+      cuddDeref(e);
+      Cudd_RecursiveDeref(dd, t);
+      return(NULL);
+    }
+    cuddDeref(t);
+    cuddDeref(e);
+    return(res);
+  }
+  else if (topf == topg) {
+    tf = cuddT(f);
+    tg = cuddT(g);
+    res = cudd_addCubeDiffRecur(dd, tf, tg);
+    return(res);
+  }
+  else {
+    tg = cuddT(g);
+    res = cudd_addCubeDiffRecur(dd, f, tg);
+    return(res);
+  }
+}
+
+
+
+/*---------------------------------------------------------------------------*/
+/* Definition of static functions                                            */
+/*---------------------------------------------------------------------------*/
+static CUDD_VALUE_TYPE Cudd_type_error(DdManager *dd, CUDD_VALUE_TYPE f)
+{
+  dd->type_error_fun(dd, dd->err, f, dd->env_arg);
+  return NULL;
+}
+
+static CUDD_VALUE_TYPE Cudd_fatal_error(DdManager *dd, const char * message)
+{
+  dd->fatal_error_fun(dd, dd->err, message, dd->env_arg);
+  return NULL;
+}
+
+/**Function********************************************************************
+
+  Synopsis    [Checks whether cube is an ADD representing the product
+  of positive literals.]
+
+  Description [Checks whether cube is an ADD representing the product of
+  positive literals. Returns 1 in case of success; 0 otherwise.]
+
+  SideEffects [None]
+
+  SeeAlso     []
+
+******************************************************************************/
+static int
+addCheckPositiveCube(
+  DdManager * manager,
+  DdNode * cube)
+{
+    if (Cudd_IsComplement(cube)) return(0);
+    if (cube == DD_TRUE(manager)) return(1);
+    if (cuddIsConstant(cube)) return(0);
+    if (cuddE(cube) == DD_FALSE(manager)) {
+        return(addCheckPositiveCube(manager, cuddT(cube)));
+    }
+    return(0);
+
+} /* end of addCheckPositiveCube */
+
+/**Function********************************************************************
+
+  Synopsis    [Performs the recursive step of Cudd_addAbstract.]
+
+  Description [Performs the recursive step of Cudd_addAbstract.
+  Returns the ADD obtained by abstracting the variables of cube from f,
+  if successful; NULL otherwise.]
+
+  SideEffects [None]
+
+  SeeAlso     []
+
+******************************************************************************/
+DdNode *
+addAbstractRecur(
+  DdManager * manager,
+  CUDD_VALUE_TYPE (*op)(),
+  DdNode * f,
+  DdNode * cube,
+  void* arg)
+{
+    DdNode	*T, *E, *res, *res1, *res2, *_false;
+
+    statLine(manager);
+    _false = DD_FALSE(manager);
+
+    /* Cube is guaranteed to be a cube at this point. */
+    if (f == _false || cuddIsConstant(cube)) {
+        return(f);
+    }
+
+    /* Abstract a variable that does not appear in f */
+    if (cuddI(manager,f->index) > cuddI(manager,cube->index)) {
+      res1 = addAbstractRecur(manager, op, f, cuddT(cube), arg);
+	if (res1 == NULL) return(NULL);
+	cuddRef(res1);
+	/* Use the "internal" procedure to be alerted in case of
+	** dynamic reordering. If dynamic reordering occurs, we
+	** have to abort the entire abstraction.
+	*/
+	res = cudd_addApplyRecur(manager,op,res1,res1,arg);
+	if (res == NULL) {
+	    Cudd_RecursiveDeref(manager,res1);
+	    return(NULL);
+	}
+	cuddRef(res);
+	Cudd_RecursiveDeref(manager,res1);
+	cuddDeref(res);
+        return(res);
+    }
+
+    if ((res = cuddCacheLookup2(manager, (DdNode * (*)())(((char*)op)+1), f, cube)) != NULL) {
+	return(res);
+    }
+
+    T = cuddT(f);
+    E = cuddE(f);
+
+    /* If the two indices are the same, so are their levels. */
+    if (f->index == cube->index) {
+      res1 = addAbstractRecur(manager, op, T, cuddT(cube), arg);
+	if (res1 == NULL) return(NULL);
+        cuddRef(res1);
+	res2 = addAbstractRecur(manager, op, E, cuddT(cube), arg);
+	if (res2 == NULL) {
+	    Cudd_RecursiveDeref(manager,res1);
+	    return(NULL);
+	}
+        cuddRef(res2);
+	res = cudd_addApplyRecur(manager, op, res1, res2, arg);
+	if (res == NULL) {
+	    Cudd_RecursiveDeref(manager,res1);
+	    Cudd_RecursiveDeref(manager,res2);
+	    return(NULL);
+	}
+	cuddRef(res);
+	Cudd_RecursiveDeref(manager,res1);
+	Cudd_RecursiveDeref(manager,res2);
+	/* function/void pointer arithmetics is illegal, allowed by
+         * gcc extension */
+	cuddCacheInsert2(manager, (DdNode * (*)())(((char*)op)+1), f, cube, res);
+	cuddDeref(res);
+        return(res);
+    } else { /* if (cuddI(manager,f->index) < cuddI(manager,cube->index)) */
+      res1 = addAbstractRecur(manager, op, T, cube, arg);
+	if (res1 == NULL) return(NULL);
+        cuddRef(res1);
+	res2 = addAbstractRecur(manager, op, E, cube, arg);
+	if (res2 == NULL) {
+	    Cudd_RecursiveDeref(manager,res1);
+	    return(NULL);
+	}
+        cuddRef(res2);
+	res = cuddUniqueInter(manager, (int) f->index, res1, res2);
+	if (res == NULL) {
+	    Cudd_RecursiveDeref(manager,res1);
+	    Cudd_RecursiveDeref(manager,res2);
+	    return(NULL);
+	}
+	cuddDeref(res1);
+	cuddDeref(res2);
+	/* pointer arithmetic illegal as a gcc extension */
+	cuddCacheInsert2(manager, (DdNode * (*)())(((char*)op)+1), f, cube, res);
+        return(res);
+    }
+
+} /* end of addAbstractRecur */
diff -Nru a/cudd/cuddAddWalsh.c b/cudd/cuddAddWalsh.c
--- a/cudd/cuddAddWalsh.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddAddWalsh.c	2024-05-03 15:06:21.835159836 +0200
@@ -77,7 +77,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddAddWalsh.c,v 1.9 2004/08/13 18:04:46 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddAddWalsh.c,v 1.1.2.1 2010-02-04 10:41:15 nusmv Exp $";
 #endif
 
 
@@ -215,7 +215,7 @@
 	} else {
 	    index = top+k;
 	}
-	var = cuddUniqueInter(dd,index,DD_ONE(dd),DD_ZERO(dd));
+	var = cuddUniqueInter(dd,index,DD_TRUE(dd),DD_FALSE(dd));
 	if (var == NULL) {
 	    for (j = 0; j < m; j++) {
 		Cudd_RecursiveDeref(dd,array[previous][j]);
@@ -301,9 +301,10 @@
     DdNode *t, *u, *t1, *u1, *v, *w;
     int     i;
 
-    one = DD_ONE(dd);
+    one = DD_TRUE(dd);
     if (n == 0) return(one);
 
+#warning [AMa] Here number is even not created as NuSMV number..
     /* Build bottom part of ADD outside loop */
     minusone = cuddUniqueConst(dd,(CUDD_VALUE_TYPE) -1);
     if (minusone == NULL) return(NULL);
diff -Nru a/cudd/cuddAndAbs.c b/cudd/cuddAndAbs.c
--- a/cudd/cuddAndAbs.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddAndAbs.c	2024-05-03 15:06:21.835159836 +0200
@@ -76,7 +76,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddAndAbs.c,v 1.19 2004/08/13 18:04:46 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddAndAbs.c,v 1.1.2.1 2010-02-04 10:41:15 nusmv Exp $";
 #endif
 
 
@@ -200,24 +200,24 @@
   DdNode * cube)
 {
     DdNode *F, *ft, *fe, *G, *gt, *ge;
-    DdNode *one, *zero, *r, *t, *e;
+    DdNode *_true, *_false, *r, *t, *e;
     unsigned int topf, topg, topcube, top, index;
 
     statLine(manager);
-    one = DD_ONE(manager);
-    zero = Cudd_Not(one);
+    _true = DD_TRUE(manager);
+    _false = Cudd_Not(_true);
 
     /* Terminal cases. */
-    if (f == zero || g == zero || f == Cudd_Not(g)) return(zero);
-    if (f == one && g == one)	return(one);
+    if (f == _false || g == _false || f == Cudd_Not(g)) return(_false);
+    if (f == _true && g == _true)	return(_true);
 
-    if (cube == one) {
+    if (cube == _true) {
 	return(cuddBddAndRecur(manager, f, g));
     }
-    if (f == one || f == g) {
+    if (f == _true || f == g) {
 	return(cuddBddExistAbstractRecur(manager, g, cube));
     }
-    if (g == one) {
+    if (g == _true) {
 	return(cuddBddExistAbstractRecur(manager, f, cube));
     }
     /* At this point f, g, and cube are not constant. */
@@ -240,7 +240,7 @@
 
     while (topcube < top) {
 	cube = cuddT(cube);
-	if (cube == one) {
+	if (cube == _true) {
 	    return(cuddBddAndRecur(manager, f, g));
 	}
 	topcube = manager->perm[cube->index];
@@ -288,7 +288,7 @@
 	** Notice that t == fe implies that fe does not depend on the
 	** variables in Cube. Likewise for t == ge.
 	*/
-	if (t == one || t == fe || t == ge) {
+	if (t == _true || t == fe || t == ge) {
 	    if (F->ref != 1 || G->ref != 1)
 		cuddCacheInsert(manager, DD_BDD_AND_ABSTRACT_TAG,
 				f, g, cube, t);
diff -Nru a/cudd/cuddAnneal.c b/cudd/cuddAnneal.c
--- a/cudd/cuddAnneal.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddAnneal.c	2024-05-03 15:06:21.835159836 +0200
@@ -92,7 +92,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddAnneal.c,v 1.14 2004/08/13 18:04:46 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddAnneal.c,v 1.1.2.1 2010-02-04 10:41:15 nusmv Exp $";
 #endif
 
 #ifdef DD_STATS
diff -Nru a/cudd/cuddApa.c b/cudd/cuddApa.c
--- a/cudd/cuddApa.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddApa.c	2024-05-03 15:06:21.835159836 +0200
@@ -75,7 +75,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddApa.c,v 1.16 2004/08/13 18:04:46 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddApa.c,v 1.1.2.1 2010-02-04 10:41:15 nusmv Exp $";
 #endif
 
 static	DdNode	*background, *zero;
diff -Nru a/cudd/cuddAPI.c b/cudd/cuddAPI.c
--- a/cudd/cuddAPI.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddAPI.c	2024-05-03 15:06:21.835159836 +0200
@@ -211,7 +211,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddAPI.c,v 1.57 2004/08/13 18:04:45 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddAPI.c,v 1.1.2.1 2010-02-04 10:41:15 nusmv Exp $";
 #endif
 
 /*---------------------------------------------------------------------------*/
@@ -243,7 +243,7 @@
   index equal to the largest previous index plus 1.  Returns a
   pointer to the new variable if successful; NULL otherwise.
   An ADD variable differs from a BDD variable because it points to the
-  arithmetic zero, instead of having a complement pointer to 1. ]
+  FALSE constant, instead of having a complement pointer to TRUE. ]
 
   SideEffects [None]
 
@@ -256,11 +256,14 @@
   DdManager * dd)
 {
     DdNode *res;
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
 
     if ((unsigned int) dd->size >= CUDD_MAXINDEX - 1) return(NULL);
     do {
 	dd->reordered = 0;
-	res = cuddUniqueInter(dd,dd->size,DD_ONE(dd),DD_ZERO(dd));
+	res = cuddUniqueInter(dd,dd->size,DD_TRUE(dd),DD_FALSE(dd));
     } while (dd->reordered == 1);
 
     return(res);
@@ -294,7 +297,7 @@
     if (!cuddInsertSubtables(dd,1,level)) return(NULL);
     do {
 	dd->reordered = 0;
-	res = cuddUniqueInter(dd,dd->size - 1,DD_ONE(dd),DD_ZERO(dd));
+	res = cuddUniqueInter(dd,dd->size - 1,DD_TRUE(dd),DD_FALSE(dd));
     } while (dd->reordered == 1);
 
     return(res);
@@ -322,7 +325,14 @@
     DdNode *res;
 
     if ((unsigned int) dd->size >= CUDD_MAXINDEX - 1) return(NULL);
+/* NuSMV: add begin */
+#if 0
+/* NuSMV: add end */
     res = cuddUniqueInter(dd,dd->size,dd->one,Cudd_Not(dd->one));
+/* NuSMV: add begin */
+#endif
+    res = cuddUniqueInter(dd,dd->size,dd->val_true,Cudd_Not(dd->val_true));
+/* NuSMV: add end */
 
     return(res);
 
@@ -367,8 +377,8 @@
   Description [Retrieves the ADD variable with index i if it already
   exists, or creates a new ADD variable.  Returns a pointer to the
   variable if successful; NULL otherwise.  An ADD variable differs from
-  a BDD variable because it points to the arithmetic zero, instead of
-  having a complement pointer to 1. ]
+  a BDD variable because it points to the FALSE constant, instead of
+  having a complement pointer to TRUE. ]
 
   SideEffects [None]
 
@@ -386,7 +396,7 @@
     if ((unsigned int) i >= CUDD_MAXINDEX - 1) return(NULL);
     do {
 	dd->reordered = 0;
-	res = cuddUniqueInter(dd,i,DD_ONE(dd),DD_ZERO(dd));
+	res = cuddUniqueInter(dd,i,DD_TRUE(dd),DD_FALSE(dd));
     } while (dd->reordered == 1);
 
     return(res);
@@ -419,7 +429,14 @@
     if (i < dd->size) {
 	res = dd->vars[i];
     } else {
+/* NuSMV: add begin */
+#if 0
+/* NuSMV: add end */
 	res = cuddUniqueInter(dd,i,dd->one,Cudd_Not(dd->one));
+/* NuSMV: add begin */
+#endif
+	res = cuddUniqueInter(dd,i,dd->val_true,Cudd_Not(dd->val_true));
+/* NuSMV: add end */
     }
 
     return(res);
@@ -450,19 +467,22 @@
     DdNode *lower;
     int j;
 
-    if ((unsigned int) i >= CUDD_MAXINDEX - 1) return(NULL);
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
 
+    if ((unsigned int) i >= CUDD_MAXINDEX - 1) return(NULL);
     /* The i-th variable function has the following structure:
     ** at the level corresponding to index i there is a node whose "then"
-    ** child points to the universe, and whose "else" child points to zero.
+    ** child points to the universe, and whose "else" child points to FALSE.
     ** Above that level there are nodes with identical children.
     */
 
     /* First we build the node at the level of index i. */
-    lower = (i < dd->sizeZ - 1) ? dd->univ[dd->permZ[i]+1] : DD_ONE(dd);
+    lower = (i < dd->sizeZ - 1) ? dd->univ[dd->permZ[i]+1] : DD_TRUE(dd);
     do {
 	dd->reordered = 0;
-	zvar = cuddUniqueInterZdd(dd, i, lower, DD_ZERO(dd));
+	zvar = cuddUniqueInterZdd(dd, i, lower, DD_FALSE(dd));
     } while (dd->reordered == 1);
 
     if (zvar == NULL)
@@ -521,6 +541,10 @@
     int allnew;
     int *permutation;
 
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     if (multiplicity < 1) return(0);
     allnew = dd->sizeZ == 0;
     if (dd->size * multiplicity > dd->sizeZ) {
@@ -641,6 +665,10 @@
 Cudd_IsNonConstant(
   DdNode *f)
 {
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     return(f == DD_NON_CONSTANT || !Cudd_IsConstant(f));
 
 } /* end of Cudd_IsNonConstant */
@@ -966,7 +994,6 @@
 
 } /* end of Cudd_bddRealignDisable */
 
-
 /**Function********************************************************************
 
   Synopsis    [Returns the one constant of the manager.]
@@ -976,24 +1003,87 @@
 
   SideEffects [None]
 
-  SeeAlso [Cudd_ReadZero Cudd_ReadLogicZero Cudd_ReadZddOne]
+  SeeAlso [Cudd_ReadZero Cudd_ReadLogicZero Cudd_ReadZddTrue]
 
 ******************************************************************************/
 DdNode *
 Cudd_ReadOne(
   DdManager * dd)
 {
-    return(dd->one);
-
+  return(dd->one);
 } /* end of Cudd_ReadOne */
 
+/* NuSMV: add begin */
+/**Function********************************************************************
+
+  Synopsis    [Returns the TRUE constant of the manager.]
+
+  Description [Returns the TRUE constant of the manager. The TRUE
+  constant is common to ADDs and BDDs.]
+
+  SideEffects [None]
+
+  SeeAlso [Cudd_ReadZero Cudd_ReadLogicZero Cudd_ReadZddTrue]
+
+******************************************************************************/
+DdNode *
+Cudd_ReadTrue(
+  DdManager * dd)
+{
+    return DD_TRUE(dd);
+
+} /* end of Cudd_ReadTrue */
 
 /**Function********************************************************************
 
-  Synopsis    [Returns the ZDD for the constant 1 function.]
+  Synopsis    [Returns the FALSE constant of the manager.]
+
+  Description [Returns the FALSE constant of the manager. The FALSE
+  constant is the boolean FALSE, rather than the logic FALSE. The
+  latter is the complement of the TRUE constant.]
 
-  Description [Returns the ZDD for the constant 1 function.
-  The representation of the constant 1 function as a ZDD depends on
+  SideEffects [None]
+
+  SeeAlso [Cudd_ReadTrue Cudd_ReadLogicFalse]
+
+******************************************************************************/
+DdNode *
+Cudd_ReadFalse(
+  DdManager * dd)
+{
+    return(DD_FALSE(dd));
+
+} /* end of Cudd_ReadFalse */
+
+/**Function********************************************************************
+
+  Synopsis    [Returns the logic FALSE constant of the manager.]
+
+  Description [Returns the FALSE constant of the manager. The logic FALSE
+  constant is the complement of the TRUE constant, and is distinct from
+  the boolean FALSE.]
+
+  SideEffects [None]
+
+  SeeAlso [Cudd_ReadOne Cudd_ReadZero]
+
+******************************************************************************/
+DdNode *
+Cudd_ReadLogicFalse(
+  DdManager * dd)
+{
+    return(Cudd_Not(DD_TRUE(dd)));
+
+} /* end of Cudd_ReadLogicFalse */
+
+/* NuSMV: add end */
+
+/**Function********************************************************************
+
+  Synopsis    [Returns the ZDD for the constant TRUE function.]
+
+  Description [Returns the ZDD for the constant TRUE function.
+  The representation of the constant TRUE function as a ZDD depends on
   how many variables it (nominally) depends on. The index of the
   topmost variable in the support is given as argument <code>i</code>.]
 
@@ -1003,16 +1093,22 @@
 
 ******************************************************************************/
 DdNode *
+/* NuSMV: added begin */
+#if 0
+/* NuSMV: added end */
 Cudd_ReadZddOne(
+/* NuSMV: added begin */
+#endif
+Cudd_ReadZddTrue(
+/* NuSMV: added end */
   DdManager * dd,
   int  i)
 {
     if (i < 0)
 	return(NULL);
-    return(i < dd->sizeZ ? dd->univ[i] : DD_ONE(dd));
-
-} /* end of Cudd_ReadZddOne */
+    return(i < dd->sizeZ ? dd->univ[i] : DD_TRUE(dd));
 
+} /* end of Cudd_ReadZddTrue */
 
 
 /**Function********************************************************************
@@ -1036,7 +1132,6 @@
 
 } /* end of Cudd_ReadZero */
 
-
 /**Function********************************************************************
 
   Synopsis    [Returns the logic zero constant of the manager.]
@@ -1171,7 +1266,11 @@
 Cudd_ReadCacheUsedSlots(
   DdManager * dd)
 {
-    unsigned long used = 0;
+  /* NuSMV: add begin */
+    unsigned long long used = 0;
+    /* WAS: unsigned long used = 0; */
+  /* NuSMV: add end */
+
     int slots = dd->cacheSlots;
     DdCache *cache = dd->cache;
     int i;
@@ -1499,7 +1598,11 @@
 Cudd_ReadUsedSlots(
   DdManager * dd)
 {
-    unsigned long used = 0;
+  /* NuSMV: add begin */
+    unsigned long long used = 0;
+    /* WAS: unsigned long used = 0; */
+  /* NuSMV: add end */
+
     int i, j;
     int size = dd->size;
     DdNodePtr *nodelist;
@@ -2908,7 +3011,7 @@
   SeeAlso     []
 
 ******************************************************************************/
-unsigned long
+ptruint
 Cudd_ReadMemoryInUse(
   DdManager * dd)
 {
@@ -3061,6 +3164,14 @@
     if (retval == EOF) return(0);
     retval = fprintf(fp,"Number of dead ZDD nodes: %u\n", dd->deadZ);
     if (retval == EOF) return(0);
+    /* NuSMV: added begin */
+    retval = fprintf(fp,"Number of LIVE BDD and ADD nodes: %u\n", 
+                     dd->keys - dd->dead);
+    if (retval == EOF) return(0);
+    retval = fprintf(fp,"Number of LIVE ZDD nodes: %u\n", 
+                     dd->keysZ - dd->deadZ);
+    if (retval == EOF) return(0);
+    /* NuSMV: added end */
     retval = fprintf(fp,"Total number of nodes allocated: %.0f\n",
 		     dd->allocated);
     if (retval == EOF) return(0);
@@ -3190,7 +3301,7 @@
 	if (dd->vars[i]->ref == 1) count--;
     }
     /* Subtract from the count the unused constants. */
-    if (DD_ZERO(dd)->ref == 1) count--;
+    if (DD_FALSE(dd)->ref == 1) count--;
     if (DD_PLUS_INFINITY(dd)->ref == 1) count--;
     if (DD_MINUS_INFINITY(dd)->ref == 1) count--;
 
@@ -3498,7 +3609,11 @@
   const char *str,
   void *data)
 {
-    long initialTime = (long) data;
+  /* NuSMV: add end */
+    long initialTime = (long)(ptrint) data;
+    /* WAS: long initialTime = (long) data; */
+  /* NuSMV: add end */
+
     int retval;
     long finalTime = util_cpu_time();
     double totalTimeSec = (double)(finalTime - initialTime) / 1000.0;
@@ -3846,7 +3961,7 @@
   SeeAlso     [Cudd_SetMaxMemory]
 
 ******************************************************************************/
-unsigned long
+ptruint
 Cudd_ReadMaxMemory(
   DdManager *dd)
 {
@@ -3870,7 +3985,7 @@
 void
 Cudd_SetMaxMemory(
   DdManager *dd,
-  unsigned long maxMemory)
+  ptruint maxMemory)
 {
     dd->maxmemhard = maxMemory;
 
diff -Nru a/cudd/cuddApprox.c b/cudd/cuddApprox.c
--- a/cudd/cuddApprox.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddApprox.c	2024-05-03 15:06:21.835159836 +0200
@@ -73,7 +73,7 @@
 
 ******************************************************************************/
 
-#ifdef __STDC__
+#if defined(__STDC__)  || defined(_MSC_VER)
 #include <float.h>
 #else
 #define DBL_MAX_EXP 1024
@@ -147,7 +147,7 @@
     double impactP;
     double impactN;
 } GlobalQueueItem;
- 
+
 typedef struct LocalQueueItem {
     struct LocalQueueItem *next;
     struct LocalQueueItem *cnext;
@@ -158,13 +158,13 @@
 #pragma pointer_size restore
 #endif
 
-    
+
 /*---------------------------------------------------------------------------*/
 /* Variable declarations                                                     */
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddApprox.c,v 1.25 2004/08/13 18:04:46 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddApprox.c,v 1.1.2.1 2010-02-04 10:41:15 nusmv Exp $";
 #endif
 
 /*---------------------------------------------------------------------------*/
@@ -278,14 +278,14 @@
 {
     DdNode *subset, *g;
 
-    g = Cudd_Not(f);    
+    g = Cudd_Not(f);
     do {
 	dd->reordered = 0;
 	subset = cuddUnderApprox(dd, g, numVars, threshold, safe, quality);
     } while (dd->reordered == 1);
-    
+
     return(Cudd_NotCond(subset, (subset != NULL)));
-    
+
 } /* end of Cudd_OverApprox */
 
 
@@ -368,14 +368,14 @@
 {
     DdNode *subset, *g;
 
-    g = Cudd_Not(f);    
+    g = Cudd_Not(f);
     do {
 	dd->reordered = 0;
 	subset = cuddRemapUnderApprox(dd, g, numVars, threshold, quality);
     } while (dd->reordered == 1);
-    
+
     return(Cudd_NotCond(subset, (subset != NULL)));
-    
+
 } /* end of Cudd_RemapOverApprox */
 
 
@@ -467,15 +467,15 @@
 {
     DdNode *subset, *g;
 
-    g = Cudd_Not(f);    
+    g = Cudd_Not(f);
     do {
 	dd->reordered = 0;
 	subset = cuddBiasedUnderApprox(dd, g, b, numVars, threshold, quality1,
 				      quality0);
     } while (dd->reordered == 1);
-    
+
     return(Cudd_NotCond(subset, (subset != NULL)));
-    
+
 } /* end of Cudd_BiasedOverApprox */
 
 
@@ -909,6 +909,10 @@
     ApproxInfo	*info;
     NodeData *infoTop;
 
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     /* If user did not give numVars value, set it to the maximum
     ** exponent that the pow function can take. The -1 is due to the
     ** discrepancy in the value that pow takes and the value that
@@ -924,7 +928,7 @@
 	return(NULL);
     }
     info->max = pow(2.0,(double) numVars);
-    info->one = DD_ONE(dd);
+    info->one = DD_TRUE(dd);
     info->zero = Cudd_Not(info->one);
     info->size = Cudd_DagSize(node);
     /* All the information gathered will be stored in a contiguous
@@ -1257,7 +1261,7 @@
 
 /**Function********************************************************************
 
-  Synopsis    [Builds the subset BDD.] 
+  Synopsis    [Builds the subset BDD.]
 
   Description [Builds the subset BDD. Based on the info table,
   replaces selected nodes by zero. Returns a pointer to the result if
@@ -2154,7 +2158,11 @@
     NodeData *infoF;
     int careT, careE;
 
-    one = DD_ONE(dd);
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
+    one = DD_TRUE(dd);
     zero = Cudd_Not(one);
 
     if (!st_lookup(info->table, f, &infoF))
diff -Nru a/cudd/cuddBddAbs.c b/cudd/cuddBddAbs.c
--- a/cudd/cuddBddAbs.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddBddAbs.c	2024-05-03 15:06:21.835159836 +0200
@@ -86,7 +86,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddBddAbs.c,v 1.26 2004/08/13 18:04:46 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddBddAbs.c,v 1.1.2.1 2010-02-04 10:41:15 nusmv Exp $";
 #endif
 
 /*---------------------------------------------------------------------------*/
@@ -170,6 +170,10 @@
 {
     DdNode *res;
 
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     if (bddCheckPositiveCube(manager, cube) == 0) {
         (void) fprintf(manager->err,
 		       "Error: Can only abstract positive cubes\n");
@@ -249,7 +253,7 @@
     /* If the variable is not currently in the manager, f cannot
     ** depend on it.
     */
-    if (x >= manager->size) return(Cudd_Not(DD_ONE(manager)));
+    if (x >= manager->size) return(Cudd_Not(DD_TRUE(manager)));
     var = manager->vars[x];
 
     do {
@@ -287,7 +291,11 @@
     DD_CTFP cacheOp;
     int retval;
 
-    zero = Cudd_Not(DD_ONE(dd));
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
+    zero = Cudd_Not(DD_TRUE(dd));
     if (Cudd_IsConstant(f)) return(f == zero);
 
     /* From now on f is not constant. */
@@ -350,14 +358,13 @@
   DdNode * f,
   DdNode * cube)
 {
-    DdNode	*F, *T, *E, *res, *res1, *res2, *one;
-
+    DdNode	*F, *T, *E, *res, *res1, *res2, *_true;
     statLine(manager);
-    one = DD_ONE(manager);
+    _true = DD_TRUE(manager);
     F = Cudd_Regular(f);
 
     /* Cube is guaranteed to be a cube at this point. */	
-    if (cube == one || F == one) {  
+    if (cube == _true || F == _true) {  
         return(f);
     }
     /* From now on, f and cube are non-constant. */
@@ -365,7 +372,7 @@
     /* Abstract a variable that does not appear in f. */
     while (manager->perm[F->index] > manager->perm[cube->index]) {
 	cube = cuddT(cube);
-	if (cube == one) return(f);
+	if (cube == _true) return(f);
     }
 
     /* Check the cache. */
@@ -381,15 +388,15 @@
 
     /* If the two indices are the same, so are their levels. */
     if (F->index == cube->index) {
-	if (T == one || E == one || T == Cudd_Not(E)) {
-	    return(one);
+	if (T == _true || E == _true || T == Cudd_Not(E)) {
+	    return(_true);
 	}
 	res1 = cuddBddExistAbstractRecur(manager, T, cuddT(cube));
 	if (res1 == NULL) return(NULL);
-	if (res1 == one) {
+	if (res1 == _true) {
 	    if (F->ref != 1)
-		cuddCacheInsert2(manager, Cudd_bddExistAbstract, f, cube, one);
-	    return(one);
+		cuddCacheInsert2(manager, Cudd_bddExistAbstract, f, cube, _true);
+	    return(_true);
 	}
         cuddRef(res1);
 	res2 = cuddBddExistAbstractRecur(manager, E, cuddT(cube));
@@ -465,8 +472,12 @@
     DdNode *one, *zero, *r, *t, *e, *Cube;
     unsigned int topf, topg, topcube, top, index;
 
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     statLine(manager);
-    one = DD_ONE(manager);
+    one = DD_TRUE(manager);
     zero = Cudd_Not(one);
 
     /* Terminal cases. */
@@ -637,7 +648,7 @@
     statLine(manager);
     if (cuddI(manager,f->index) > manager->perm[var->index]) {
 	/* f does not depend on var. */
-	return(Cudd_Not(DD_ONE(manager)));
+	return(Cudd_Not(DD_TRUE(manager)));
     }
 
     /* From now on, f is non-constant. */
@@ -704,9 +715,9 @@
   DdNode * cube)
 {
     if (Cudd_IsComplement(cube)) return(0);
-    if (cube == DD_ONE(manager)) return(1);
+    if (cube == DD_TRUE(manager)) return(1);
     if (cuddIsConstant(cube)) return(0);
-    if (cuddE(cube) == Cudd_Not(DD_ONE(manager))) {
+    if (cuddE(cube) == Cudd_Not(DD_TRUE(manager))) {
         return(bddCheckPositiveCube(manager, cuddT(cube)));
     }
     return(0);
diff -Nru a/cudd/cuddBddCorr.c b/cudd/cuddBddCorr.c
--- a/cudd/cuddBddCorr.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddBddCorr.c	2024-05-03 15:06:21.835159836 +0200
@@ -86,7 +86,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddBddCorr.c,v 1.14 2004/08/13 18:04:46 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddBddCorr.c,v 1.1.2.1 2010-02-04 10:41:15 nusmv Exp $";
 #endif
 
 #ifdef CORREL_STATS
@@ -475,11 +475,15 @@
     int val = 0;
 
     entry = (HashEntry *) key;
-#if SIZEOF_VOID_P == 8 && SIZEOF_INT == 4
-    val = ((int) ((long)entry->f))*997 + ((int) ((long)entry->g));
-#else
-    val = ((int) entry->f)*997 + ((int) entry->g);
-#endif
+
+    /* NuSMV: add begin */
+    val = ((int) ((ptrint)entry->f))*997 + ((int) ((ptrint)entry->g));
+    /* WAS: #if NUSMV_SIZEOF_VOID_P == 8 && NUSMV_SIZEOF_INT == 4
+              val = ((int) ((long)entry->f))*997 + ((int) ((long)entry->g));
+            #else
+              val = ((int) entry->f)*997 + ((int) entry->g);
+            #endif */
+    /* NuSMV: add end */
 
     return ((val < 0) ? -val : val) % modulus;
 
diff -Nru a/cudd/cuddBddIte.c b/cudd/cuddBddIte.c
--- a/cudd/cuddBddIte.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddBddIte.c	2024-05-03 15:06:21.835159836 +0200
@@ -96,7 +96,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddBddIte.c,v 1.24 2004/08/13 18:04:46 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddBddIte.c,v 1.1.2.1 2010-02-04 10:41:15 nusmv Exp $";
 #endif
 
 /*---------------------------------------------------------------------------*/
@@ -174,17 +174,21 @@
   DdNode * h)
 {
     DdNode	 *r, *Fv, *Fnv, *Gv, *Gnv, *H, *Hv, *Hnv, *t, *e;
-    DdNode	 *one = DD_ONE(dd);
+    DdNode	 *one = DD_TRUE(dd);
     DdNode	 *zero = Cudd_Not(one);
     int		 comple;
     unsigned int topf, topg, toph, v;
 
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     statLine(dd);
     /* Trivial cases. */
-    if (f == one) 			/* ITE(1,G,H) => G */
+    if (f == one) 			/* ITE(TRUE,G,H) => G */
 	return(g);
     
-    if (f == zero)			/* ITE(0,G,H) => H */
+    if (f == zero)			/* ITE(FALSE,G,H) => H */
 	return(h);
     
     /* f now not a constant. */
@@ -534,7 +538,7 @@
   DdNode * f,
   DdNode * g)
 {
-    DdNode *one, *zero, *tmp, *F, *fv, *fvn, *gv, *gvn;
+    DdNode *_true, *_false, *tmp, *F, *fv, *fvn, *gv, *gvn;
     unsigned int topf, topg, res;
 
     statLine(dd);
@@ -559,19 +563,19 @@
     }
 
     /* Now g is regular and, if f is not regular, f < g. */
-    one = DD_ONE(dd);
-    if (g == one) return(1);	/* no need to test against zero */
-    if (f == one) return(0);	/* since at this point g != one */
+    _true = DD_TRUE(dd);
+    if (g == _true) return(1);	/* no need to test against _false */
+    if (f == _true) return(0);	/* since at this point g != _true */
     if (Cudd_Not(f) == g) return(0); /* because neither is constant */
-    zero = Cudd_Not(one);
-    if (f == zero) return(1);
+    _false = Cudd_Not(_true);
+    if (f == _false) return(1);
 
     /* Here neither f nor g is constant. */
 
     /* Check cache. */
     tmp = cuddCacheLookup2(dd,(DD_CTFP)Cudd_bddLeq,f,g);
     if (tmp != NULL) {
-	return(tmp == one);
+	return(tmp == _true);
     }
 
     /* Compute cofactors. */
@@ -601,7 +605,7 @@
     res = Cudd_bddLeq(dd,fvn,gvn) && Cudd_bddLeq(dd,fv,gv);
 
     /* Store result in cache and return. */
-    cuddCacheInsert2(dd,(DD_CTFP)Cudd_bddLeq,f,g,(res ? one : zero));
+    cuddCacheInsert2(dd,(DD_CTFP)Cudd_bddLeq,f,g,(res ? _true : _false));
     return(res);
 
 } /* end of Cudd_bddLeq */
@@ -632,47 +636,47 @@
   DdNode * g,
   DdNode * h)
 {
-    DdNode	 *one, *zero, *res;
+    DdNode	 *_true, *_false, *res;
     DdNode	 *r, *Fv, *Fnv, *Gv, *Gnv, *H, *Hv, *Hnv, *t, *e;
     unsigned int topf, topg, toph, v;
-    int		 index;
+    int		 index = 0;
     int		 comple;
 
     statLine(dd);
     /* Terminal cases. */
 
-    /* One variable cases. */
-    if (f == (one = DD_ONE(dd))) 	/* ITE(1,G,H) = G */
+    /* _True variable cases. */
+    if (f == (_true = DD_TRUE(dd))) 	/* ITE(TRUE,G,H) = G */
 	return(g);
     
-    if (f == (zero = Cudd_Not(one))) 	/* ITE(0,G,H) = H */
+    if (f == (_false = Cudd_Not(_true))) 	/* ITE(FALSE,G,H) = H */
 	return(h);
     
     /* From now on, f is known not to be a constant. */
-    if (g == one || f == g) {	/* ITE(F,F,H) = ITE(F,1,H) = F + H */
-	if (h == zero) {	/* ITE(F,1,0) = F */
+    if (g == _true || f == g) {	/* ITE(F,F,H) = ITE(F,TRUE,H) = F + H */
+	if (h == _false) {	/* ITE(F,TRUE,FALSE) = F */
 	    return(f);
 	} else {
 	    res = cuddBddAndRecur(dd,Cudd_Not(f),Cudd_Not(h));
 	    return(Cudd_NotCond(res,res != NULL));
 	}
-    } else if (g == zero || f == Cudd_Not(g)) { /* ITE(F,!F,H) = ITE(F,0,H) = !F * H */
-	if (h == one) {		/* ITE(F,0,1) = !F */
+    } else if (g == _false || f == Cudd_Not(g)) { /* ITE(F,!F,H) = ITE(F,FALSE,H) = !F * H */
+	if (h == _true) {		/* ITE(F,FALSE,TRUE) = !F */
 	    return(Cudd_Not(f));
 	} else {
 	    res = cuddBddAndRecur(dd,Cudd_Not(f),h);
 	    return(res);
 	}
     }
-    if (h == zero || f == h) {    /* ITE(F,G,F) = ITE(F,G,0) = F * G */
+    if (h == _false || f == h) {    /* ITE(F,G,F) = ITE(F,G,FALSE) = F * G */
 	res = cuddBddAndRecur(dd,f,g);
 	return(res);
-    } else if (h == one || f == Cudd_Not(h)) { /* ITE(F,G,!F) = ITE(F,G,1) = !F + G */
+    } else if (h == _true || f == Cudd_Not(h)) { /* ITE(F,G,!F) = ITE(F,G,TRUE) = !F + G */
 	res = cuddBddAndRecur(dd,f,Cudd_Not(g));
 	return(Cudd_NotCond(res,res != NULL));
     }
 
-    /* Check remaining one variable case. */
+    /* Check remaining _true variable case. */
     if (g == h) { 		/* ITE(F,G,G) = G */
 	return(g);
     } else if (g == Cudd_Not(h)) { /* ITE(F,G,!G) = F <-> G */
@@ -687,8 +691,8 @@
 
     v = ddMin(topg, toph);
 
-    /* A shortcut: ITE(F,G,H) = (v,G,H) if F = (v,1,0), v < top(G,H). */
-    if (topf < v && cuddT(f) == one && cuddE(f) == zero) {
+    /* A shortcut: ITE(F,G,H) = (v,G,H) if F = (v,TRUE,FALSE), v < top(G,H). */
+    if (topf < v && cuddT(f) == _true && cuddE(f) == _false) {
 	r = cuddUniqueInter(dd, (int) f->index, g, h);
 	return(Cudd_NotCond(r,comple && r != NULL));
     }
@@ -775,8 +779,12 @@
     DdNode *one, *zero;
     unsigned int index, topf, topg;
 
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     statLine(dd);
-    one = DD_ONE(dd);
+    one = DD_TRUE(dd);
     zero = Cudd_Not(one);
 
     /* Terminal cases. */
@@ -885,25 +893,25 @@
   DdNode * g)
 {
     DdNode *F, *fv, *fnv, *G, *gv, *gnv;
-    DdNode *one, *r, *t, *e;
+    DdNode *_true, *r, *t, *e;
     unsigned int topf, topg, index;
 
     statLine(manager);
-    one = DD_ONE(manager);
+    _true = DD_TRUE(manager);
 
     /* Terminal cases. */
     F = Cudd_Regular(f);
     G = Cudd_Regular(g);
     if (F == G) {
 	if (f == g) return(f);
-	else return(Cudd_Not(one));
+	else return(Cudd_Not(_true));
     }
-    if (F == one) {
-	if (f == one) return(g);
+    if (F == _true) {
+	if (f == _true) return(g);
 	else return(f);
     }
-    if (G == one) {
-	if (g == one) return(f);
+    if (G == _true) {
+	if (g == _true) return(f);
 	else return(g);
     }
 
@@ -1013,29 +1021,29 @@
   DdNode * g)
 {
     DdNode *fv, *fnv, *G, *gv, *gnv;
-    DdNode *one, *zero, *r, *t, *e;
+    DdNode *_true, *_false, *r, *t, *e;
     unsigned int topf, topg, index;
 
     statLine(manager);
-    one = DD_ONE(manager);
-    zero = Cudd_Not(one);
+    _true = DD_TRUE(manager);
+    _false = Cudd_Not(_true);
 
     /* Terminal cases. */
-    if (f == g) return(zero);
-    if (f == Cudd_Not(g)) return(one);
+    if (f == g) return(_false);
+    if (f == Cudd_Not(g)) return(_true);
     if (f > g) { /* Try to increase cache efficiency and simplify tests. */
 	DdNode *tmp = f;
 	f = g;
 	g = tmp;
     }
-    if (g == zero) return(f);
-    if (g == one) return(Cudd_Not(f));
+    if (g == _false) return(f);
+    if (g == _true) return(Cudd_Not(f));
     if (Cudd_IsComplement(f)) {
 	f = Cudd_Not(f);
 	g = Cudd_Not(g);
     }
     /* Now the first argument is regular. */
-    if (f == one) return(Cudd_Not(g));
+    if (f == _true) return(Cudd_Not(g));
 
     /* At this point f and g are not constant. */
 
@@ -1174,9 +1182,21 @@
 {
     register DdNode		*F, *G, *H, *r, *f, *g, *h;
     register unsigned int	topf, topg, toph;
+  /* NuSMV: add begin */
+#if 0
+  /* NuSMV: add end */
     DdNode			*one = dd->one;
+  /* NuSMV: add begin */
+#endif
+
+    DdNode			*one = DD_TRUE(dd);
+  /* NuSMV: add end */
     int				comple, change;
 
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     f = *fp;
     g = *gp;
     h = *hp;
@@ -1193,9 +1213,9 @@
 	if ((topf > toph) || (topf == toph && f > h)) {
 	    r = h;
 	    h = f;
-	    f = r;			/* ITE(F,1,H) = ITE(H,1,F) */
+	    f = r;			/* ITE(F,TRUE,H) = ITE(H,TRUE,F) */
 	    if (g != one) {	/* g == zero */
-		f = Cudd_Not(f);		/* ITE(F,0,H) = ITE(!H,0,!F) */
+		f = Cudd_Not(f);		/* ITE(F,FALSE,H) = ITE(!H,FALSE,!F) */
 		h = Cudd_Not(h);
 	    }
 	    change = 1;
@@ -1204,9 +1224,9 @@
 	if ((topf > topg) || (topf == topg && f > g)) {
 	    r = g;
 	    g = f;
-	    f = r;			/* ITE(F,G,0) = ITE(G,F,0) */
+	    f = r;			/* ITE(F,G,FALSE) = ITE(G,F,FALSE) */
 	    if (h == one) {
-		f = Cudd_Not(f);		/* ITE(F,G,1) = ITE(!G,!F,1) */
+		f = Cudd_Not(f);		/* ITE(F,G,TRUE) = ITE(!G,!F,TRUE) */
 		g = Cudd_Not(g);
 	    }
 	    change = 1;
diff -Nru a/cudd/cuddBddOp.c b/cudd/cuddBddOp.c
--- a/cudd/cuddBddOp.c	1970-01-01 01:00:00.000000000 +0100
+++ b/cudd/cuddBddOp.c	2024-05-03 15:06:21.835159836 +0200
@@ -0,0 +1,499 @@
+/**CFile***********************************************************************
+
+  FileName    [cuddBddOp.c]
+
+  PackageName [cudd]
+
+  Synopsis    [Some useful functions for manipulating BDD.]
+
+  Description [Some useful functions for manipulating BDD.]
+
+  Author      [Marco Roveri]
+
+  Copyright   [Copyright (C) 1998 by FBK-irst
+  All rights reserved.
+
+  Redistribution and use in source and binary forms, with or without
+  modification, are permitted provided that the following conditions
+  are met:
+
+  Redistributions of source code must retain the above copyright
+  notice, this list of conditions and the following disclaimer.
+
+  Redistributions in binary form must reproduce the above copyright
+  notice, this list of conditions and the following disclaimer in the
+  documentation and/or other materials provided with the distribution.
+
+  Neither the name of the University of Colorado nor the names of its
+  contributors may be used to endorse or promote products derived from
+  this software without specific prior written permission.
+
+  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+  "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
+  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+  LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+  ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+  POSSIBILITY OF SUCH DAMAGE.]
+
+******************************************************************************/
+
+#include    "util.h"
+#include    "st.h"
+#include    "cuddInt.h"
+
+/*---------------------------------------------------------------------------*/
+/* Constant declarations                                                     */
+/*---------------------------------------------------------------------------*/
+
+
+/*---------------------------------------------------------------------------*/
+/* Structure declarations                                                     */
+/*---------------------------------------------------------------------------*/
+
+
+/*---------------------------------------------------------------------------*/
+/* Type declarations                                                         */
+/*---------------------------------------------------------------------------*/
+
+
+/*---------------------------------------------------------------------------*/
+/* Variable declarations                                                     */
+/*---------------------------------------------------------------------------*/
+
+#ifndef lint
+static char rcsid[] DD_UNUSED = "$Id: cuddBddOp.c,v 1.1.2.1 2010-02-04 10:41:15 nusmv Exp $";
+#endif
+
+
+/*---------------------------------------------------------------------------*/
+/* Macro declarations                                                        */
+/*---------------------------------------------------------------------------*/
+
+/**AutomaticStart*************************************************************/
+/*---------------------------------------------------------------------------*/
+/* Static function prototypes                                                */
+/*---------------------------------------------------------------------------*/
+static int bddCheckPositiveCube (DdManager *, DdNode *);
+static void ddClearFlag (DdNode *);
+static CUDD_VALUE_TYPE Cudd_fatal_error (DdManager *, const char *);
+
+/**AutomaticEnd***************************************************************/
+
+/*---------------------------------------------------------------------------*/
+/* Definition of exported functions                                          */
+/*---------------------------------------------------------------------------*/
+/**Function********************************************************************
+
+  Synopsis    [Computes the difference between two BDD cubes.]
+
+  Description [Computes the set difference between two BDD cubes.]
+
+  SideEffects [None]
+
+  SeeAlso     []
+
+******************************************************************************/
+DdNode *
+Cudd_bddCubeDiff(
+DdManager * dd,
+DdNode * a,
+DdNode * b)
+{
+  DdNode * res;
+
+  if (bddCheckPositiveCube(dd, a) == 0) {
+    (void) fprintf(dd->err,"Error: (arg_1) Can only abstract positive cubes\n");
+    return(NULL);
+  }
+  if (bddCheckPositiveCube(dd, b) == 0) {
+    (void) fprintf(dd->err,"Error: (arg_2) Can only abstract positive cubes\n");
+    return(NULL);
+  }
+  do {
+    dd->reordered = 0;
+    res = cudd_bddCubeDiffRecur(dd, a, b);
+  } while (dd->reordered == 1);
+  return(res);
+}
+
+/**Function********************************************************************
+
+  Synopsis    []
+
+  Description []
+
+  SideEffects []
+
+  SeeAlso     []
+
+******************************************************************************/
+int 
+Cudd_BddGetLowestVar(
+DdManager *dd,
+DdNode * N)
+{
+  int res = Cudd_BddGetLowestVarRecur(dd, N, 0);
+  ddClearFlag(N);
+  return(Cudd_ReadInvPerm(dd, res));
+}
+
+/*---------------------------------------------------------------------------*/
+/* Definition of internal functions                                          */
+/*---------------------------------------------------------------------------*/
+
+/**Function********************************************************************
+
+  Synopsis    [Performs the recursive step of Cudd_bddCubeDiff.]
+
+  Description [Performs the recursive step of Cudd_bddCubeDiff.
+  Returns a pointer to the result if successful; NULL otherwise.]
+
+  SideEffects [None]
+
+  SeeAlso     []
+
+******************************************************************************/
+DdNode *
+cudd_bddCubeDiffRecur(
+DdManager * dd,
+DdNode    * f,
+DdNode    * g)
+{
+  DdNode       * t,  * e , * res;
+  DdNode       * tf, * tg;
+  unsigned int topf, topg;
+  DdNode       * _true  = DD_TRUE(dd);
+  DdNode       * _false = Cudd_Not(_true);
+  
+  if ((f == _false) || (g == _false))
+    Cudd_fatal_error(dd, "cudd_bddCubeDiff: f == FALSE || g == FALSE");
+  if (f == _true) return(f);
+
+  topf = cuddI(dd,f->index);
+  topg = cuddI(dd,g->index);
+
+  if (topf < topg) {
+    e = _false;
+    cuddRef(e);
+    tf = cuddT(f);
+    t = cudd_bddCubeDiffRecur(dd, tf, g);
+    if (t == NULL) {
+      cuddDeref(e);
+      return(NULL);
+    }
+    cuddRef(t);
+    res = (t == e) ? t : cuddUniqueInter(dd, f->index, t, e);
+    if (res == NULL) {
+      cuddDeref(e);
+      Cudd_RecursiveDeref(dd, t);
+      return(NULL);
+    }
+    cuddDeref(t);
+    cuddDeref(e);
+    return(res);
+  }
+  else if (topf == topg) {
+    tf = cuddT(f);
+    tg = cuddT(g);
+    res = cudd_bddCubeDiffRecur(dd, tf, tg);
+    return(res);
+  }
+  else {
+    tg = cuddT(g);
+    res = cudd_bddCubeDiffRecur(dd, f, tg);
+    return(res);
+  }
+}
+
+/**Function********************************************************************
+
+  Synopsis    []
+
+  Description []
+
+  SideEffects []
+
+  SeeAlso     []
+
+******************************************************************************/
+int 
+Cudd_BddGetLowestVarRecur(
+DdManager *dd,
+DdNode * N,
+int level)
+{
+  int i; 
+  DdNode * RN = Cudd_Regular(N);
+  /* if Cudd_IsComplement(RN->next) is true then the node has already been visited */
+  if (Cudd_IsComplement(RN->next) || cuddIsConstant(RN)) return(level);
+  RN->next = Cudd_Not(RN->next);
+  i = cuddI(dd, RN->index);
+  if (i > level) level = i;
+  return(Cudd_BddGetLowestVarRecur(dd, cuddT(RN),
+                              Cudd_BddGetLowestVarRecur(dd, cuddE(RN), level)));
+}
+
+/**Function********************************************************************
+
+  Synopsis           [Returns the array of All Possible Minterms]
+
+  Description        [Takes a minterm and returns an array of all its
+  terms, according to variables specified in the array vars[].  Notice
+  that the array of the result has to be previously allocated, and its
+  size must be greater or equal the number of the minterms of the "minterm"
+  function. The array contains referenced BDD so it is necessary to
+  dereference them after their use.]
+
+  SideEffects        []
+
+  SeeAlso            []
+
+******************************************************************************/
+int 
+Cudd_PickAllTerms(
+DdManager * dd      /* manager */,
+DdNode *    minterm /* minterm from which to pick  all term */,
+DdNode **   vars    /* The array of the vars to be put in the returned array */,
+int         n       /* The size of the above array */,
+DdNode **   result  /* The array used as return value */)
+{
+  CUDD_VALUE_TYPE value;
+  DdGen * gen;
+  int * cube;
+  int q;
+  int pos = 0;
+  int reorder_status = 0;
+  Cudd_ReorderingType Reorder_Method;
+
+  if (result == NULL) {
+    (void) fprintf(dd->err, "Cudd_PickAllTerms: result == NULL\n");
+    return 1;
+  }
+  
+  /*
+    Check the dynamic reordering status. If enabled, then the status
+    is saved in order to restore it after the operation. 
+  */
+  if (Cudd_ReorderingStatus(dd, &Reorder_Method)) {
+    Cudd_AutodynDisable(dd);
+    reorder_status = 1;
+  }
+  
+  Cudd_ForeachCube(dd, minterm, gen, cube, value) {
+    /* number of indifferent boolean variables */
+    int nd = 0;
+    /* We build the cube of the minterm. */
+
+    for(q = 0; q < n; q++) {
+      switch(cube[vars[q]->index]) {
+      case 0:
+      case 1:
+        break;
+      default:
+        nd += 1;
+        break;
+      }
+    }
+    { /* For each cube we expand the terms, i.e. all the assignments. */
+      int ** matrix;
+      int lim = 0;
+      int num_of_mint = (int)pow(2.0,(double)nd);
+
+      matrix = ALLOC(int *, num_of_mint+1);
+      if (matrix == NULL) {
+        fprintf(dd->err, "Cudd_PickAllTerms: Unable to allocate matrix[]\n");
+        return 1;
+      }
+      {
+        int i;
+        for (i = 0; i <= num_of_mint; i++) {
+          matrix[i] = ALLOC(int, n+1); 
+          if (matrix[i] == NULL) {
+            fprintf(dd->err, "Cudd_PickAllTerms: Unable to allocate matrix[%d][]\n", i);
+            return 1;
+          }
+        }
+      }
+
+      lim = 1;
+      for(q = 0; q < n; q++) {
+        switch(cube[vars[q]->index]) {
+        case 0: {
+          int i;
+          for(i = 0; i < num_of_mint; i++) matrix[i][q] = 0;
+          break;
+        }
+        case 1: {
+          int i;
+          for(i = 0; i < num_of_mint; i++) matrix[i][q] = 1;
+          break;
+        }
+        case 2: {
+          /*
+            The current variable is indifferent. It has to be expanded
+            considering the cases in which it is assigned a true value
+            and the cases in which it is assigned a false value.
+          */
+          int i, j;
+          i = 0;
+          j = (1<<(lim-1));
+          for (; j <= num_of_mint; ) {
+            for(; i < j  && i < num_of_mint; i++) matrix[i][q] = 1;
+            j += (1<<(lim-1));
+            for(; i < j && i < num_of_mint; i++) matrix[i][q] = 0;
+            j += (1<<(lim-1));
+          }
+          lim++;
+          break;
+        }
+        default:
+          (void) fprintf(dd->err,"\nCudd_PickAllTerms: unexpected switch value %d\n", cube[vars[q]->index]);
+          return 1;
+        }
+      }
+      {
+        int i, j;
+
+        for (j = 0; j < num_of_mint; j++) {
+          result[pos] = Cudd_ReadTrue(dd);
+          cuddRef(result[pos]);
+
+          /* sometimes it is better to start building the cube from
+             the higher order variables to the lower order variable to
+             avoid traversal of the BDD so far build to add the last
+             variable. Usually the orders of variables in vars
+             corresponds to the order of bdd variables */
+          for(i = n - 1; i >= 0; i--) {
+            DdNode * New;  
+
+            switch(matrix[j][i]) {
+            case 0: {
+              New = Cudd_bddAnd(dd, result[pos], Cudd_Not(vars[i]));
+              break;
+            }
+            case 1: {
+              New = Cudd_bddAnd(dd, result[pos], vars[i]);
+              break;
+            }
+            default: {
+              int k;
+
+              fprintf(dd->err, "Cudd_PickAllTerms: unexpected switch value %d\n", matrix[j][i]);
+              for(k = 0; k < num_of_mint; k++) FREE(matrix[k]);
+              FREE(matrix);
+              for(k = 0; k <= pos; k++) Cudd_RecursiveDeref(dd, result[k]);
+              return 1;
+            }
+            }
+              
+            if (New == NULL) {
+              int k;
+
+              for(k = 0; k < num_of_mint; k++) FREE(matrix[k]);
+              FREE(matrix);
+              for(k = 0; k <= pos; k++) Cudd_RecursiveDeref(dd, result[k]);
+              return 1;
+            }
+            cuddRef(New);
+            Cudd_RecursiveDeref(dd, result[pos]);
+            result[pos] = New;
+          }
+          pos++;
+        }
+      }
+      {
+        int k;
+
+        for(k = 0; k <= num_of_mint; k++) FREE(matrix[k]);
+        FREE(matrix);
+      }
+    }
+  } /* End of Cudd_ForeachCube */
+
+  /* If the case than the dynamic variable ordering is restored. */
+  if (reorder_status) Cudd_AutodynEnable(dd, Reorder_Method);
+  return 0;
+}
+
+/*---------------------------------------------------------------------------*/
+/* Definition of static functions                                            */
+/*---------------------------------------------------------------------------*/
+
+/**Function********************************************************************
+
+  Synopsis    [Performs a DFS from f, clearing the LSB of the next
+  pointers.]
+
+  Description []
+
+  SideEffects [None]
+
+  SeeAlso     [ddSupportStep ddDagInt]
+
+******************************************************************************/
+static void
+ddClearFlag(
+DdNode *f)
+{
+    if (!Cudd_IsComplement(f->next)) {
+	return;
+    }
+    /* Clear visited flag. */
+    f->next = Cudd_Regular(f->next);
+    if (cuddIsConstant(f)) {
+	return;
+    }
+    ddClearFlag(cuddT(f));
+    ddClearFlag(Cudd_Regular(cuddE(f)));
+    return;
+
+} /* end of ddClearFlag */
+
+/**Function********************************************************************
+
+  Synopsis [Checks whether cube is an BDD representing the product of
+  positive literals.]
+
+  Description [Returns 1 in case of success; 0 otherwise.]
+
+  SideEffects [None]
+
+******************************************************************************/
+static int
+bddCheckPositiveCube(
+DdManager *manager,
+DdNode	  *cube)
+{
+  if (Cudd_IsComplement(cube)) return(0);
+  if (cube == DD_TRUE(manager)) return(1);
+  if (cuddIsConstant(cube)) return(0);
+  if (cuddE(cube) == Cudd_Not(DD_TRUE(manager))) {
+    return(bddCheckPositiveCube(manager, cuddT(cube)));
+  }
+  return(0);
+} /* end of bddCheckPositiveCube */
+
+/**Function********************************************************************
+
+  Synopsis           [required]
+
+  Description        [optional]
+
+  SideEffects        [required]
+
+  SeeAlso            [optional]
+
+******************************************************************************/
+static CUDD_VALUE_TYPE Cudd_fatal_error(DdManager * dd, const char * message)
+{
+  dd->fatal_error_fun(dd, dd->err, message, dd->env_arg);
+  return(NULL);
+}
+
+
diff -Nru a/cudd/cuddBridge.c b/cudd/cuddBridge.c
--- a/cudd/cuddBridge.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddBridge.c	2024-05-03 15:06:21.835159836 +0200
@@ -94,7 +94,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddBridge.c,v 1.18 2004/08/13 18:04:46 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddBridge.c,v 1.1.2.1 2010-02-04 10:41:15 nusmv Exp $";
 #endif
 
 /*---------------------------------------------------------------------------*/
@@ -112,6 +112,11 @@
 /* Static function prototypes                                                */
 /*---------------------------------------------------------------------------*/
 
+/* NuSMV: add begin */
+static DdNode * addBddBooleanMap (DdManager *dd, DdNode *f);
+static DdNode * ddBddTo01AddRecur (DdManager *dd, DdNode *B);
+static DdNode * cuddAddCmpl01Recur (DdManager * dd, DdNode * f);
+/* NuSMV: add end */
 static DdNode * addBddDoThreshold (DdManager *dd, DdNode *f, DdNode *val);
 static DdNode * addBddDoStrictThreshold (DdManager *dd, DdNode *f, DdNode *val);
 static DdNode * addBddDoInterval (DdManager *dd, DdNode *f, DdNode *l, DdNode *u);
@@ -130,14 +135,46 @@
 /* Definition of exported functions                                          */
 /*---------------------------------------------------------------------------*/
 
+/* NuSMV: add begin */
+/**Function********************************************************************
+
+  Synopsis    [Converts an ADD to a BDD.]
+
+  Description [Converts an ADD to a BDD by replacing all discriminants
+  different from FALSE with TRUE, and all other discriminants with
+  FALSE. Only TRUE and FALSE leaves are admitted. Returns a pointer to
+  the resulting BDD if successful; NULL otherwise.]
+
+  SideEffects [None]
+
+  SeeAlso     [Cudd_addBddInterval Cudd_addBddPattern Cudd_BddToAdd
+  Cudd_addBddThreshold Cudd_addBddStrictThreshold]
+
+******************************************************************************/
+DdNode *
+Cudd_addBddBooleanMap(
+  DdManager * dd,
+  DdNode * f)
+{
+    DdNode *res;
+
+    do {
+      dd->reordered = 0;
+      res = addBddBooleanMap(dd, f);
+    } while (dd->reordered == 1);
+
+    return(res);
+
+} /* end of Cudd_addBddThreshold */
+/* NuSMV: add end */
 
 /**Function********************************************************************
 
   Synopsis    [Converts an ADD to a BDD.]
 
   Description [Converts an ADD to a BDD by replacing all
-  discriminants greater than or equal to value with 1, and all other
-  discriminants with 0. Returns a pointer to the resulting BDD if
+  discriminants greater than or equal to value with TRUE, and all other
+  discriminants with FALSE. Returns a pointer to the resulting BDD if
   successful; NULL otherwise.]
 
   SideEffects [None]
@@ -154,7 +191,10 @@
 {
     DdNode *res;
     DdNode *val;
-    
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     val = cuddUniqueConst(dd,value);
     if (val == NULL) return(NULL);
     cuddRef(val);
@@ -199,6 +239,9 @@
 {
     DdNode *res;
     DdNode *val;
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
     
     val = cuddUniqueConst(dd,value);
     if (val == NULL) return(NULL);
@@ -246,7 +289,11 @@
     DdNode *res;
     DdNode *l;
     DdNode *u;
-    
+
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     /* Create constant nodes for the interval bounds, so that we can use
     ** the global cache.
     */
@@ -302,11 +349,15 @@
 Cudd_addBddIthBit(
   DdManager * dd,
   DdNode * f,
-  int  bit)
+  ptrint  bit)
 {
     DdNode *res;
     DdNode *index;
-    
+
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     index = cuddUniqueConst(dd,(CUDD_VALUE_TYPE) bit);
     if (index == NULL) return(NULL);
     cuddRef(index);
@@ -330,9 +381,9 @@
 
 /**Function********************************************************************
 
-  Synopsis    [Converts a BDD to a 0-1 ADD.]
+  Synopsis    [Converts a BDD to a FALSE-TRUE ADD.]
 
-  Description [Converts a BDD to a 0-1 ADD. Returns a pointer to the
+  Description [Converts a BDD to a FALSE-TRUE ADD. Returns a pointer to the
   resulting ADD if successful; NULL otherwise.]
 
   SideEffects [None]
@@ -356,6 +407,35 @@
 
 } /* end of Cudd_BddToAdd */
 
+/* NuSMV: begin end */
+/**Function********************************************************************
+
+  Synopsis    [Converts a BDD to a 0-1 ADD.]
+
+  Description [Converts a BDD to a 0-1 ADD. Returns a pointer to the
+  resulting ADD if successful; NULL otherwise.]
+
+  SideEffects [None]
+
+  SeeAlso     [Cudd_addBddPattern Cudd_addBddThreshold Cudd_addBddInterval
+  Cudd_addBddStrictThreshold]
+
+******************************************************************************/
+DdNode *
+Cudd_BddTo01Add(
+  DdManager * dd,
+  DdNode * B)
+{
+    DdNode *res;
+
+    do {
+	dd->reordered = 0;
+	res = ddBddTo01AddRecur(dd, B);
+    } while (dd->reordered ==1);
+    return(res);
+
+} /* end of Cudd_BddToAdd */
+/* NuSMV: begin end */
 
 /**Function********************************************************************
 
@@ -377,7 +457,11 @@
   DdNode * f)
 {
     DdNode *res;
-    
+
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     do {
 	dd->reordered = 0;
 	res = cuddAddBddDoPattern(dd, f);
@@ -408,6 +492,10 @@
   DdNode * f)
 {
     DdNode *res;
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     do {
 	ddDestination->reordered = 0;
 	res = cuddBddTransfer(ddSource, ddDestination, f);
@@ -446,6 +534,10 @@
     st_generator *gen = NULL;
     DdNode *key, *value;
 
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     table = st_init_table(st_ptrcmp,st_ptrhash);
     if (table == NULL) goto failure;
     res = cuddBddTransferRecur(ddS, ddD, f, table);
@@ -494,10 +586,14 @@
     DdNode *fv, *fvn;
     int v;
 
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     statLine(dd);
     /* Check terminal case. */
     if (cuddIsConstant(f)) {
-	return(Cudd_NotCond(DD_ONE(dd),f == DD_ZERO(dd)));
+	return(Cudd_NotCond(DD_TRUE(dd),f == DD_FALSE(dd)));
     }
 
     /* Check cache. */
@@ -549,6 +645,82 @@
 /* Definition of static functions                                            */
 /*---------------------------------------------------------------------------*/
 
+/* NuSMV: add begin */
+/**Function********************************************************************
+
+  Synopsis    [Performs the recursive step for Cudd_addBddBooleanMap.]
+
+  Description [Performs the recursive step for Cudd_addBddBooleanMap.
+  Returns a pointer to the BDD if successful; NULL otherwise.]
+
+  SideEffects [None]
+
+  SeeAlso     [addBddDoStrictThreshold]
+
+******************************************************************************/
+static DdNode *
+addBddBooleanMap(
+  DdManager * dd,
+  DdNode * f)
+{
+    DdNode *res, *T, *E;
+    DdNode *fv, *fvn;
+    int v;
+
+    statLine(dd);
+    /* Check terminal case. */
+    if (cuddIsConstant(f)) {
+      if ((f != DD_TRUE(dd)) && (f != DD_FALSE(dd))) {
+        (void)fprintf(dd->err, "Error: Can only convert Add with FALSE or TRUE leaves to Bdd.");
+        return(NULL);
+      }
+      return(Cudd_NotCond(DD_TRUE(dd), f == DD_FALSE(dd)));
+    }
+
+    /* Check cache. */
+    res = cuddCacheLookup1(dd,addBddBooleanMap,f);
+    if (res != NULL) return(res);
+
+    /* Recursive step. */
+    v = f->index;
+    fv = cuddT(f); fvn = cuddE(f);
+
+    T = addBddBooleanMap(dd,fv);
+    if (T == NULL) return(NULL);
+    cuddRef(T);
+
+    E = addBddBooleanMap(dd,fvn);
+    if (E == NULL) {
+	Cudd_RecursiveDeref(dd, T);
+	return(NULL);
+    }
+    cuddRef(E);
+    if (Cudd_IsComplement(T)) {
+	res = (T == E) ? Cudd_Not(T) : cuddUniqueInter(dd,v,Cudd_Not(T),Cudd_Not(E));
+	if (res == NULL) {
+	    Cudd_RecursiveDeref(dd, T);
+	    Cudd_RecursiveDeref(dd, E);
+	    return(NULL);
+	}
+	res = Cudd_Not(res);
+    } else {
+	res = (T == E) ? T : cuddUniqueInter(dd,v,T,E);
+	if (res == NULL) {
+	    Cudd_RecursiveDeref(dd, T);
+	    Cudd_RecursiveDeref(dd, E);
+	    return(NULL);
+	}
+    }
+    cuddDeref(T);    
+    cuddDeref(E);
+
+    /* Store result. */
+    cuddCacheInsert1(dd,addBddBooleanMap,f,res);
+
+    return(res);
+
+} /* end of addBddBooleanMap */
+/* NuSMV: add end */
 
 /**Function********************************************************************
 
@@ -575,7 +747,7 @@
     statLine(dd);
     /* Check terminal case. */
     if (cuddIsConstant(f)) {
-	return(Cudd_NotCond(DD_ONE(dd),cuddV(f) < cuddV(val)));
+      return(Cudd_NotCond(DD_TRUE(dd),cuddV(f) < cuddV(val)));
     }
 
     /* Check cache. */
@@ -648,7 +820,7 @@
     statLine(dd);
     /* Check terminal case. */
     if (cuddIsConstant(f)) {
-	return(Cudd_NotCond(DD_ONE(dd),cuddV(f) <= cuddV(val)));
+	return(Cudd_NotCond(DD_TRUE(dd),cuddV(f) <= cuddV(val)));
     }
 
     /* Check cache. */
@@ -722,7 +894,7 @@
     statLine(dd);
     /* Check terminal case. */
     if (cuddIsConstant(f)) {
-	return(Cudd_NotCond(DD_ONE(dd),cuddV(f) < cuddV(l) || cuddV(f) > cuddV(u)));
+	return(Cudd_NotCond(DD_TRUE(dd),cuddV(f) < cuddV(l) || cuddV(f) > cuddV(u)));
     }
 
     /* Check cache. */
@@ -790,15 +962,23 @@
 {
     DdNode *res, *T, *E;
     DdNode *fv, *fvn;
-    int mask, value;
+    /* NuSMV: add begin */
+    ptrint mask, value;
+      /* WAS: long mask, value; */
+    /* NuSMV: add end */
+
     int v;
 
     statLine(dd);
     /* Check terminal case. */
     if (cuddIsConstant(f)) {
-	mask = 1 << ((int) cuddV(index));
-	value = (int) cuddV(f);
-	return(Cudd_NotCond(DD_ONE(dd),(value & mask) == 0));
+      /* NuSMV: add begin */
+	mask = 1 << ((ptrint) cuddV(index));
+	value = (ptrint) cuddV(f);
+        /* WAS: mask = 1 << ((long) cuddV(index));
+                value = (long) cuddV(f); */
+      /* NuSMV: add end */
+	return(Cudd_NotCond(DD_TRUE(dd),(value & mask) == 0));
     }
 
     /* Check cache. */
@@ -863,18 +1043,18 @@
   DdManager * dd,
   DdNode * B)
 {
-    DdNode *one;
+    DdNode *_true;
     DdNode *res, *res1, *T, *E, *Bt, *Be;
     int complement = 0;
 
     statLine(dd);
-    one = DD_ONE(dd);
+    _true = DD_TRUE(dd);
 
     if (Cudd_IsConstant(B)) {
-	if (B == one) {
-	    res = one;
+	if (B == _true) {
+	    res = _true;
 	} else {
-	    res = DD_ZERO(dd);
+	    res = DD_FALSE(dd);
 	}
 	return(res);
     }
@@ -932,6 +1112,89 @@
 
 } /* end of ddBddToAddRecur */
 
+/* NuSMV: add begin */
+/**Function********************************************************************
+
+  Synopsis    [Performs the recursive step for Cudd_BddTo01Add.]
+
+  Description [Performs the recursive step for Cudd_BddTo01Add. Returns a
+  pointer to the resulting ADD if successful; NULL otherwise.]
+
+  SideEffects [None]
+
+  SeeAlso     []
+
+******************************************************************************/
+static DdNode *
+ddBddTo01AddRecur(
+  DdManager * dd,
+  DdNode * B)
+{
+    DdNode *res, *res1, *T, *E, *Bt, *Be;
+    int complement = 0;
+
+    statLine(dd);
+
+    if (B == DD_TRUE(dd)) {
+      return DD_ONE(dd);
+    } else if (B == Cudd_Not(DD_TRUE(dd))) {
+      return DD_ZERO(dd);
+    }
+
+    /* Check visited table */
+    res = cuddCacheLookup1(dd,ddBddTo01AddRecur,B);
+    if (res != NULL) return(res);
+
+    if (Cudd_IsComplement(B)) {
+	complement = 1;
+	Bt = cuddT(Cudd_Regular(B));
+	Be = cuddE(Cudd_Regular(B));
+    } else {
+	Bt = cuddT(B);
+	Be = cuddE(B);
+    }
+
+    T = ddBddTo01AddRecur(dd, Bt);
+    if (T == NULL) return(NULL);
+    cuddRef(T);
+
+    E = ddBddTo01AddRecur(dd, Be);
+    if (E == NULL) {
+	Cudd_RecursiveDeref(dd, T);
+	return(NULL);
+    }
+    cuddRef(E);
+
+    /* No need to check for T == E, because it is guaranteed not to happen. */
+    res = cuddUniqueInter(dd, (int) Cudd_Regular(B)->index, T, E);
+    if (res == NULL) {
+	Cudd_RecursiveDeref(dd ,T);
+	Cudd_RecursiveDeref(dd ,E);
+	return(NULL);
+    }
+    cuddDeref(T);
+    cuddDeref(E);
+
+    if (complement) {
+	cuddRef(res);
+	res1 = cuddAddCmpl01Recur(dd, res);
+	if (res1 == NULL) {
+	    Cudd_RecursiveDeref(dd, res);
+	    return(NULL);
+	}
+	cuddRef(res1);
+	Cudd_RecursiveDeref(dd, res);
+	res = res1;
+	cuddDeref(res);
+    }
+
+    /* Store result. */
+    cuddCacheInsert1(dd,ddBddTo01AddRecur,B,res);
+
+    return(res);
+
+} /* end of ddBddTo01AddRecur */
+/* NuSMV: add end */
 
 /**Function********************************************************************
 
@@ -958,7 +1221,7 @@
     int    comple = 0;
 
     statLine(ddD);
-    one = DD_ONE(ddD);
+    one = DD_TRUE(ddD);
     comple = Cudd_IsComplement(f);
 
     /* Trivial cases. */
@@ -1014,3 +1277,66 @@
 
 } /* end of cuddBddTransferRecur */
 
+/* NuSMV: add end */
+/**Function********************************************************************
+
+  Synopsis    [Auxiliary routine for the BddTo01Add function]
+
+  Description [This is a copy of the cuddAddCmplRecur function,
+  declared in "cuddAddIte.c". The only difference between the original
+  version and the copy is that this copy returns a 0-1 ADD instead of
+  a F-T ADD. Returns a pointer to the resulting ADD if successful; NULL
+  otherwise.]
+
+  SideEffects [None]
+
+  SeeAlso     [cuddAddCmplRecur]
+
+******************************************************************************/
+static DdNode *
+cuddAddCmpl01Recur(
+  DdManager * dd,
+  DdNode * f)
+{
+    DdNode *one,*zero;
+    DdNode *r,*Fv,*Fnv,*t,*e;
+
+    statLine(dd);
+    one = DD_ONE(dd);
+    zero = DD_ZERO(dd); 
+
+    if (cuddIsConstant(f)) {
+        if (f == zero) {
+	    return(one);
+	} else {
+	    return(zero);
+	}
+    }
+    r = cuddCacheLookup1(dd,cuddAddCmpl01Recur,f);
+    if (r != NULL) {
+	return(r);
+    }
+    Fv = cuddT(f);
+    Fnv = cuddE(f);
+    t = cuddAddCmpl01Recur(dd,Fv);
+    if (t == NULL) return(NULL);
+    cuddRef(t);
+    e = cuddAddCmpl01Recur(dd,Fnv);
+    if (e == NULL) {
+	Cudd_RecursiveDeref(dd,t);
+	return(NULL);
+    }
+    cuddRef(e);
+    r = (t == e) ? t : cuddUniqueInter(dd,(int)f->index,t,e);
+    if (r == NULL) {
+	Cudd_RecursiveDeref(dd, t);
+	Cudd_RecursiveDeref(dd, e);
+	return(NULL);
+    }
+    cuddDeref(t);
+    cuddDeref(e);
+    cuddCacheInsert1(dd,cuddAddCmpl01Recur,f,r);
+    return(r);
+
+} /* end of cuddAddCmpl01Recur */
+/* NuSMV: add end */
diff -Nru a/cudd/cuddCache.c b/cudd/cuddCache.c
--- a/cudd/cuddCache.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddCache.c	2024-05-03 15:06:21.838493208 +0200
@@ -89,7 +89,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddCache.c,v 1.33 2004/08/13 18:04:47 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddCache.c,v 1.1.2.1 2010-02-04 10:41:15 nusmv Exp $";
 #endif
 
 /*---------------------------------------------------------------------------*/
@@ -755,16 +755,29 @@
 
 #ifdef DD_CACHE_PROFILE
     double count, mean, meansq, stddev, expected;
-    long max, min;
+  /* NuSMV: add begin */
+    ptrint max, min;
+    /* WAS: long max, min; */
+  /* NuSMV: add end */
     int imax, imin;
     double *hystogramQ, *hystogramR; /* histograms by quotient and remainder */
     int nbins = DD_HYSTO_BINS;
     int bin;
-    long thiscount;
+
+ /* NuSMV: add begin */
+    ptrint thiscount;
+    /* WAS: long thiscount; */
+  /* NuSMV: add end */
+
     double totalcount, exStddev;
 
     meansq = mean = expected = 0.0;
-    max = min = (long) cache[0].count;
+
+  /* NuSMV: add begin */
+    max = min = (ptrint) cache[0].count;
+    /* WAS: max = min = (long) cache[0].count; */
+  /* NuSMV: add end */
+
     imax = imin = 0;
     totalcount = 0.0;
 
@@ -785,7 +798,11 @@
     }
 
     for (i = 0; i < slots; i++) {
-	thiscount = (long) cache[i].count;
+      /* NuSMV: add begin */
+	thiscount = (ptrint) cache[i].count;
+        /* WAS: thiscount = (long) cache[i].count; */
+      /* NuSMV: add end */
+
 	if (thiscount > max) {
 	    max = thiscount;
 	    imax = i;
diff -Nru a/cudd/cuddCheck.c b/cudd/cuddCheck.c
--- a/cudd/cuddCheck.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddCheck.c	2024-05-03 15:06:21.838493208 +0200
@@ -84,7 +84,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddCheck.c,v 1.33 2004/08/13 18:04:47 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddCheck.c,v 1.1.2.2 2010-02-04 10:57:14 nusmv Exp $";
 #endif
 
 /*---------------------------------------------------------------------------*/
@@ -150,7 +150,6 @@
     int		totalNode;
     int		deadNode;
     int		index;
-    
 
     edgeTable = st_init_table(st_ptrcmp,st_ptrhash);
     if (edgeTable == NULL) return(CUDD_OUT_OF_MEM);
@@ -214,7 +213,12 @@
 			count = 1;
 		    }
 		    if (st_insert(edgeTable,(char *)cuddT(f),
-		    (char *)(long)count) == ST_OUT_OF_MEM) {
+
+                  /* NuSMV: add begin */
+                        (char *)(ptrint)count) == ST_OUT_OF_MEM) {
+                      /* WAS: (char *)(long)count) == ST_OUT_OF_MEM) { */
+                  /* NuSMV: add end */
+
 			st_free_table(edgeTable);
 			return(CUDD_OUT_OF_MEM);
 		    }
@@ -229,7 +233,10 @@
 			count = 1;
 		    }
 		    if (st_insert(edgeTable,(char *)Cudd_Regular(cuddE(f)),
-		    (char *)(long)count) == ST_OUT_OF_MEM) {
+                     /* NuSMV: add begin */
+                       (char *)(ptrint)count) == ST_OUT_OF_MEM) {
+                       /* WAS: (char *)(long)count) == ST_OUT_OF_MEM) { */
+                     /* NuSMV: add end */
 			st_free_table(edgeTable);
 			return(CUDD_OUT_OF_MEM);
 		    }
@@ -299,7 +306,7 @@
 			cuddPrintNode(cuddE(f),table->err);
 			flag = 1;
 		    }
-		    if (cuddT(f) == DD_ZERO(table)) {
+		    if (cuddT(f) == DD_FALSE(table)) {
 			(void) fprintf(table->err,
 				       "Error: ZDD node has zero then child\n");
 			cuddPrintNode(f,table->err);
@@ -320,7 +327,10 @@
 			count = 1;
 		    }
 		    if (st_insert(edgeTable,(char *)cuddT(f),
-		    (char *)(long)count) == ST_OUT_OF_MEM) {
+                      /* NuSMV: add begin */
+                        (char *)(ptrint)count) == ST_OUT_OF_MEM) {
+                           /* WAS: (char *)(long)count) == ST_OUT_OF_MEM) { */
+                      /* NuSMV: add end */
 			st_free_table(edgeTable);
 			return(CUDD_OUT_OF_MEM);
 		    }
@@ -334,7 +344,10 @@
 			count = 1;
 		    }
 		    if (st_insert(edgeTable,(char *)cuddE(f),
-		    (char *)(long)count) == ST_OUT_OF_MEM) {
+                      /* NuSMV: add begin */
+                        (char *)(ptrint)count) == ST_OUT_OF_MEM) {
+                           /* WAS: (char *)(long)count) == ST_OUT_OF_MEM) { */
+                      /* NuSMV: add end */
 			st_free_table(edgeTable);
 			table->errorCode = CUDD_MEMORY_OUT;
 			return(CUDD_OUT_OF_MEM);
@@ -380,14 +393,17 @@
 	    if (f->ref != 0) { 
 		if (f->index != CUDD_CONST_INDEX) {
 		    fprintf(table->err,"Error: node has illegal index\n");
-#if SIZEOF_VOID_P == 8
+#if NUSMV_SIZEOF_VOID_P == 8
 		    fprintf(table->err,
 			    "       node 0x%lx, id = %d, ref = %d, value = %g\n",
-			    (unsigned long)f,f->index,f->ref,cuddV(f));
+                            /* NuSMV: add begin */
+			    (ptruint)f,f->index,f->ref,(double)(ptruint)cuddV(f));
+                              /* WAS: (unsigned long)f,f->index,f->ref,cuddV(f)); */
+                            /* NuSMV: add end */
 #else
 		    fprintf(table->err,
 			    "       node 0x%x, id = %d, ref = %d, value = %g\n",
-			    (unsigned)f,f->index,f->ref,cuddV(f));
+			    (unsigned)f,f->index,f->ref,(double)(ptruint)cuddV(f));
 #endif
 		    flag = 1;
 		}
@@ -410,8 +426,11 @@
     gen = st_init_gen(edgeTable);
     while (st_gen(gen, &f, &count)) {
 	if (count > (int)(f->ref) && f->ref != DD_MAXREF) {
-#if SIZEOF_VOID_P == 8
-	    fprintf(table->err,"ref count error at node 0x%lx, count = %d, id = %d, ref = %d, then = 0x%lx, else = 0x%lx\n",(unsigned long)f,count,f->index,f->ref,(unsigned long)cuddT(f),(unsigned long)cuddE(f));
+#if NUSMV_SIZEOF_VOID_P == 8
+          /* NuSMV: add begin */
+	    fprintf(table->err,"ref count error at node 0x%lx, count = %d, id = %d, ref = %d, then = 0x%lx, else = 0x%lx\n",(ptruint)f,count,f->index,f->ref,(ptruint)cuddT(f),(ptruint)cuddE(f));
+            /* WAS: fprintf(table->err,"ref count error at node 0x%lx, count = %d, id = %d, ref = %d, then = 0x%lx, else = 0x%lx\n",(unsigned long)f,count,f->index,f->ref,(unsigned long)cuddT(f),(unsigned long)cuddE(f)); */
+          /* NuSMV: add end */
 #else
 	    fprintf(table->err,"ref count error at node 0x%x, count = %d, id = %d, ref = %d, then = 0x%x, else = 0x%x\n",(unsigned)f,count,f->index,f->ref,(unsigned)cuddT(f),(unsigned)cuddE(f));
 #endif
@@ -645,9 +664,12 @@
 	nonempty = 0;	/* number of tables with live nodes */
 
     /* Print header. */
-#if SIZEOF_VOID_P == 8
+#if NUSMV_SIZEOF_VOID_P == 8
     retval = fprintf(dd->out,"*** DD heap profile for 0x%lx ***\n",
-		     (unsigned long) dd);
+                     /* NuSMV: add begin */
+		     (ptruint) dd);
+                       /* WAS: (unsigned long) dd); */
+                     /* NuSMV: add end */
 #else
     retval = fprintf(dd->out,"*** DD heap profile for 0x%x ***\n",
 		     (unsigned) dd);
@@ -708,8 +730,11 @@
   FILE *fp)
 {
     f = Cudd_Regular(f);
-#if SIZEOF_VOID_P == 8
-    (void) fprintf(fp,"       node 0x%lx, id = %d, ref = %d, then = 0x%lx, else = 0x%lx\n",(unsigned long)f,f->index,f->ref,(unsigned long)cuddT(f),(unsigned long)cuddE(f));
+#if NUSMV_SIZEOF_VOID_P == 8
+    /* NuSMV: add begin */
+    (void) fprintf(fp,"       node 0x%lx, id = %d, ref = %d, then = 0x%lx, else = 0x%lx\n",(ptruint)f,f->index,f->ref,(ptruint)cuddT(f),(ptruint)cuddE(f));
+      /* WAS: (void) fprintf(fp,"       node 0x%lx, id = %d, ref = %d, then = 0x%lx, else = 0x%lx\n",(unsigned long)f,f->index,f->ref,(unsigned long)cuddT(f),(unsigned long)cuddE(f)); */
+    /* NuSMV: add end */
 #else
     (void) fprintf(fp,"       node 0x%x, id = %d, ref = %d, then = 0x%x, else = 0x%x\n",(unsigned)f,f->index,f->ref,(unsigned)cuddT(f),(unsigned)cuddE(f));
 #endif
@@ -820,9 +845,12 @@
 	    f = nodelist[j];
 	    while (f != NULL) {
 		if (cuddT(f) == node || Cudd_Regular(cuddE(f)) == node) {
-#if SIZEOF_VOID_P == 8
+#if NUSMV_SIZEOF_VOID_P == 8
 		    (void) fprintf(table->out,"parent is at 0x%lx, id = %d, ref = %d, then = 0x%lx, else = 0x%lx\n",
-			(unsigned long)f,f->index,f->ref,(unsigned long)cuddT(f),(unsigned long)cuddE(f));
+                      /* NuSMV: add begin */
+			(ptruint)f,f->index,f->ref,(ptruint)cuddT(f),(ptruint)cuddE(f));
+                         /* WAS: (unsigned long)f,f->index,f->ref,(unsigned long)cuddT(f),(unsigned long)cuddE(f)); */
+                      /* NuSMV: add end */
 #else
 		    (void) fprintf(table->out,"parent is at 0x%x, id = %d, ref = %d, then = 0x%x, else = 0x%x\n",
 			(unsigned)f,f->index,f->ref,(unsigned)cuddT(f),(unsigned)cuddE(f));
diff -Nru a/cudd/cuddClip.c b/cudd/cuddClip.c
--- a/cudd/cuddClip.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddClip.c	2024-05-03 15:06:21.838493208 +0200
@@ -83,7 +83,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddClip.c,v 1.8 2004/08/13 18:04:47 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddClip.c,v 1.1.2.1 2010-02-04 10:41:15 nusmv Exp $";
 #endif
 
 /*---------------------------------------------------------------------------*/
@@ -270,18 +270,18 @@
   int  direction)
 {
     DdNode *F, *ft, *fe, *G, *gt, *ge;
-    DdNode *one, *zero, *r, *t, *e;
+    DdNode *_true, *_false, *r, *t, *e;
     unsigned int topf, topg, index;
     DD_CTFP cacheOp;
 
     statLine(manager);
-    one = DD_ONE(manager);
-    zero = Cudd_Not(one);
+    _true = DD_TRUE(manager);
+    _false = Cudd_Not(_true);
 
     /* Terminal cases. */
-    if (f == zero || g == zero || f == Cudd_Not(g)) return(zero);
-    if (f == g || g == one) return(f);
-    if (f == one) return(g);
+    if (f == _false || g == _false || f == Cudd_Not(g)) return(_false);
+    if (f == g || g == _true) return(f);
+    if (f == _true) return(g);
     if (distance == 0) {
 	/* One last attempt at returning the right result. We sort of
 	** cheat by calling Cudd_bddLeq. */
@@ -289,9 +289,9 @@
 	if (Cudd_bddLeq(manager,g,f)) return(g);
 	if (direction == 1) {
 	    if (Cudd_bddLeq(manager,f,Cudd_Not(g)) ||
-		Cudd_bddLeq(manager,g,Cudd_Not(f))) return(zero);
+		Cudd_bddLeq(manager,g,Cudd_Not(f))) return(_false);
 	}
-	return(Cudd_NotCond(one,(direction == 0)));
+	return(Cudd_NotCond(_true,(direction == 0)));
     }
 
     /* At this point f and g are not constant. */
@@ -407,27 +407,27 @@
   int  direction)
 {
     DdNode *F, *ft, *fe, *G, *gt, *ge;
-    DdNode *one, *zero, *r, *t, *e, *Cube;
+    DdNode *_true, *_false, *r, *t, *e, *Cube;
     unsigned int topf, topg, topcube, top, index;
     ptruint cacheTag;
 
     statLine(manager);
-    one = DD_ONE(manager);
-    zero = Cudd_Not(one);
+    _true = DD_TRUE(manager);
+    _false = Cudd_Not(_true);
 
     /* Terminal cases. */
-    if (f == zero || g == zero || f == Cudd_Not(g)) return(zero);
-    if (f == one && g == one)	return(one);
-    if (cube == one) {
+    if (f == _false || g == _false || f == Cudd_Not(g)) return(_false);
+    if (f == _true && g == _true)	return(_true);
+    if (cube == _true) {
 	return(cuddBddClippingAndRecur(manager, f, g, distance, direction));
     }
-    if (f == one || f == g) {
+    if (f == _true || f == g) {
 	return (cuddBddExistAbstractRecur(manager, g, cube));
     }
-    if (g == one) {
+    if (g == _true) {
 	return (cuddBddExistAbstractRecur(manager, f, cube));
     }
-    if (distance == 0) return(Cudd_NotCond(one,(direction == 0)));
+    if (distance == 0) return(Cudd_NotCond(_true,(direction == 0)));
 
     /* At this point f, g, and cube are not constant. */
     distance--;
@@ -499,10 +499,10 @@
     /* Special case: 1 OR anything = 1. Hence, no need to compute
     ** the else branch if t is 1.
     */
-    if (t == one && topcube == top) {
+    if (t == _true && topcube == top) {
 	if (F->ref != 1 || G->ref != 1)
-	    cuddCacheInsert(manager, cacheTag, f, g, cube, one);
-	return(one);
+	    cuddCacheInsert(manager, cacheTag, f, g, cube, _true);
+	return(_true);
     }
     cuddRef(t);
 
diff -Nru a/cudd/cuddCof.c b/cudd/cuddCof.c
--- a/cudd/cuddCof.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddCof.c	2024-05-03 15:06:21.838493208 +0200
@@ -79,7 +79,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddCof.c,v 1.9 2004/08/13 18:04:47 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddCof.c,v 1.1.2.1 2010-02-04 10:41:15 nusmv Exp $";
 #endif
 
 /*---------------------------------------------------------------------------*/
@@ -121,10 +121,14 @@
   DdNode * f,
   DdNode * g)
 {
-    DdNode *res,*zero;
+    DdNode *res,*_false;
 
-    zero = Cudd_Not(DD_ONE(dd));
-    if (g == zero || g == DD_ZERO(dd)) {
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
+    _false = Cudd_Not(DD_TRUE(dd));
+    if (g == _false || g == DD_FALSE(dd)) {
 	(void) fprintf(dd->err,"Cudd_Cofactor: Invalid restriction 1\n");
 	dd->errorCode = CUDD_INVALID_ARG;
 	return(NULL);
@@ -192,7 +196,7 @@
 {
     DdNode *g1,*g0,*one,*zero;
     
-    one = DD_ONE(dd);
+    one = DD_TRUE(dd);
     if (g == one) return(1);
     if (Cudd_IsConstant(g)) return(0);
 
@@ -235,8 +239,7 @@
     statLine(dd);
     F = Cudd_Regular(f);
     if (cuddIsConstant(F)) return(f);
-
-    one = DD_ONE(dd);
+    one = DD_TRUE(dd);
 
     /* The invariant g != 0 is true on entry to this procedure and is
     ** recursively maintained by it. Therefore it suffices to test g
@@ -274,9 +277,9 @@
 
     zero = Cudd_Not(one);
     if (topf >= topg) {
-	if (g0 == zero || g0 == DD_ZERO(dd)) {
+	if (g0 == zero || g0 == DD_FALSE(dd)) {
 	    r = cuddCofactorRecur(dd, f1, g1);
-	} else if (g1 == zero || g1 == DD_ZERO(dd)) {
+	} else if (g1 == zero || g1 == DD_FALSE(dd)) {
 	    r = cuddCofactorRecur(dd, f0, g0);
 	} else {
 	    (void) fprintf(dd->out,
diff -Nru a/cudd/cuddCompose.c b/cudd/cuddCompose.c
--- a/cudd/cuddCompose.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddCompose.c	2024-05-03 15:06:21.838493208 +0200
@@ -103,16 +103,19 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddCompose.c,v 1.45 2004/08/13 18:04:47 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddCompose.c,v 1.1.2.1 2010-02-04 10:41:15 nusmv Exp $";
 #endif
 
 #ifdef DD_DEBUG
 static int addPermuteRecurHits;
 static int bddPermuteRecurHits;
 static int bddVectorComposeHits;
-static int addVectorComposeHits;
-
-static int addGeneralVectorComposeHits;
+/* NuSMV: remove begin */
+/*
+   static int addVectorComposeHits;
+   static int addGeneralVectorComposeHits;
+*/
+/* NuSMV: remove end */
 #endif
 
 /*---------------------------------------------------------------------------*/
@@ -129,12 +132,16 @@
 static DdNode * cuddAddPermuteRecur (DdManager *manager, DdHashTable *table, DdNode *node, int *permut);
 static DdNode * cuddBddPermuteRecur (DdManager *manager, DdHashTable *table, DdNode *node, int *permut);
 static DdNode * cuddBddVarMapRecur (DdManager *manager, DdNode *f);
-static DdNode * cuddAddVectorComposeRecur (DdManager *dd, DdHashTable *table, DdNode *f, DdNode **vector, int deepest);
-static DdNode * cuddAddNonSimComposeRecur (DdManager *dd, DdNode *f, DdNode **vector, DdNode *key, DdNode *cube, int lastsub);
+
+/* NuSMV: remove begin */
+/*static DdNode * cuddAddVectorComposeRecur (DdManager *dd, DdHashTable *table, DdNode *f, DdNode **vector, int deepest);*/
+/*static DdNode * cuddAddNonSimComposeRecur (DdManager *dd, DdNode *f, DdNode **vector, DdNode *key, DdNode *cube, int lastsub);*/
+/*static DdNode * cuddAddGeneralVectorComposeRecur (DdManager *dd, DdHashTable *table, DdNode *f, DdNode **vectorOn, DdNode **vectorOff, int deepest);*/
+/*NuSMV: remove end */
+
 static DdNode * cuddBddVectorComposeRecur (DdManager *dd, DdHashTable *table, DdNode *f, DdNode **vector, int deepest);
 DD_INLINE static int ddIsIthAddVar (DdManager *dd, DdNode *f, unsigned int i);
 
-static DdNode * cuddAddGeneralVectorComposeRecur (DdManager *dd, DdHashTable *table, DdNode *f, DdNode **vectorOn, DdNode **vectorOff, int deepest);
 DD_INLINE static int ddIsIthAddVarPair (DdManager *dd, DdNode *f, DdNode *g, unsigned int i);
 
 /**AutomaticEnd***************************************************************/
@@ -535,7 +542,9 @@
 
 } /* end of Cudd_bddAdjPermuteX */
 
-
+/* NuSMV: added begin */
+#if 0
+/* NuSMV: added end */
 /**Function********************************************************************
 
   Synopsis    [Composes an ADD with a vector of 0-1 ADDs.]
@@ -658,8 +667,8 @@
 
   Synopsis    [Composes an ADD with a vector of 0-1 ADDs.]
 
-  Description [Given a vector of 0-1 ADDs, creates a new ADD by
-  substituting the 0-1 ADDs for the variables of the ADD f.  There
+  Description [Given a vector of FALSE-TRUE ADDs, creates a new ADD by
+  substituting the FALSE-TRUE ADDs for the variables of the ADD f.  There
   should be an entry in vector for each variable in the manager.
   This function implements non-simultaneous composition. If any of the
   functions being composed depends on any of the variables being
@@ -694,9 +703,10 @@
     ** First we build replacement relation and cube of substituted
     ** variables from the vector specifying the desired composition.
     */
-    key = DD_ONE(dd);
+#warning [AMa] Check for T/F, should be ok, but after Cudd_addTimes check
+    key = DD_TRUE(dd);
     cuddRef(key);
-    cube = DD_ONE(dd);
+    cube = DD_TRUE(dd);
     cuddRef(cube);
     for (i = (int) dd->size - 1; i >= 0; i--) {
 	if (ddIsIthAddVar(dd,vector[i],(unsigned int)i)) {
@@ -763,6 +773,9 @@
     return(res);
 
 } /* end of Cudd_addNonSimCompose */
+/* NuSMV: added begin */
+#endif
+/* NuSMV: added end */
 
 
 /**Function********************************************************************
@@ -1090,7 +1103,7 @@
     ** cuddAddIteRecur with the T and E we just created.
     */
     index = permut[node->index];
-    var = cuddUniqueInter(manager,index,DD_ONE(manager),DD_ZERO(manager));
+    var = cuddUniqueInter(manager,index,DD_TRUE(manager),DD_FALSE(manager));
     if (var == NULL) return(NULL);
     cuddRef(var);
     res = cuddAddIteRecur(manager,var,T,E);
@@ -1285,6 +1298,9 @@
 } /* end of cuddBddVarMapRecur */
 
 
+/* NuSMV: added begin */
+#if 0
+/* NuSMV: added end */
 /**Function********************************************************************
 
   Synopsis    [Performs the recursive step of Cudd_addVectorCompose.]
@@ -1489,7 +1505,7 @@
 
     statLine(dd);
     /* If we are past the deepest substitution, return f. */
-    if (cube == DD_ONE(dd) || cuddIsConstant(f)) {
+    if (cube == DD_TRUE(dd) || cuddIsConstant(f)) {
 	return(f);
     }
 
@@ -1616,6 +1632,9 @@
     return(r);
 
 } /* end of cuddAddNonSimComposeRecur */
+/* NuSMV: added begin */
+#endif
+/* NuSMV: added end */
 
 
 /**Function********************************************************************
@@ -1716,7 +1735,7 @@
   DdNode * f,
   unsigned int  i)
 {
-    return(f->index == i && cuddT(f) == DD_ONE(dd) && cuddE(f) == DD_ZERO(dd));
+    return(f->index == i && cuddT(f) == DD_TRUE(dd) && cuddE(f) == DD_FALSE(dd));
 
 } /* end of ddIsIthAddVar */
 
@@ -1743,7 +1762,7 @@
   unsigned int  i)
 {
     return(f->index == i && g->index == i && 
-	   cuddT(f) == DD_ONE(dd) && cuddE(f) == DD_ZERO(dd) &&
-	   cuddT(g) == DD_ZERO(dd) && cuddE(g) == DD_ONE(dd));
+	   cuddT(f) == DD_TRUE(dd) && cuddE(f) == DD_FALSE(dd) &&
+	   cuddT(g) == DD_FALSE(dd) && cuddE(g) == DD_TRUE(dd));
 
 } /* end of ddIsIthAddVarPair */
diff -Nru a/cudd/cuddDecomp.c b/cudd/cuddDecomp.c
--- a/cudd/cuddDecomp.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddDecomp.c	2024-05-03 15:06:21.838493208 +0200
@@ -102,7 +102,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddDecomp.c,v 1.44 2004/08/13 18:04:47 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddDecomp.c,v 1.1.2.1 2010-02-04 10:41:15 nusmv Exp $";
 #endif
 
 static	DdNode	*one, *zero;
@@ -112,12 +112,19 @@
 /* Macro declarations                                                        */
 /*---------------------------------------------------------------------------*/
 
+/* NuSMV: add begin */
+#define FactorsNotStored(factors)  ((int)((ptrint)(factors) & 01))
 
-#define FactorsNotStored(factors)  ((int)((long)(factors) & 01))
+#define FactorsComplement(factors) ((Conjuncts *)((ptrint)(factors) | 01))
 
-#define FactorsComplement(factors) ((Conjuncts *)((long)(factors) | 01))
+#define FactorsUncomplement(factors) ((Conjuncts *)((ptrint)(factors) ^ 01))
 
-#define FactorsUncomplement(factors) ((Conjuncts *)((long)(factors) ^ 01))
+/* WAS:  #define FactorsNotStored(factors)  ((int)((long)(factors) & 01))
+
+         #define FactorsComplement(factors) ((Conjuncts *)((long)(factors) | 01))
+
+         #define FactorsUncomplement(factors) ((Conjuncts *)((long)(factors) ^ 01)) */
+/* NuSMV: add end */
 
 /**AutomaticStart*************************************************************/
 
@@ -176,6 +183,10 @@
     DdNode *superset1, *superset2, *glocal, *hlocal;
     int nvars = Cudd_SupportSize(dd,f);
 
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     /* Find a tentative first factor by overapproximation and minimization. */
     superset1 = Cudd_RemapOverApprox(dd,f,nvars,0,1.0);
     if (superset1 == NULL) return(0);
@@ -207,8 +218,8 @@
     cuddRef(glocal);
     Cudd_RecursiveDeref(dd,superset2);
 
-    if (glocal != DD_ONE(dd)) {
-	if (hlocal != DD_ONE(dd)) {
+    if (glocal != DD_TRUE(dd)) {
+	if (hlocal != DD_TRUE(dd)) {
 	    *conjuncts = ALLOC(DdNode *,2);
 	    if (*conjuncts == NULL) {
 		Cudd_RecursiveDeref(dd,glocal);
@@ -273,6 +284,10 @@
 {
     int result, i;
 
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     result = Cudd_bddApproxConjDecomp(dd,Cudd_Not(f),disjuncts);
     for (i = 0; i < result; i++) {
 	(*disjuncts)[i] = Cudd_Not((*disjuncts)[i]);
@@ -315,7 +330,11 @@
     int sizeOld, sizeNew;
     int nvars = Cudd_SupportSize(dd,f);
 
-    old[0] = DD_ONE(dd);
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
+    old[0] = DD_TRUE(dd);
     cuddRef(old[0]);
     old[1] = f;
     cuddRef(old[1]);
@@ -390,8 +409,8 @@
     Cudd_RecursiveDeref(dd,old[0]);
     old[0] = superset1;
 
-    if (old[0] != DD_ONE(dd)) {
-	if (old[1] != DD_ONE(dd)) {
+    if (old[0] != DD_TRUE(dd)) {
+	if (old[1] != DD_TRUE(dd)) {
 	    *conjuncts = ALLOC(DdNode *,2);
 	    if (*conjuncts == NULL) {
 		Cudd_RecursiveDeref(dd,old[0]);
@@ -456,6 +475,10 @@
 {
     int result, i;
 
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     result = Cudd_bddIterConjDecomp(dd,Cudd_Not(f),disjuncts);
     for (i = 0; i < result; i++) {
 	(*disjuncts)[i] = Cudd_Not((*disjuncts)[i]);
@@ -497,7 +520,11 @@
     int result;
     DdNode *glocal, *hlocal;
 
-    one = DD_ONE(dd);
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
+    one = DD_TRUE(dd);
     zero = Cudd_Not(one);
     
     do {
@@ -575,6 +602,10 @@
 {
     int result, i;
 
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     result = Cudd_bddGenConjDecomp(dd,Cudd_Not(f),disjuncts);
     for (i = 0; i < result; i++) {
 	(*disjuncts)[i] = Cudd_Not((*disjuncts)[i]);
@@ -617,6 +648,10 @@
     int min;
     DdNode *support, *scan, *var, *glocal, *hlocal;
 
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     /* Find best cofactoring variable. */
     support = Cudd_Support(dd,f);
     if (support == NULL) return(0);
@@ -664,8 +699,8 @@
     }
     cuddRef(hlocal);
 
-    if (glocal != DD_ONE(dd)) {
-	if (hlocal != DD_ONE(dd)) {
+    if (glocal != DD_TRUE(dd)) {
+	if (hlocal != DD_TRUE(dd)) {
 	    *conjuncts = ALLOC(DdNode *,2);
 	    if (*conjuncts == NULL) {
 		Cudd_RecursiveDeref(dd,glocal);
@@ -733,6 +768,10 @@
 {
     int result, i;
 
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     result = Cudd_bddVarConjDecomp(dd,Cudd_Not(f),disjuncts);
     for (i = 0; i < result; i++) {
 	(*disjuncts)[i] = Cudd_Not((*disjuncts)[i]);
@@ -945,7 +984,7 @@
     int valueG, valueH, gPresent, hPresent;
 
     valueG = valueH = gPresent = hPresent = 0;
-    
+
     gPresent = st_lookup_int(ghTable, (char *)Cudd_Regular(g), &valueG);
     hPresent = st_lookup_int(ghTable, (char *)Cudd_Regular(h), &valueH);
 
@@ -1016,7 +1055,10 @@
 		value = 1;
 	    }
 	    if (st_insert(ghTable, (char *)Cudd_Regular(g),
-			  (char *)(long)value) == ST_OUT_OF_MEM) {
+                          /* NuSMV: add begin */
+                          (char *)(ptrint)value) == ST_OUT_OF_MEM) {
+                            /* WAS: (char *)(long)value) == ST_OUT_OF_MEM) { */
+                          /* NuSMV: add end */
 		return(NULL);
 	    }
 	}
@@ -1031,7 +1073,10 @@
 		value = 2;
 	    }
 	    if (st_insert(ghTable, (char *)Cudd_Regular(h),
-			  (char *)(long)value) == ST_OUT_OF_MEM) {
+                          /* NuSMV: add begin */
+                          (char *)(ptrint)value) == ST_OUT_OF_MEM) {
+                            /* WAS: (char *)(long)value) == ST_OUT_OF_MEM) { */
+                          /* NuSMV: add end */
 		return(NULL);
 	    }
 	}
@@ -1041,7 +1086,10 @@
 	if (g != one) {
 	    value = 2;
 	    if (st_insert(ghTable, (char *)Cudd_Regular(g),
-			  (char *)(long)value) == ST_OUT_OF_MEM) {
+                          /* NuSMV: add begin */
+                          (char *)(ptrint)value) == ST_OUT_OF_MEM) {
+                            /* WAS: (char *)(long)value) == ST_OUT_OF_MEM) { */
+                          /* NuSMV: add end */
 		return(NULL);
 	    }
 	}
@@ -1051,7 +1099,10 @@
 	if (h != one) {
 	    value = 1;
 	    if (st_insert(ghTable, (char *)Cudd_Regular(h),
-			  (char *)(long)value) == ST_OUT_OF_MEM) {
+                          /* NuSMV: add begin */
+                          (char *)(ptrint)value) == ST_OUT_OF_MEM) {
+                            /* WAS: (char *)(long)value) == ST_OUT_OF_MEM) { */
+                          /* NuSMV: add end */
 		return(NULL);
 	    }
 	}
@@ -1146,7 +1197,10 @@
 	    if (value == 2) {
 		value |= 1;
 		if (st_insert(ghTable, (char *)Cudd_Regular(factors->g),
-			      (char *)(long)value) == ST_OUT_OF_MEM) {
+                          /* NuSMV: add begin */
+                          (char *)(ptrint)value) == ST_OUT_OF_MEM) {
+                            /* WAS: (char *)(long)value) == ST_OUT_OF_MEM) { */
+                          /* NuSMV: add end */
 		    FREE(factors);
 		    return(NULL);
 		}
@@ -1154,7 +1208,10 @@
 	} else {
 	    value = 1;
 	    if (st_insert(ghTable, (char *)Cudd_Regular(factors->g),
-			  (char *)(long)value) == ST_OUT_OF_MEM) {
+                          /* NuSMV: add begin */
+                          (char *)(ptrint)value) == ST_OUT_OF_MEM) {
+                            /* WAS: (char *)(long)value) == ST_OUT_OF_MEM) { */
+                          /* NuSMV: add end */
 		FREE(factors);
 		return(NULL);
 	    }
@@ -1168,7 +1225,10 @@
 	    if (value == 1) {
 		value |= 2;
 		if (st_insert(ghTable, (char *)Cudd_Regular(factors->h),
-			      (char *)(long)value) == ST_OUT_OF_MEM) {
+                          /* NuSMV: add begin */
+                          (char *)(ptrint)value) == ST_OUT_OF_MEM) {
+                            /* WAS: (char *)(long)value) == ST_OUT_OF_MEM) { */
+                          /* NuSMV: add end */
 		    FREE(factors);
 		    return(NULL);
 		}
@@ -1176,7 +1236,10 @@
 	} else {
 	    value = 2;
 	    if (st_insert(ghTable, (char *)Cudd_Regular(factors->h),
-			  (char *)(long)value) == ST_OUT_OF_MEM) {
+                          /* NuSMV: add begin */
+                          (char *)(ptrint)value) == ST_OUT_OF_MEM) {
+                            /* WAS: (char *)(long)value) == ST_OUT_OF_MEM) { */
+                          /* NuSMV: add end */
 		FREE(factors);
 		return(NULL);
 	    }
@@ -1261,7 +1324,10 @@
 	if (h1 != one) {
 	    value = 2;
 	    if (st_insert(ghTable, (char *)Cudd_Regular(h1),
-			  (char *)(long)value) == ST_OUT_OF_MEM) {
+                          /* NuSMV: add begin */
+                          (char *)(ptrint)value) == ST_OUT_OF_MEM) {
+                            /* WAS: (char *)(long)value) == ST_OUT_OF_MEM) { */
+                          /* NuSMV: add end */
 		*outOfMem = 1;
 		FREE(factors);
 		return(NULL);
@@ -1274,7 +1340,10 @@
 	if (h1 != one) {
 	    value = 3;
 	    if (st_insert(ghTable, (char *)Cudd_Regular(h1),
-			  (char *)(long)value) == ST_OUT_OF_MEM) {
+                          /* NuSMV: add begin */
+                          (char *)(ptrint)value) == ST_OUT_OF_MEM) {
+                            /* WAS: (char *)(long)value) == ST_OUT_OF_MEM) { */
+                          /* NuSMV: add end */
 		*outOfMem = 1;
 		FREE(factors);
 		return(NULL);
@@ -1287,7 +1356,10 @@
 	if (g1 != one) {
 	    value = 1;
 	    if (st_insert(ghTable, (char *)Cudd_Regular(g1),
-			  (char *)(long)value) == ST_OUT_OF_MEM) {
+                          /* NuSMV: add begin */
+                          (char *)(ptrint)value) == ST_OUT_OF_MEM) {
+                            /* WAS: (char *)(long)value) == ST_OUT_OF_MEM) { */
+                          /* NuSMV: add end */
 		*outOfMem = 1;
 		FREE(factors);
 		return(NULL);
@@ -1300,7 +1372,10 @@
 	if (g1 != one) {
 	    value = 3;
 	    if (st_insert(ghTable, (char *)Cudd_Regular(g1),
-			  (char *)(long)value) == ST_OUT_OF_MEM) {
+                          /* NuSMV: add begin */
+                          (char *)(ptrint)value) == ST_OUT_OF_MEM) {
+                            /* WAS: (char *)(long)value) == ST_OUT_OF_MEM) { */
+                          /* NuSMV: add end */
 		*outOfMem = 1;
 		FREE(factors);
 		return(NULL);
@@ -1313,7 +1388,10 @@
 	if (h2 != one) {
 	    value = 2;
 	    if (st_insert(ghTable, (char *)Cudd_Regular(h2),
-			  (char *)(long)value) == ST_OUT_OF_MEM) {
+                          /* NuSMV: add begin */
+                          (char *)(ptrint)value) == ST_OUT_OF_MEM) {
+                            /* WAS: (char *)(long)value) == ST_OUT_OF_MEM) { */
+                          /* NuSMV: add end */
 		*outOfMem = 1;
 		FREE(factors);
 		return(NULL);
@@ -1326,7 +1404,10 @@
 	if (h2 != one) {
 	    value = 3;
 	    if (st_insert(ghTable, (char *)Cudd_Regular(h2),
-			  (char *)(long)value) == ST_OUT_OF_MEM) {
+                          /* NuSMV: add begin */
+                          (char *)(ptrint)value) == ST_OUT_OF_MEM) {
+                            /* WAS: (char *)(long)value) == ST_OUT_OF_MEM) { */
+                          /* NuSMV: add end */
 		*outOfMem = 1;
 		FREE(factors);
 		return(NULL);
@@ -1339,7 +1420,10 @@
 	if (g2 != one) {
 	    value = 1;
 	    if (st_insert(ghTable, (char *)Cudd_Regular(g2),
-			  (char *)(long)value) == ST_OUT_OF_MEM) {
+                          /* NuSMV: add begin */
+                          (char *)(ptrint)value) == ST_OUT_OF_MEM) {
+                            /* WAS: (char *)(long)value) == ST_OUT_OF_MEM) { */
+                          /* NuSMV: add end */
 		*outOfMem = 1;
 		FREE(factors);
 		return(NULL);
@@ -1352,7 +1436,10 @@
 	if (g2 != one) {
 	    value = 3;
 	    if (st_insert(ghTable, (char *)Cudd_Regular(g2),
-			  (char *)(long)value) == ST_OUT_OF_MEM) {
+                          /* NuSMV: add begin */
+                          (char *)(ptrint)value) == ST_OUT_OF_MEM) {
+                            /* WAS: (char *)(long)value) == ST_OUT_OF_MEM) { */
+                          /* NuSMV: add end */
 		*outOfMem = 1;
 		FREE(factors);
 		return(NULL);
@@ -1365,7 +1452,10 @@
 	if (h1 != one) {
 	    value = 1;
 	    if (st_insert(ghTable, (char *)Cudd_Regular(h1),
-			  (char *)(long)value) == ST_OUT_OF_MEM) {
+                          /* NuSMV: add begin */
+                          (char *)(ptrint)value) == ST_OUT_OF_MEM) {
+                            /* WAS: (char *)(long)value) == ST_OUT_OF_MEM) { */
+                          /* NuSMV: add end */
 		*outOfMem = 1;
 		FREE(factors);
 		return(NULL);
@@ -1378,7 +1468,10 @@
 	if (g1 != one) {
 	    value = 2;
 	    if (st_insert(ghTable, (char *)Cudd_Regular(g1),
-			  (char *)(long)value) == ST_OUT_OF_MEM) {
+                          /* NuSMV: add begin */
+                          (char *)(ptrint)value) == ST_OUT_OF_MEM) {
+                            /* WAS: (char *)(long)value) == ST_OUT_OF_MEM) { */
+                          /* NuSMV: add end */
 		*outOfMem = 1;
 		FREE(factors);
 		return(NULL);
@@ -1391,7 +1484,10 @@
 	if (h2 != one) {
 	    value = 1;
 	    if (st_insert(ghTable, (char *)Cudd_Regular(h2),
-			  (char *)(long)value) == ST_OUT_OF_MEM) {
+                          /* NuSMV: add begin */
+                          (char *)(ptrint)value) == ST_OUT_OF_MEM) {
+                            /* WAS: (char *)(long)value) == ST_OUT_OF_MEM) { */
+                          /* NuSMV: add end */
 		*outOfMem = 1;
 		FREE(factors);
 		return(NULL);
@@ -1404,7 +1500,10 @@
 	if (g2 != one) {
 	    value = 2;
 	    if (st_insert(ghTable, (char *)Cudd_Regular(g2),
-			  (char *)(long)value) == ST_OUT_OF_MEM) {
+                          /* NuSMV: add begin */
+                          (char *)(ptrint)value) == ST_OUT_OF_MEM) {
+                            /* WAS: (char *)(long)value) == ST_OUT_OF_MEM) { */
+                          /* NuSMV: add end */
 		*outOfMem = 1;
 		FREE(factors);
 		return(NULL);
@@ -1489,7 +1588,10 @@
 	} else {
 	    value = 1;
 	}
-	if (st_insert(ghTable, (char *)Cudd_Regular(x), (char *)(long)value) == ST_OUT_OF_MEM) {
+        /* NuSMV: add begin */
+	if (st_insert(ghTable, (char *)Cudd_Regular(x), (char *)(ptrint)value) == ST_OUT_OF_MEM) {
+          /* WAS: if (st_insert(ghTable, (char *)Cudd_Regular(x), (char *)(long)value) == ST_OUT_OF_MEM) { */
+        /* NuSMV: add end */
 	    dd->errorCode = CUDD_MEMORY_OUT;
 	    return NULL;
 	}
@@ -1522,9 +1624,12 @@
 	} else {
 	    value = 2;
 	}
-	if (st_insert(ghTable, (char *)Cudd_Regular(x), (char *)(long)value) == ST_OUT_OF_MEM) {
-	    dd->errorCode = CUDD_MEMORY_OUT;
-	    return NULL;
+        /* NuSMV: add begin */
+	if (st_insert(ghTable, (char *)Cudd_Regular(x), (char *)(ptrint)value) == ST_OUT_OF_MEM) {
+          /* WAS: if (st_insert(ghTable, (char *)Cudd_Regular(x), (char *)(long)value) == ST_OUT_OF_MEM) { */
+        /* NuSMV: add end */
+          dd->errorCode = CUDD_MEMORY_OUT;
+          return NULL;
 	}
 	return(factors);
     }
@@ -1700,6 +1805,12 @@
     NodeStat *nodeStat;
     int value;
 
+    /* NuSMV: add begin */
+    /* Avoid warnings */
+    factorsNv =  (Conjuncts*) NULL;
+    factorsNnv = (Conjuncts*) NULL;
+    /* NuSMV: add end */
+
     /* if f is constant, return (f,f) */
     if (Cudd_IsConstant(node)) {
 	factors = ALLOC(Conjuncts, 1);
@@ -1761,7 +1872,11 @@
 	    factors->h = one;
 	    lastTimeG = 1;
 	    value = 1;
-	    if (st_insert(ghTable, (char *)Cudd_Regular(node), (char *)(long)value) == ST_OUT_OF_MEM) {
+
+        /* NuSMV: add begin */
+            if (st_insert(ghTable, (char *)Cudd_Regular(node), (char *)(ptrint)value) == ST_OUT_OF_MEM) {
+              /* WAS: if (st_insert(ghTable, (char *)Cudd_Regular(node), (char *)(long)value) == ST_OUT_OF_MEM) { */
+        /* NuSMV: add end */
 		dd->errorCode = CUDD_MEMORY_OUT;
 		FREE(factors);
 		return NULL;
@@ -1771,7 +1886,10 @@
 	    factors->h = node;
 	    lastTimeG = 0;
 	    value = 2;
-	    if (st_insert(ghTable, (char *)Cudd_Regular(node), (char *)(long)value) == ST_OUT_OF_MEM) {
+        /* NuSMV: add begin */
+            if (st_insert(ghTable, (char *)Cudd_Regular(node), (char *)(ptrint)value) == ST_OUT_OF_MEM) {
+              /* WAS: if (st_insert(ghTable, (char *)Cudd_Regular(node), (char *)(long)value) == ST_OUT_OF_MEM) { */
+        /* NuSMV: add end */
 		dd->errorCode = CUDD_MEMORY_OUT;
 		FREE(factors);
 		return NULL;
@@ -2045,7 +2163,7 @@
     if (distance < approxDistance) {
 	/* Too small to bother. */
 	*c1 = f;
-	*c2 = DD_ONE(dd);
+	*c2 = DD_TRUE(dd);
 	cuddRef(*c1); cuddRef(*c2);
 	stGen = st_init_gen(distanceTable);
 	if (stGen == NULL) goto outOfMem;
diff -Nru a/cudd/cuddEssent.c b/cudd/cuddEssent.c
--- a/cudd/cuddEssent.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddEssent.c	2024-05-03 15:06:21.838493208 +0200
@@ -79,7 +79,7 @@
 /*---------------------------------------------------------------------------*/
 
 /* These definitions are for the bit vectors. */
-#if SIZEOF_LONG == 8
+#if NUSMV_SIZEOF_LONG == 8
 #define BPL 64
 #define LOGBPL 6
 #else
@@ -143,7 +143,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddEssent.c,v 1.21 2004/08/13 18:04:48 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddEssent.c,v 1.1.2.1 2010-02-04 10:41:15 nusmv Exp $";
 #endif
 
 static BitVector *Tolv;
@@ -191,9 +191,9 @@
   Synopsis    [Finds the essential variables of a DD.]
 
   Description [Returns the cube of the essential variables. A positive
-  literal means that the variable must be set to 1 for the function to be
-  1. A negative literal means that the variable must be set to 0 for the
-  function to be 1. Returns a pointer to the cube BDD if successful;
+  literal means that the variable must be set to TRUE for the function to be
+  TRUE. A negative literal means that the variable must be set to FALSE for the
+  function to be TRUE. Returns a pointer to the cube BDD if successful;
   NULL otherwise.]
 
   SideEffects [None]
@@ -281,6 +281,10 @@
     DdNode *node;
     int size = dd->size;
 
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     if (Cudd_IsConstant(f)) {
 	res = emptyClauseSet();
 	return(res);
@@ -398,6 +402,10 @@
     DdTlcInfo *res = Cudd_FindTwoLiteralClauses(dd, f);
     FILE *ifp = fp == NULL ? dd->out : fp;
     
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     if (res == NULL) return(0);
     vars = res->vars;
     phases = res->phases;
@@ -486,20 +494,20 @@
     DdNode	*T, *E, *F;
     DdNode	*essT, *essE, *res;
     int		index;
-    DdNode	*one, *lzero, *azero;
+    DdNode	*_true, *lfalse, *afalse;
 
-    one = DD_ONE(dd);
+    _true = DD_TRUE(dd);
     F = Cudd_Regular(f);
     /* If f is constant the set of essential variables is empty. */
-    if (cuddIsConstant(F)) return(one);
+    if (cuddIsConstant(F)) return(_true);
 
     res = cuddCacheLookup1(dd,Cudd_FindEssential,f);
     if (res != NULL) {
 	return(res);
     }
 
-    lzero = Cudd_Not(one);
-    azero = DD_ZERO(dd);
+    lfalse = Cudd_Not(_true);
+    afalse = DD_FALSE(dd);
     /* Find cofactors: here f is non-constant. */
     T = cuddT(F);
     E = cuddE(F);
@@ -508,19 +516,19 @@
     }
 
     index = F->index;
-    if (Cudd_IsConstant(T) && T != lzero && T != azero) {
-	/* if E is zero, index is essential, otherwise there are no
+    if (Cudd_IsConstant(T) && T != lfalse && T != afalse) {
+	/* if E is false, index is essential, otherwise there are no
 	** essentials, because index is not essential and no other variable
 	** can be, since setting index = 1 makes the function constant and
 	** different from 0.
 	*/
-	if (E == lzero || E == azero) {
+	if (E == lfalse || E == afalse) {
 	    res = dd->vars[index];
 	} else {
-	    res = one;
+	    res = _true;
 	}
-    } else if (T == lzero || T == azero) {
-	if (Cudd_IsConstant(E)) { /* E cannot be zero here */
+    } else if (T == lfalse || T == afalse) {
+	if (Cudd_IsConstant(E)) { /* E cannot be false here */
 	    res = Cudd_Not(dd->vars[index]);
 	} else { /* E == non-constant */
 	    /* find essentials in the else branch */
@@ -531,7 +539,7 @@
 	    cuddRef(essE);
 
 	    /* add index to the set with negative phase */
-	    res = cuddUniqueInter(dd,index,one,Cudd_Not(essE));
+	    res = cuddUniqueInter(dd,index,_true,Cudd_Not(essE));
 	    if (res == NULL) {
 		Cudd_RecursiveDeref(dd,essE);
 		return(NULL);
@@ -540,7 +548,7 @@
 	    cuddDeref(essE);
 	}
     } else { /* T == non-const */
-	if (E == lzero || E == azero) {
+	if (E == lfalse || E == afalse) {
 	    /* find essentials in the then branch */
 	    essT = ddFindEssentialRecur(dd,T);
 	    if (essT == NULL) {
@@ -557,15 +565,15 @@
 	    }
 	    cuddDeref(essT);
 	} else if (!Cudd_IsConstant(E)) {
-	    /* if E is a non-zero constant there are no essentials
+	    /* if E is a non-false constant there are no essentials
 	    ** because T is non-constant.
 	    */
 	    essT = ddFindEssentialRecur(dd,T);
 	    if (essT == NULL) {
 		return(NULL);
 	    }
-	    if (essT == one) {
-		res = one;
+	    if (essT == _true) {
+		res = _true;
 	    } else {
 		cuddRef(essT);
 		essE = ddFindEssentialRecur(dd,E);
@@ -587,8 +595,8 @@
 		Cudd_RecursiveDeref(dd,essE);
 		cuddDeref(res);
 	    }
-	} else {	/* E is a non-zero constant */
-	    res = one;
+	} else {	/* E is a non-false constant */
+	    res = _true;
 	}
     }
 
@@ -633,10 +641,14 @@
 	return(res);
     }
 
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     /* Easy access to the constants for BDDs and ADDs. */
-    one = DD_ONE(dd);
+    one = DD_TRUE(dd);
     lzero = Cudd_Not(one);
-    azero = DD_ZERO(dd);
+    azero = DD_FALSE(dd);
 
     /* Find cofactors and variable labeling the top node. */
     T = cuddT(F); E = cuddE(F);
diff -Nru a/cudd/cuddExact.c b/cudd/cuddExact.c
--- a/cudd/cuddExact.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddExact.c	2024-05-03 15:06:21.838493208 +0200
@@ -88,7 +88,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddExact.c,v 1.26 2004/08/13 18:04:48 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddExact.c,v 1.1.2.1 2010-02-04 10:41:15 nusmv Exp $";
 #endif
 
 #ifdef DD_STATS
diff -Nru a/cudd/cuddExport.c b/cudd/cuddExport.c
--- a/cudd/cuddExport.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddExport.c	2024-05-03 15:06:21.838493208 +0200
@@ -82,7 +82,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddExport.c,v 1.18 2004/08/13 18:04:48 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddExport.c,v 1.1.2.1 2010-02-04 10:41:15 nusmv Exp $";
 #endif
 
 /*---------------------------------------------------------------------------*/
@@ -96,8 +96,13 @@
 /*---------------------------------------------------------------------------*/
 
 static int ddDoDumpBlif (DdManager *dd, DdNode *f, FILE *fp, st_table *visited, char **names);
-static int ddDoDumpDaVinci (DdManager *dd, DdNode *f, FILE *fp, st_table *visited, char **names, unsigned long mask);
-static int ddDoDumpDDcal (DdManager *dd, DdNode *f, FILE *fp, st_table *visited, char **names, unsigned long mask);
+
+/* NuSMV: add begin */
+static int ddDoDumpDaVinci (DdManager *dd, DdNode *f, FILE *fp, st_table *visited, char **names, ptruint mask);
+static int ddDoDumpDDcal (DdManager *dd, DdNode *f, FILE *fp, st_table *visited, char **names, ptruint mask);
+  /* WAS: static int ddDoDumpDaVinci (DdManager *dd, DdNode *f, FILE *fp, st_table *visited, char **names, unsigned long mask);
+          static int ddDoDumpDDcal (DdManager *dd, DdNode *f, FILE *fp, st_table *visited, char **names, unsigned long mask); */
+/* NuSMV: add end */
 static int ddDoDumpFactoredForm (DdManager *dd, DdNode *f, FILE *fp, char **names);
 
 /**AutomaticEnd***************************************************************/
@@ -270,15 +275,22 @@
     for (i = 0; i < n; i++) {
 	if (onames == NULL) {
 	    retval = fprintf(fp,
-#if SIZEOF_VOID_P == 8
-		".names %lx f%d\n", (unsigned long) f[i] / (unsigned long) sizeof(DdNode), i);
+#if NUSMV_SIZEOF_VOID_P == 8
+            /* NuSMV: add begin */
+		".names %lx f%d\n", (ptruint) f[i] / (ptruint) sizeof(DdNode), i);
+                /* WAS: ".names %lx f%d\n", (unsigned long) f[i] / (unsigned long) sizeof(DdNode), i); */
+            /* NuSMV: add end */
 #else
 		".names %x f%d\n", (unsigned) f[i] / (unsigned) sizeof(DdNode), i);
 #endif
 	} else {
 	    retval = fprintf(fp,
-#if SIZEOF_VOID_P == 8
-		".names %lx %s\n", (unsigned long) f[i] / (unsigned long) sizeof(DdNode), onames[i]);
+#if NUSMV_SIZEOF_VOID_P == 8
+            /* NuSMV: add begin */
+              ".names %lx %s\n", (ptruint) f[i] / (ptruint) sizeof(DdNode), onames[i]);
+              /* WAS: ".names %lx %s\n", (unsigned long) f[i] / (unsigned long) sizeof(DdNode), onames[i]); */
+            /* NuSMV: add end */
+	
 #else
 		".names %x %s\n", (unsigned) f[i] / (unsigned) sizeof(DdNode), onames[i]);
 #endif
@@ -350,7 +362,11 @@
     int		i, j;
     int		slots;
     DdNodePtr	*nodelist;
-    long	refAddr, diff, mask;
+
+    /* NuSMV: add begin */
+    ptrint	refAddr, diff, mask;
+      /* WAS: long	refAddr, diff, mask; */
+    /* NuSMV: add end */
 
     /* Build a bit array with the support of f. */
     sorted = ALLOC(int,nvars);
@@ -394,17 +410,26 @@
     */
 
     /* Find the bits that are different. */
-    refAddr = (long) Cudd_Regular(f[0]);
+    /* NuSMV: add begin */
+    refAddr = (ptrint) Cudd_Regular(f[0]);
+      /* WAS: refAddr = (long) Cudd_Regular(f[0]); */
+    /* NuSMV: add end */
     diff = 0;
     gen = st_init_gen(visited);
     if (gen == NULL) goto failure;
     while (st_gen(gen, &scan, NULL)) {
-	diff |= refAddr ^ (long) scan;
+      /* NuSMV: add begin */
+	diff |= refAddr ^ (ptrint) scan;
+          /* WAS: diff |= refAddr ^ (long) scan; */
+        /* NuSMV: add end */
     }
     st_free_gen(gen); gen = NULL;
 
     /* Choose the mask. */
-    for (i = 0; (unsigned) i < 8 * sizeof(long); i += 4) {
+    /* NuSMV: add begin */
+    for (i = 0; (unsigned) i < 8 * sizeof(ptrint); i += 4) {
+        /* WAS: for (i = 0; (unsigned) i < 8 * sizeof(long); i += 4) { */
+      /* NuSMV: add end */
 	mask = (1 << i) - 1;
 	if (diff <= mask) break;
     }
@@ -474,9 +499,18 @@
 		scan = nodelist[j];
 		while (scan != NULL) {
 		    if (st_is_member(visited,(char *) scan)) {
-			retval = fprintf(fp,"\"%lx\";\n",
-			    (unsigned long) ((mask & (long) scan) /
-			    sizeof(DdNode)));
+                      /* NuSMV: add begin */
+#if NUSMV_SIZEOF_VOID_P == 8	
+                      retval = fprintf(fp,"\"%lx\";\n",
+			    (ptruint) ((mask & (ptrint) scan) / sizeof(DdNode)));
+#else
+                      retval = fprintf(fp,"\"%x\";\n",
+			    (ptruint) ((mask & (ptrint) scan) / sizeof(DdNode)));
+#endif
+                        /* WAS: retval = fprintf(fp,"\"%lx\";\n",
+			        (unsigned long) ((mask & (long) scan) /
+			        sizeof(DdNode))); */
+                      /* NuSMV: add end */
 			if (retval == EOF) goto failure;
 		    }
 		    scan = scan->next;
@@ -497,8 +531,31 @@
 	scan = nodelist[j];
 	while (scan != NULL) {
 	    if (st_is_member(visited,(char *) scan)) {
+              /* NuSMV: added begin */
+#if 0
+              /* NuSMV: added end */
 		retval = fprintf(fp,"\"%lx\";\n",
-		    (unsigned long) ((mask & (long) scan) / sizeof(DdNode)));
+                /* NuSMV: add begin */
+		    (ptruint) ((mask & (ptrint) scan) / sizeof(DdNode)));
+                  /* WAS:  (unsigned long) ((mask & (long) scan) / sizeof(DdNode))); */
+                /* NuSMV: add end */
+              /* NuSMV: added begin */
+#endif
+
+                /* NuSMV: add begin */
+#if NUSMV_SIZEOF_VOID_P == 8
+		fprintf(fp,"\"%lx\" [label = \"",
+                  (mask & (ptrint) scan) / sizeof(DdNode));
+#else
+		fprintf(fp,"\"%x\" [label = \"",
+                  (mask & (ptrint) scan) / sizeof(DdNode));
+#endif
+                  /* WAS: fprintf(fp,"\"%lx\" [label = \"",
+                          (mask & (long) scan) / sizeof(DdNode)); */
+                /* NuSMV: add end */
+                dd->print_fun(dd, fp, cuddV(scan), dd->env_arg);
+                retval = fprintf(fp, "\"];\n");
+              /* NuSMV: added end */
 		if (retval == EOF) goto failure;
 	    }
 	    scan = scan->next;
@@ -518,11 +575,29 @@
 	if (retval == EOF) goto failure;
 	/* Account for the possible complement on the root. */
 	if (Cudd_IsComplement(f[i])) {
-	    retval = fprintf(fp," -> \"%lx\" [style = dotted];\n",
-		(unsigned long) ((mask & (long) f[i]) / sizeof(DdNode)));
+          /* NuSMV: add begin */
+#if NUSMV_SIZEOF_VOID_P == 8
+          retval = fprintf(fp," -> \"%lx\" [style = dotted];\n",
+                           (ptruint) ((mask & (ptrint) f[i]) / sizeof(DdNode))); 
+#else
+          retval = fprintf(fp," -> \"%x\" [style = dotted];\n",
+                           (ptruint) ((mask & (ptrint) f[i]) / sizeof(DdNode)));
+#endif
+            /* WAS: retval = fprintf(fp," -> \"%lx\" [style = dotted];\n",
+		    (unsigned long) ((mask & (long) f[i]) / sizeof(DdNode))); */
+          /* NuSMV: add end */
 	} else {
-	    retval = fprintf(fp," -> \"%lx\" [style = solid];\n",
-		(unsigned long) ((mask & (long) f[i]) / sizeof(DdNode)));
+          /* NuSMV: add begin */
+#if NUSMV_SIZEOF_VOID_P == 8
+          retval = fprintf(fp," -> \"%lx\" [style = solid];\n",
+                           (ptruint) ((mask & (ptrint) f[i]) / sizeof(DdNode)));
+#else
+	    retval = fprintf(fp," -> \"%x\" [style = solid];\n",
+                             (ptruint) ((mask & (ptrint) f[i]) / sizeof(DdNode)));
+#endif
+            /* WAS: retval = fprintf(fp," -> \"%lx\" [style = solid];\n",
+		    (unsigned long) ((mask & (long) f[i]) / sizeof(DdNode))); */
+          /* NuSMV: add end */
 	}
 	if (retval == EOF) goto failure;
     }
@@ -536,27 +611,80 @@
 		scan = nodelist[j];
 		while (scan != NULL) {
 		    if (st_is_member(visited,(char *) scan)) {
-			retval = fprintf(fp,
-			    "\"%lx\" -> \"%lx\";\n",
-			    (unsigned long) ((mask & (long) scan) /
-			    sizeof(DdNode)),
-			    (unsigned long) ((mask & (long) cuddT(scan)) /
-			    sizeof(DdNode)));
+                      /* NuSMV: add begin */
+#if NUSMV_SIZEOF_VOID_P == 8
+                      retval = fprintf(fp,
+                                       "\"%lx\" -> \"%lx\";\n",
+                                       (ptruint) ((mask & (ptrint) scan) /
+                                                  sizeof(DdNode)),
+                                       (ptruint) ((mask & (ptrint) cuddT(scan)) /
+                                                  sizeof(DdNode)));
+#else
+                      retval = fprintf(fp,
+                                       "\"%x\" -> \"%x\";\n",
+                                       (ptruint) ((mask & (ptrint) scan) /
+                                                  sizeof(DdNode)),
+                                       (ptruint) ((mask & (ptrint) cuddT(scan)) /
+                                                  sizeof(DdNode)));
+#endif
+                        /* WAS: retval = fprintf(fp,
+			        "\"%lx\" -> \"%lx\";\n",
+                                (unsigned long) ((mask & (long) scan) /
+                                sizeof(DdNode)),
+                                (unsigned long) ((mask & (long) cuddT(scan)) /
+                                sizeof(DdNode))); */
+                      /* NuSMV: add end */
+
 			if (retval == EOF) goto failure;
 			if (Cudd_IsComplement(cuddE(scan))) {
-			    retval = fprintf(fp,
+                          /* NuSMV: add begin */
+#if NUSMV_SIZEOF_VOID_P == 8
+                          retval = fprintf(fp,
+                                           "\"%lx\" -> \"%lx\" [style = dotted];\n",
+                                           (ptruint) ((mask & (ptrint) scan) /
+                                                      sizeof(DdNode)),
+                                           (ptruint) ((mask & (ptrint) cuddE(scan)) /
+                                                      sizeof(DdNode)));
+#else
+                          retval = fprintf(fp,
+                                           "\"%x\" -> \"%x\" [style = dotted];\n",
+                                           (ptruint) ((mask & (ptrint) scan) /
+                                                      sizeof(DdNode)),
+                                           (ptruint) ((mask & (ptrint) cuddE(scan)) /
+                                                      sizeof(DdNode)));
+
+#endif
+                        /* WAS: retval = fprintf(fp,
 				"\"%lx\" -> \"%lx\" [style = dotted];\n",
 				(unsigned long) ((mask & (long) scan) /
 				sizeof(DdNode)),
 				(unsigned long) ((mask & (long) cuddE(scan)) /
-				sizeof(DdNode)));
+				sizeof(DdNode))); */
+                      /* NuSMV: add end */
 			} else {
-			    retval = fprintf(fp,
+                          /* NuSMV: add begin */
+#if NUSMV_SIZEOF_VOID_P == 8
+                          retval = fprintf(fp,
+                                           "\"%lx\" -> \"%lx\" [style = dashed];\n",
+                                           (ptruint) ((mask & (ptrint) scan) /
+                                                      sizeof(DdNode)),
+                                           (ptruint) ((mask & (ptrint) cuddE(scan)) /
+                                                      sizeof(DdNode)));
+#else
+                          retval = fprintf(fp,
+                                           "\"%x\" -> \"%x\" [style = dashed];\n",
+                                           (ptruint) ((mask & (ptrint) scan) /
+                                                      sizeof(DdNode)),
+                                           (ptruint) ((mask & (ptrint) cuddE(scan)) /
+                                                      sizeof(DdNode)));
+#endif
+                        /* WAS: retval = fprintf(fp,
 				"\"%lx\" -> \"%lx\" [style = dashed];\n",
 				(unsigned long) ((mask & (long) scan) /
 				sizeof(DdNode)),
 				(unsigned long) ((mask & (long) cuddE(scan)) /
-				sizeof(DdNode)));
+				sizeof(DdNode))); */
+                      /* NuSMV: add end */
 			}
 			if (retval == EOF) goto failure;
 		    }
@@ -572,10 +700,35 @@
     for (j = 0; j < slots; j++) {
 	scan = nodelist[j];
 	while (scan != NULL) {
-	    if (st_is_member(visited,(char *) scan)) {
+     if (st_is_member(visited,(char *) scan)) {
+
+    /* NuSMV: added begin */
+#if 0
 		retval = fprintf(fp,"\"%lx\" [label = \"%g\"];\n",
-		    (unsigned long) ((mask & (long) scan) / sizeof(DdNode)),
+                                 /* NuSMV: add begin */
+			(ptruint) ((mask & (ptrint) scan) / sizeof(DdNode)),
+                                   /* WAS: (unsigned long) ((mask & (long) scan) / sizeof(DdNode)), */
+                                 /* NuSMV: add end */
 		    cuddV(scan));
+#else
+
+                /* NuSMV: add begin */
+#if NUSMV_SIZEOF_VOID_P == 8
+                retval = fprintf(fp,"\"%lx\" [label = \"",
+                                 (ptruint) ((mask & (ptrint) scan) / sizeof(DdNode))); 
+#else
+                retval = fprintf(fp,"\"%x\" [label = \"",
+                                 (ptruint) ((mask & (ptrint) scan) / sizeof(DdNode))); 
+#endif
+                  /* WAS: retval = fprintf(fp,"\"%lx\" [label = \"",
+                          (unsigned long) ((mask & (long) scan) / sizeof(DdNode))); */
+                /* NuSMV: add end */
+
+                retval &= dd->print_fun(dd, fp, cuddV(scan), dd->env_arg);
+                retval &= fprintf(fp, "\"];\n");
+#endif
+    /* NuSMV: added end */
+
 		if (retval == EOF) goto failure;
 	    }
 	    scan = scan->next;
@@ -632,7 +785,10 @@
     int		  retval;
     int		  i;
     st_generator  *gen;
-    unsigned long refAddr, diff, mask;
+    /* NuSMV: add begin */
+    ptruint refAddr, diff, mask;
+      /* WAS: unsigned long refAddr, diff, mask; */
+    /* NuSMV: add end */
 
     /* Initialize symbol table for visited nodes. */
     visited = st_init_table(st_ptrcmp, st_ptrhash);
@@ -656,16 +812,25 @@
     */
 
     /* Find the bits that are different. */
-    refAddr = (unsigned long) Cudd_Regular(f[0]);
+    /* NuSMV: add begin */
+    refAddr = (ptruint) Cudd_Regular(f[0]);
+      /* WAS: refAddr = (unsigned long) Cudd_Regular(f[0]); */
+    /* NuSMV: add end */
     diff = 0;
     gen = st_init_gen(visited);
     while (st_gen(gen, &scan, NULL)) {
-	diff |= refAddr ^ (unsigned long) scan;
+      /* NuSMV: add begin */
+	diff |= refAddr ^ (ptruint) scan;
+          /* WAS: diff |= refAddr ^ (unsigned long) scan; */
+        /* NuSMV: add end */
     }
     st_free_gen(gen);
 
     /* Choose the mask. */
-    for (i = 0; (unsigned) i < 8 * sizeof(long unsigned); i += 4) {
+    /* NuSMV: add begin */
+    for (i = 0; (unsigned) i < 8 * sizeof(ptruint); i += 4) {
+        /* WAS: for (i = 0; (unsigned) i < 8 * sizeof(long unsigned); i += 4) { */
+      /* NuSMV: add end */
 	mask = (1 << i) - 1;
 	if (diff <= mask) break;
     }
@@ -748,7 +913,10 @@
     int		  retval;
     int		  i;
     st_generator  *gen;
-    unsigned long refAddr, diff, mask;
+    /* NuSMV: add begin */
+    ptruint refAddr, diff, mask;
+      /* WAS: unsigned long refAddr, diff, mask; */
+    /* NuSMV: add end */
 
     /* Initialize symbol table for visited nodes. */
     visited = st_init_table(st_ptrcmp, st_ptrhash);
@@ -772,16 +940,25 @@
     */
 
     /* Find the bits that are different. */
-    refAddr = (unsigned long) Cudd_Regular(f[0]);
+    /* NuSMV: add begin */
+    refAddr = (ptruint) Cudd_Regular(f[0]);
+      /* WAS: refAddr = (unsigned long) Cudd_Regular(f[0]); */
+    /* NuSMV: add end */
     diff = 0;
     gen = st_init_gen(visited);
     while (st_gen(gen, &scan, NULL)) {
-	diff |= refAddr ^ (unsigned long) scan;
+      /* NuSMV: add begin */
+	diff |= refAddr ^ (ptruint) scan;
+          /* WAS: diff |= refAddr ^ (unsigned long) scan; */
+        /* NuSMV: add end */
     }
     st_free_gen(gen);
 
     /* Choose the mask. */
-    for (i = 0; (unsigned) i < 8 * sizeof(unsigned long); i += 4) {
+    /* NuSMV: add begin */
+    for (i = 0; (unsigned) i < 8 * sizeof(ptruint); i += 4) {
+        /* WAS: for (i = 0; (unsigned) i < 8 * sizeof(unsigned long); i += 4) { */
+      /* NuSMV: add end */
 	mask = (1 << i) - 1;
 	if (diff <= mask) break;
     }
@@ -835,10 +1012,23 @@
 	    retval = fprintf(fp, "%s = ", onames[i]);
 	}
 	if (retval == EOF) goto failure;
-	retval = fprintf(fp, "n%lx%s\n",
+        /* NuSMV: add begin */
+#if NUSMV_SIZEOF_VOID_P == 8
+        retval = fprintf(fp, "n%lx%s\n",
+			 ((ptruint) f[i] & mask) /
+			 (ptruint) sizeof(DdNode),
+			 Cudd_IsComplement(f[i]) ? "'" : "");
+#else
+	retval = fprintf(fp, "n%x%s\n",
+			 ((ptruint) f[i] & mask) /
+			 (ptruint) sizeof(DdNode),
+			 Cudd_IsComplement(f[i]) ? "'" : "");
+#endif
+          /* WAS: retval = fprintf(fp, "n%lx%s\n",
 			 ((unsigned long) f[i] & mask) /
 			 (unsigned long) sizeof(DdNode),
-			 Cudd_IsComplement(f[i]) ? "'" : "");
+			 Cudd_IsComplement(f[i]) ? "'" : ""); */
+        /* NuSMV: add end */
 	if (retval == EOF) goto failure;
     }
 
@@ -909,10 +1099,10 @@
 	    retval = fprintf(fp, "%s = ", onames[i]);
 	}
 	if (retval == EOF) return(0);
-	if (f[i] == DD_ONE(dd)) {
+	if (f[i] == DD_TRUE(dd)) {
 	    retval = fprintf(fp, "CONST1");
 	    if (retval == EOF) return(0);
-	} else if (f[i] == Cudd_Not(DD_ONE(dd)) || f[i] == DD_ZERO(dd)) {
+	} else if (f[i] == Cudd_Not(DD_TRUE(dd)) || f[i] == DD_FALSE(dd)) {
 	    retval = fprintf(fp, "CONST0");
 	    if (retval == EOF) return(0);
 	} else {
@@ -984,9 +1174,12 @@
         return(0);
 
     /* Check for special case: If constant node, generate constant 1. */
-    if (f == DD_ONE(dd)) {
-#if SIZEOF_VOID_P == 8
-        retval = fprintf(fp, ".names %lx\n1\n",(unsigned long) f / (unsigned long) sizeof(DdNode));
+    if (f == DD_TRUE(dd)) {
+#if NUSMV_SIZEOF_VOID_P == 8
+      /* NuSMV: add begin */
+        retval = fprintf(fp, ".names %lx\n1\n",(ptruint) f / (ptruint) sizeof(DdNode));
+          /* WAS: retval = fprintf(fp, ".names %lx\n1\n",(unsigned long) f / (unsigned long) sizeof(DdNode)); */
+        /* NuSMV: add end */
 #else
         retval = fprintf(fp, ".names %x\n1\n",(unsigned) f / (unsigned) sizeof(DdNode));
 #endif
@@ -997,12 +1190,15 @@
         }
     }
 
-    /* Check whether this is an ADD. We deal with 0-1 ADDs, but not
+    /* Check whether this is an ADD. We deal with FALSE-TRUE ADDs, but not
     ** with the general case.
     */
-    if (f == DD_ZERO(dd)) {
-#if SIZEOF_VOID_P == 8
-        retval = fprintf(fp, ".names %lx\n",(unsigned long) f / (unsigned long) sizeof(DdNode));
+    if (f == DD_FALSE(dd)) {
+#if NUSMV_SIZEOF_VOID_P == 8
+      /* NuSMV: add begin */
+        retval = fprintf(fp, ".names %lx\n",(ptruint) f / (ptruint) sizeof(DdNode));
+          /* WAS: retval = fprintf(fp, ".names %lx\n",(unsigned long) f / (unsigned long) sizeof(DdNode)); */
+        /* NuSMV: add end */
 #else
         retval = fprintf(fp, ".names %x\n",(unsigned) f / (unsigned) sizeof(DdNode));
 #endif
@@ -1032,17 +1228,27 @@
     if (retval == EOF)
 	return(0);
 
-#if SIZEOF_VOID_P == 8
+#if NUSMV_SIZEOF_VOID_P == 8
     if (Cudd_IsComplement(cuddE(f))) {
         retval = fprintf(fp," %lx %lx %lx\n11- 1\n0-0 1\n",
-	    (unsigned long) T / (unsigned long) sizeof(DdNode),
-	    (unsigned long) E / (unsigned long) sizeof(DdNode),
-	    (unsigned long) f / (unsigned long) sizeof(DdNode));
+        /* NuSMV: add begin */
+	    (ptruint) T / (ptruint) sizeof(DdNode),
+	    (ptruint) E / (ptruint) sizeof(DdNode),
+	    (ptruint) f / (ptruint) sizeof(DdNode));
+          /* WAS: (unsigned long) T / (unsigned long) sizeof(DdNode),
+	          (unsigned long) E / (unsigned long) sizeof(DdNode),
+                  (unsigned long) f / (unsigned long) sizeof(DdNode)); */
+        /* NuSMV: add end */
     } else {
         retval = fprintf(fp," %lx %lx %lx\n11- 1\n0-1 1\n",
-	    (unsigned long) T / (unsigned long) sizeof(DdNode),
-	    (unsigned long) E / (unsigned long) sizeof(DdNode),
-	    (unsigned long) f / (unsigned long) sizeof(DdNode));
+        /* NuSMV: add begin */
+	    (ptruint) T / (ptruint) sizeof(DdNode),
+	    (ptruint) E / (ptruint) sizeof(DdNode),
+	    (ptruint) f / (ptruint) sizeof(DdNode));
+          /* WAS: (unsigned long) T / (unsigned long) sizeof(DdNode),
+	          (unsigned long) E / (unsigned long) sizeof(DdNode),
+                  (unsigned long) f / (unsigned long) sizeof(DdNode)); */
+        /* NuSMV: add end */
     }
 #else
     if (Cudd_IsComplement(cuddE(f))) {
@@ -1087,26 +1293,39 @@
   FILE * fp,
   st_table * visited,
   char ** names,
-  unsigned long mask)
+  ptruint mask)
 {
     DdNode	  *T, *E;
     int		  retval;
-    unsigned long id;
+    /* NuSMV: add begin */
+    ptruint id;
+      /* WAS: unsigned long id; */
+    /* NuSMV: add end */
 
 #ifdef DD_DEBUG
     assert(!Cudd_IsComplement(f));
 #endif
 
-    id = ((unsigned long) f & mask) / sizeof(DdNode);
+    /* NuSMV: add begin */
+    id = ((ptruint) f & mask) / sizeof(DdNode);
+      /* WAS: id = ((unsigned long) f & mask) / sizeof(DdNode); */
+    /* NuSMV: add end */
 
     /* If already visited, insert a reference. */
     if (st_is_member(visited, (char *) f) == 1) {
-	retval = fprintf(fp,"r(\"%lx\")", id);
-        if (retval == EOF) {
-            return(0);
-        } else {
-            return(1);
-        }
+      /* NuSMV: add begin */
+#if NUSMV_SIZEOF_VOID_P == 8
+      retval = fprintf(fp,"r(\"%lx\")", id);
+#else
+      retval = fprintf(fp,"r(\"%x\")", id);
+#endif
+        /* WAS: retval = fprintf(fp,"r(\"%lx\")", id); */
+      /* NuSMV: add end */
+      if (retval == EOF) {
+        return(0);
+      } else {
+        return(1);
+      }
     }
 
     /* Check for abnormal condition that should never happen. */
@@ -1119,7 +1338,23 @@
 
     /* Check for special case: If constant node, generate constant 1. */
     if (Cudd_IsConstant(f)) {
+      /* NuSMV: added begin */
+#if 0
+      /* NuSMV: added end */
         retval = fprintf(fp, "l(\"%lx\",n(\"constant\",[a(\"OBJECT\",\"%g\")],[]))", id, cuddV(f));
+      /* NuSMV: added begin */
+#endif
+        /* NuSMV: add begin */
+#if NUSMV_SIZEOF_VOID_P == 8
+        (void) fprintf(fp, "l(\"%lx\",n(\"constant\",[a(\"OBJECT\",\"", id);
+#else
+        (void) fprintf(fp, "l(\"%x\",n(\"constant\",[a(\"OBJECT\",\"", id);
+#endif
+          /* WAS: (void) fprintf(fp, "l(\"%lx\",n(\"constant\",[a(\"OBJECT\",\"", id); */
+        /* NuSMV: add end */
+        (void) dd->print_fun(dd, fp, cuddV(f), dd->env_arg);
+        retval = fprintf(fp, "\")],[]))");
+      /* NuSMV: added end */
         if (retval == EOF) {
             return(0);
         } else {
@@ -1129,13 +1364,35 @@
 
     /* Recursive calls. */
     if (names != NULL) {
-	retval = fprintf(fp,
+      /* NuSMV: add begin */
+#if NUSMV_SIZEOF_VOID_P == 8
+      retval = fprintf(fp,
+                       "l(\"%lx\",n(\"internal\",[a(\"OBJECT\",\"%s\"),",
+                       id, names[f->index]);
+#else
+      retval = fprintf(fp,
+                       "l(\"%x\",n(\"internal\",[a(\"OBJECT\",\"%s\"),",
+                       id, names[f->index]);
+#endif
+        /* WAS: retval = fprintf(fp,
 			 "l(\"%lx\",n(\"internal\",[a(\"OBJECT\",\"%s\"),",
-			 id, names[f->index]);
+			 id, names[f->index]); */
+      /* NuSMV: add end */
     } else {
-	retval = fprintf(fp,
+      /* NuSMV: add begin */
+#if NUSMV_SIZEOF_VOID_P == 8
+      retval = fprintf(fp,
+                       "l(\"%lx\",n(\"internal\",[a(\"OBJECT\",\"%d\"),",
+                       id, f->index);
+#else
+      retval = fprintf(fp,
+                       "l(\"%x\",n(\"internal\",[a(\"OBJECT\",\"%d\"),",
+                       id, f->index);
+#endif
+        /* WAS: retval = fprintf(fp,
 			 "l(\"%lx\",n(\"internal\",[a(\"OBJECT\",\"%d\"),",
-			 id, f->index);
+			 id, f->index); */
+      /* NuSMV: add end */
     }
     retval = fprintf(fp, "a(\"_GO\",\"ellipse\")],[e(\"then\",[a(\"EDGECOLOR\",\"blue\"),a(\"_DIR\",\"none\")],");
     if (retval == EOF) return(0);
@@ -1180,17 +1437,23 @@
   FILE * fp,
   st_table * visited,
   char ** names,
-  unsigned long mask)
+  ptruint mask)
 {
     DdNode	  *T, *E;
     int		  retval;
-    unsigned long id, idT, idE;
+    /* NuSMV: add begin */
+    ptruint id, idT, idE;
+      /* WAS: unsigned long id, idT, idE; */
+    /* NuSMV: add end */
 
 #ifdef DD_DEBUG
     assert(!Cudd_IsComplement(f));
 #endif
 
-    id = ((unsigned long) f & mask) / sizeof(DdNode);
+    /* NuSMV: add begin */
+    id = ((ptruint) f & mask) / sizeof(DdNode);
+      /* WAS: id = ((unsigned long) f & mask) / sizeof(DdNode); */
+    /* NuSMV: add end */
 
     /* If already visited, do nothing. */
     if (st_is_member(visited, (char *) f) == 1) {
@@ -1207,9 +1470,26 @@
 
     /* Check for special case: If constant node, assign constant. */
     if (Cudd_IsConstant(f)) {
-	if (f != DD_ONE(dd) && f != DD_ZERO(dd))
-	    return(0);
+			if (f != DD_TRUE(dd) && f != DD_FALSE(dd)) return(0);
+
+    /* NuSMV: added begin */
+#if 0
 	retval = fprintf(fp, "n%lx = %g\n", id, cuddV(f));
+#else
+
+        /* NuSMV: add begin */
+#if NUSMV_SIZEOF_VOID_P == 8
+	retval = fprintf(fp, "n%lx = ", id);
+#else
+	retval = fprintf(fp, "n%x = ", id);
+#endif
+          /* WAS: retval = fprintf(fp, "n%lx = ", id); */
+        /* NuSMV: add end */
+	retval &= dd->print_fun(dd, fp, cuddV(f), dd->env_arg);
+	retval &= fprintf(fp, "\n");
+#endif
+    /* NuSMV: added end */
+
         if (retval == EOF) {
             return(0);
         } else {
@@ -1224,16 +1504,42 @@
     E = Cudd_Regular(cuddE(f));
     retval = ddDoDumpDDcal(dd,E,fp,visited,names,mask);
     if (retval != 1) return(retval);
-    idT = ((unsigned long) T & mask) / sizeof(DdNode);
-    idE = ((unsigned long) E & mask) / sizeof(DdNode);
+    /* NuSMV: add begin */
+    idT = ((ptruint) T & mask) / sizeof(DdNode);
+    idE = ((ptruint) E & mask) / sizeof(DdNode);
+      /* WAS: idT = ((unsigned long) T & mask) / sizeof(DdNode);
+              idE = ((unsigned long) E & mask) / sizeof(DdNode); */
+    /* NuSMV: add end */
     if (names != NULL) {
-	retval = fprintf(fp, "n%lx = %s * n%lx + %s' * n%lx%s\n",
+      /* NuSMV: add begin */
+#if NUSMV_SIZEOF_VOID_P == 8
+      retval = fprintf(fp, "n%lx = %s * n%lx + %s' * n%lx%s\n",
+                       id, names[f->index], idT, names[f->index],
+                       idE, Cudd_IsComplement(cuddE(f)) ? "'" : "");
+#else
+      retval = fprintf(fp, "n%x = %s * n%x + %s' * n%x%s\n",
+                       id, names[f->index], idT, names[f->index],
+                       idE, Cudd_IsComplement(cuddE(f)) ? "'" : "");
+#endif
+        /* WAS: retval = fprintf(fp, "n%lx = %s * n%lx + %s' * n%lx%s\n",
 			 id, names[f->index], idT, names[f->index],
-			 idE, Cudd_IsComplement(cuddE(f)) ? "'" : "");
+			 idE, Cudd_IsComplement(cuddE(f)) ? "'" : ""); */
+      /* NuSMV: add end */
     } else {
-	retval = fprintf(fp, "n%lx = v%d * n%lx + v%d' * n%lx%s\n",
+      /* NuSMV: add begin */
+#if NUSMV_SIZEOF_VOID_P == 8
+      retval = fprintf(fp, "n%lx = v%d * n%lx + v%d' * n%lx%s\n",
+                       id, f->index, idT, f->index,
+                       idE, Cudd_IsComplement(cuddE(f)) ? "'" : "");
+#else
+      retval = fprintf(fp, "n%x = v%d * n%x + v%d' * n%x%s\n",
+                       id, f->index, idT, f->index,
+                       idE, Cudd_IsComplement(cuddE(f)) ? "'" : "");
+#endif
+        /* WAS: retval = fprintf(fp, "n%lx = v%d * n%lx + v%d' * n%lx%s\n",
 			 id, f->index, idT, f->index,
-			 idE, Cudd_IsComplement(cuddE(f)) ? "'" : "");
+			 idE, Cudd_IsComplement(cuddE(f)) ? "'" : ""); */
+      /* NuSMV: add end */
     }
     if (retval == EOF) {
         return(0);
@@ -1283,8 +1589,8 @@
     /* Recursive calls. */
     T = cuddT(f);
     E = cuddE(f);
-    if (T != DD_ZERO(dd)) {
-	if (E != DD_ONE(dd)) {
+    if (T != DD_FALSE(dd)) {
+	if (E != DD_TRUE(dd)) {
 	    if (names != NULL) {
 		retval = fprintf(fp, "%s", names[f->index]);
 	    } else {
@@ -1292,20 +1598,20 @@
 	    }
 	    if (retval == EOF) return(0);
 	}
-	if (T != DD_ONE(dd)) {
-	    retval = fprintf(fp, "%s(", E != DD_ONE(dd) ? " * " : "");
+	if (T != DD_TRUE(dd)) {
+	    retval = fprintf(fp, "%s(", E != DD_TRUE(dd) ? " * " : "");
 	    if (retval == EOF) return(0);
 	    retval = ddDoDumpFactoredForm(dd,T,fp,names);
 	    if (retval != 1) return(retval);
 	    retval = fprintf(fp, ")");
 	    if (retval == EOF) return(0);
 	}
-	if (E == Cudd_Not(DD_ONE(dd)) || E == DD_ZERO(dd)) return(1);
+	if (E == Cudd_Not(DD_TRUE(dd)) || E == DD_FALSE(dd)) return(1);
 	retval = fprintf(fp, " + ");
 	if (retval == EOF) return(0);
     }
     E = Cudd_Regular(E);
-    if (T != DD_ONE(dd)) {
+    if (T != DD_TRUE(dd)) {
 	if (names != NULL) {
 	    retval = fprintf(fp, "!%s", names[f->index]);
 	} else {
@@ -1313,8 +1619,8 @@
 	}
 	if (retval == EOF) return(0);
     }
-    if (E != DD_ONE(dd)) {
-	retval = fprintf(fp, "%s%s(", T != DD_ONE(dd) ? " * " : "",
+    if (E != DD_TRUE(dd)) {
+	retval = fprintf(fp, "%s%s(", T != DD_TRUE(dd) ? " * " : "",
 			 E != cuddE(f) ? "!" : "");
 	if (retval == EOF) return(0);
 	retval = ddDoDumpFactoredForm(dd,E,fp,names);
diff -Nru a/cudd/cuddGenCof.c b/cudd/cuddGenCof.c
--- a/cudd/cuddGenCof.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddGenCof.c	2024-05-03 15:06:21.838493208 +0200
@@ -111,7 +111,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddGenCof.c,v 1.38 2005/05/14 17:27:11 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddGenCof.c,v 1.1.2.1 2010-02-04 10:41:15 nusmv Exp $";
 #endif
 
 /*---------------------------------------------------------------------------*/
@@ -156,12 +156,12 @@
   Uses a canonical form: (f' @ c) = ( f @ c)'.  (Note: this is not true
   for c.)  List of special cases:
     <ul>
-    <li> f @ 0 = 0
-    <li> f @ 1 = f
-    <li> 0 @ c = 0
-    <li> 1 @ c = 1
-    <li> f @ f = 1
-    <li> f @ f'= 0
+    <li> f @ FALSE = FALSE
+    <li> f @ TRUE = f
+    <li> FALSE @ c = FALSE
+    <li> TRUE @ c = TRUE
+    <li> f @ f = TRUE
+    <li> f @ f'= FALSE
     </ul>
   Returns a pointer to the result if successful; NULL otherwise. Note that if
   F=(f1,...,fn) and reordering takes place while computing F @ c, then the
@@ -216,12 +216,12 @@
     int sizeF, sizeRes;
 
     /* Check terminal cases here to avoid computing supports in trivial cases.
-    ** This also allows us notto check later for the case c == 0, in which
+    ** This also allows us notto check later for the case c == FALSE, in which
     ** there is no common support. */
-    if (c == Cudd_Not(DD_ONE(dd))) return(Cudd_Not(DD_ONE(dd)));
+    if (c == Cudd_Not(DD_TRUE(dd))) return(Cudd_Not(DD_TRUE(dd)));
     if (Cudd_IsConstant(f)) return(f);
-    if (f == c) return(DD_ONE(dd));
-    if (f == Cudd_Not(c)) return(Cudd_Not(DD_ONE(dd)));
+    if (f == c) return(DD_TRUE(dd));
+    if (f == Cudd_Not(c)) return(Cudd_Not(DD_TRUE(dd)));
 
     /* Check if supports intersect. */
     retval = Cudd_ClassifySupport(dd,f,c,&commonSupport,&suppF,&suppC);
@@ -231,7 +231,7 @@
     cuddRef(commonSupport); cuddRef(suppF); cuddRef(suppC);
     Cudd_IterDerefBdd(dd,suppF);
 
-    if (commonSupport == DD_ONE(dd)) {
+    if (commonSupport == DD_TRUE(dd)) {
 	Cudd_IterDerefBdd(dd,commonSupport);
 	Cudd_IterDerefBdd(dd,suppC);
 	return(f);
@@ -299,6 +299,10 @@
 {
     DdNode *res;
 
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     do {
 	dd->reordered = 0;
 	res = cuddBddNPAndRecur(dd,f,g);
@@ -312,14 +316,14 @@
 
   Synopsis    [Computes f constrain c for ADDs.]
 
-  Description [Computes f constrain c (f @ c), for f an ADD and c a 0-1
-  ADD.  List of special cases:
+  Description [Computes f constrain c (f @ c), for f an ADD and c a
+  FALSE-TRUE ADD.  List of special cases:
     <ul>
-    <li> F @ 0 = 0
-    <li> F @ 1 = F
-    <li> 0 @ c = 0
-    <li> 1 @ c = 1
-    <li> F @ F = 1
+    <li> F @ FALSE = FALSE
+    <li> F @ TRUE = F
+    <li> FALSE @ c = FALSE
+    <li> TRUE @ c = TRUE
+    <li> F @ F = TRUE
     </ul>
   Returns a pointer to the result if successful; NULL otherwise.]
 
@@ -336,6 +340,10 @@
 {
     DdNode *res;
 
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     do {
 	dd->reordered = 0;
 	res = cuddAddConstrainRecur(dd,f,c);
@@ -396,10 +404,10 @@
 	FREE(decomp);
 	return(NULL);
     }
-    /* Missing components are constant ones. */
+    /* Missing components are constant TRUEs. */
     for (i = 0; i < dd->size; i++) {
 	if (decomp[i] == NULL) {
-	    decomp[i] = DD_ONE(dd);
+	    decomp[i] = DD_TRUE(dd);
 	    cuddRef(decomp[i]);
 	}
     }
@@ -455,7 +463,7 @@
     cuddRef(commonSupport);
     Cudd_RecursiveDeref(dd,supp_f);
     Cudd_RecursiveDeref(dd,supp_c);
-    intersection = commonSupport != DD_ONE(dd);
+    intersection = commonSupport != DD_TRUE(dd);
     Cudd_RecursiveDeref(dd,commonSupport);
 
     if (intersection) {
@@ -511,7 +519,11 @@
     DdNode **vect;
     DdNode *res = NULL;
 
-    if (f == Cudd_Not(DD_ONE(dd))) return(NULL);
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
+    if (f == Cudd_Not(DD_TRUE(dd))) return(NULL);
 
     vect = ALLOC(DdNode *, dd->size);
     if (vect == NULL) {
@@ -570,6 +582,10 @@
 {
     DdNode *res;
 
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     do {
 	dd->reordered = 0;
 	res = cuddBddLICompaction(dd,f,c);
@@ -653,10 +669,14 @@
 {
     DdNode *cplus, *res;
 
-    if (c == Cudd_Not(DD_ONE(dd))) return(c);
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
+    if (c == Cudd_Not(DD_TRUE(dd))) return(c);
     if (Cudd_IsConstant(f)) return(f);
-    if (f == c) return(DD_ONE(dd));
-    if (f == Cudd_Not(c)) return(Cudd_Not(DD_ONE(dd)));
+    if (f == c) return(DD_TRUE(dd));
+    if (f == Cudd_Not(c)) return(Cudd_Not(DD_TRUE(dd)));
 
     cplus = Cudd_RemapOverApprox(dd,c,0,0,1.0);
     if (cplus == NULL) return(NULL);
@@ -701,6 +721,10 @@
 {
     DdNode *res, *tmp1, *tmp2;
 
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     tmp1 = Cudd_SubsetShortPaths(dd, f, nvars, threshold, 0);
     if (tmp1 == NULL) return(NULL);
     cuddRef(tmp1);
@@ -751,6 +775,10 @@
 {
     DdNode *subset;
 
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     subset = Cudd_SubsetCompress(dd, Cudd_Not(f),nvars,threshold);
 
     return(Cudd_NotCond(subset, (subset != NULL)));
@@ -782,21 +810,21 @@
   DdNode * c)
 {
     DdNode       *Fv, *Fnv, *Cv, *Cnv, *t, *e, *r;
-    DdNode	 *one, *zero;
+    DdNode	 *_true, *_false;
     unsigned int topf, topc;
     int		 index;
     int          comple = 0;
 
     statLine(dd);
-    one = DD_ONE(dd);
-    zero = Cudd_Not(one);
+    _true = DD_TRUE(dd);
+    _false = Cudd_Not(_true);
 
     /* Trivial cases. */
-    if (c == one)		return(f);
-    if (c == zero)		return(zero);
+    if (c == _true)		return(f);
+    if (c == _false)		return(_false);
     if (Cudd_IsConstant(f))	return(f);
-    if (f == c)			return(one);
-    if (f == Cudd_Not(c))	return(zero);
+    if (f == c)			return(_true);
+    if (f == Cudd_Not(c))	return(_false);
 
     /* Make canonical to increase the utilization of the cache. */
     if (Cudd_IsComplement(f)) {
@@ -837,10 +865,10 @@
 	t = cuddBddConstrainRecur(dd, Fv, Cv);
 	if (t == NULL)
 	    return(NULL);
-    } else if (Cv == one) {
+    } else if (Cv == _true) {
 	t = Fv;
-    } else {		/* Cv == zero: return Fnv @ Cnv */
-	if (Cnv == one) {
+    } else {		/* Cv == FALSE: return Fnv @ Cnv */
+	if (Cnv == _true) {
 	    r = Fnv;
 	} else {
 	    r = cuddBddConstrainRecur(dd, Fnv, Cnv);
@@ -857,9 +885,9 @@
 	    Cudd_IterDerefBdd(dd, t);
 	    return(NULL);
 	}
-    } else if (Cnv == one) {
+    } else if (Cnv == _true) {
 	e = Fnv;
-    } else {		/* Cnv == zero: return Fv @ Cv previously computed */
+    } else {		/* Cnv == FALSE: return Fv @ Cv previously computed */
 	cuddDeref(t);
 	return(Cudd_NotCond(t,comple));
     }
@@ -910,21 +938,21 @@
   DdNode * f,
   DdNode * c)
 {
-    DdNode	 *Fv, *Fnv, *Cv, *Cnv, *t, *e, *r, *one, *zero;
+    DdNode	 *Fv, *Fnv, *Cv, *Cnv, *t, *e, *r, *_true, *_false;
     unsigned int topf, topc;
     int		 index;
     int		 comple = 0;
 
     statLine(dd);
-    one = DD_ONE(dd);
-    zero = Cudd_Not(one);
+    _true = DD_TRUE(dd);
+    _false = Cudd_Not(_true);
 
     /* Trivial cases */
-    if (c == one)		return(f);
-    if (c == zero)		return(zero);
+    if (c == _true)		return(f);
+    if (c == _false)		return(_false);
     if (Cudd_IsConstant(f))	return(f);
-    if (f == c)			return(one);
-    if (f == Cudd_Not(c))	return(zero);
+    if (f == c)			return(_true);
+    if (f == Cudd_Not(c))	return(_false);
 
     /* Make canonical to increase the utilization of the cache. */
     if (Cudd_IsComplement(f)) {
@@ -988,10 +1016,10 @@
     if (!Cudd_IsConstant(Cv)) {
 	t = cuddBddRestrictRecur(dd, Fv, Cv);
 	if (t == NULL) return(NULL);
-    } else if (Cv == one) {
+    } else if (Cv == _true) {
 	t = Fv;
-    } else {		/* Cv == zero: return(Fnv @ Cnv) */
-	if (Cnv == one) {
+    } else {		/* Cv == FALSE: return(Fnv @ Cnv) */
+	if (Cnv == _true) {
 	    r = Fnv;
 	} else {
 	    r = cuddBddRestrictRecur(dd, Fnv, Cnv);
@@ -1007,9 +1035,9 @@
 	    Cudd_IterDerefBdd(dd, t);
 	    return(NULL);
 	}
-    } else if (Cnv == one) {
+    } else if (Cnv == _true) {
 	e = Fnv;
-    } else {		/* Cnv == zero: return (Fv @ Cv) previously computed */
+    } else {		/* Cnv == FALSE: return (Fv @ Cv) previously computed */
 	cuddDeref(t);
 	return(Cudd_NotCond(t,comple));
     }
@@ -1064,8 +1092,12 @@
     DdNode *one, *r, *t, *e;
     unsigned int topf, topg, index;
 
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     statLine(manager);
-    one = DD_ONE(manager);
+    one = DD_TRUE(manager);
 
     /* Terminal cases. */
     F = Cudd_Regular(f);
@@ -1206,9 +1238,13 @@
     unsigned int topf, topc;
     int		 index;
 
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     statLine(dd);
-    one = DD_ONE(dd);
-    zero = DD_ZERO(dd);
+    one = DD_TRUE(dd);
+    zero = DD_FALSE(dd);
 
     /* Trivial cases. */
     if (c == one)		return(f);
@@ -1305,19 +1341,19 @@
   DdNode * f,
   DdNode * c)
 {
-    DdNode	 *Fv, *Fnv, *Cv, *Cnv, *t, *e, *r, *one, *zero;
+    DdNode	 *Fv, *Fnv, *Cv, *Cnv, *t, *e, *r, *_true, *_false;
     unsigned int topf, topc;
     int		 index;
 
     statLine(dd);
-    one = DD_ONE(dd);
-    zero = DD_ZERO(dd);
+    _true = DD_TRUE(dd);
+    _false = DD_FALSE(dd);
 
     /* Trivial cases */
-    if (c == one)		return(f);
-    if (c == zero)		return(zero);
+    if (c == _true)		return(f);
+    if (c == _false)		return(_false);
     if (Cudd_IsConstant(f))	return(f);
-    if (f == c)			return(one);
+    if (f == c)			return(_true);
 
     /* Now f and c are non-constant. */
 
@@ -1337,7 +1373,15 @@
 	s1 = cuddT(c);
 	s2 = cuddE(c);
 	/* Take the OR by applying DeMorgan. */
+        /* NuSMV: added begin */
+#if 0
+        /* NuSMV: added end */
 	d = cuddAddApplyRecur(dd, Cudd_addOr, s1, s2);
+        /* NuSMV: added begin */
+#endif
+        d = (DdNode *) cudd_addOrRecur(dd, s1, s2);
+        /* NuSMV: added end */
+
 	if (d == NULL) return(NULL);
 	cuddRef(d);
 	r = cuddAddRestrictRecur(dd, f, d);
@@ -1364,10 +1408,10 @@
     if (!Cudd_IsConstant(Cv)) {
 	t = cuddAddRestrictRecur(dd, Fv, Cv);
 	if (t == NULL) return(NULL);
-    } else if (Cv == one) {
+    } else if (Cv == _true) {
 	t = Fv;
-    } else {		/* Cv == zero: return(Fnv @ Cnv) */
-	if (Cnv == one) {
+    } else {		/* Cv == _false: return(Fnv @ Cnv) */
+	if (Cnv == _true) {
 	    r = Fnv;
 	} else {
 	    r = cuddAddRestrictRecur(dd, Fnv, Cnv);
@@ -1383,9 +1427,9 @@
 	    Cudd_RecursiveDeref(dd, t);
 	    return(NULL);
 	}
-    } else if (Cnv == one) {
+    } else if (Cnv == _true) {
 	e = Fnv;
-    } else {		/* Cnv == zero: return (Fv @ Cv) previously computed */
+    } else {		/* Cnv == _false: return (Fv @ Cv) previously computed */
 	cuddDeref(t);
 	return(t);
     }
@@ -1415,8 +1459,8 @@
   <code>f</code> of a function to be minimized and a BDD
   <code>c</code> representing the care set, Cudd_bddLICompaction
   produces the BDD of a function that agrees with <code>f</code>
-  wherever <code>c</code> is 1.  Safe minimization means that the size
-  of the result is guaranteed not to exceed the size of
+  wherever <code>c</code> is TRUE.  Safe minimization means that the
+  size of the result is guaranteed not to exceed the size of
   <code>f</code>. This function is based on the DAC97 paper by Hong et
   al..  Returns a pointer to the result if successful; NULL
   otherwise.]
@@ -1435,7 +1479,10 @@
     st_table *marktable, *markcache, *buildcache;
     DdNode *res, *zero;
 
-    zero = Cudd_Not(DD_ONE(dd));
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+    zero = Cudd_Not(DD_TRUE(dd));
     if (c == zero) return(zero);
 
     /* We need to use local caches for both steps of this operation.
@@ -1584,7 +1631,8 @@
 
     if (topf > level) return(x);
 
-    one = DD_ONE(dd);
+
+    one = DD_TRUE(dd);
     zero = Cudd_Not(one);
 
     comple = F != f;
@@ -1654,8 +1702,11 @@
     int resT, resE, res, retval;
     char **slot;
     MarkCacheKey *key;
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
 
-    one = DD_ONE(dd);
+    one = DD_TRUE(dd);
     zero = Cudd_Not(one);
 
     /* Terminal cases. */
@@ -1771,7 +1822,11 @@
     int comple;
     int markT, markE, markings;
 
-    one = DD_ONE(dd);
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
+    one = DD_TRUE(dd);
     zero = Cudd_Not(one);
 
     if (Cudd_IsConstant(f)) return(f);
@@ -1977,7 +2032,12 @@
     if (l == u) {
 	return(l);
     }
-    one = DD_ONE(dd);
+
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
+    one = DD_TRUE(dd);
     zero = Cudd_Not(one);
     /* The only case when l == zero && u == one is at the top level,
     ** where returning either one or zero is OK. In all other cases
diff -Nru a/cudd/cuddGenetic.c b/cudd/cuddGenetic.c
--- a/cudd/cuddGenetic.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddGenetic.c	2024-05-03 15:06:21.838493208 +0200
@@ -100,7 +100,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddGenetic.c,v 1.28 2004/08/13 18:04:48 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddGenetic.c,v 1.1.2.1 2010-02-04 10:41:15 nusmv Exp $";
 #endif
 
 static int popsize;		/* the size of the population */
@@ -287,7 +287,10 @@
 	if (st_lookup_int(computed,(char *)&STOREDD(i,0),&index)) {
 	    repeat[index]++;
 	} else {
-	    if (st_insert(computed,(char *)&STOREDD(i,0),(char *)(long)i) ==
+          /* NuSMV: add begin */
+	    if (st_insert(computed,(char *)&STOREDD(i,0),(char *)(ptrint)i) ==
+             /* WAS: if (st_insert(computed,(char *)&STOREDD(i,0),(char *)(long)i) == */
+          /* NuSMV: add end */
 	    ST_OUT_OF_MEM) {
 		FREE(storedd);
 		FREE(repeat);
@@ -390,7 +393,10 @@
 		    repeat[index]++;
 		} else {
 		    if (st_insert(computed,(char *)&STOREDD(large,0),
-		    (char *)(long)large) == ST_OUT_OF_MEM) {
+                      /* NuSMV: add begin */
+		    (char *)(ptrint)large) == ST_OUT_OF_MEM) {
+                        /* WAS: (char *)(long)large) == ST_OUT_OF_MEM) { */
+                      /* NuSMV: add end */
 			FREE(storedd);
 			FREE(repeat);
 			st_free_table(computed);
diff -Nru a/cudd/cuddGroup.c b/cudd/cuddGroup.c
--- a/cudd/cuddGroup.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddGroup.c	2024-05-03 15:06:21.838493208 +0200
@@ -112,7 +112,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddGroup.c,v 1.42 2004/08/13 18:04:49 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddGroup.c,v 1.1.2.1 2010-02-04 10:41:15 nusmv Exp $";
 #endif
 
 static	int	*entry;
@@ -456,6 +456,10 @@
     int result;
     unsigned int initialSize;
 
+    /* NuSMV: add begin */
+    upper = 0;
+    /* NuSMV: add end */
+
     ddFindNodeHiLo(table,treenode,&lower,&upper);
     /* If upper == -1 these variables do not exist yet. */
     if (upper == -1)
@@ -1495,6 +1499,11 @@
     int  initialSize,bestSize;
 #endif
 
+    /* NuSMV: add begin */
+    swapy = 0;
+    swapx = 0;
+    /* NuSMV: add end */
+
 #if DD_DEBUG
     /* We assume that x < y */
     assert(x < y);
@@ -1674,6 +1683,10 @@
     int diff, tmp_diff;
     int index, pairlev;
 
+    /* NuSMV: add begin */
+    end_move = (Move*)NULL;
+    /* NuSMV: add end */
+
     if (lazyFlag) {
 	end_move = NULL;
 
@@ -1952,6 +1965,10 @@
     DdNodePtr *list;
     DdNode *sentinel = &(table->sentinel);
 
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     xindex = table->invperm[x];
     yindex = table->invperm[y];
 
@@ -1980,7 +1997,7 @@
     arccount = 0;
     counter = (int) (table->subtables[x].keys *
 	      (table->symmviolation/100.0) + 0.5);
-    one = DD_ONE(table);
+    one = DD_TRUE(table);
 
     slots = table->subtables[x].slots;
     list = table->subtables[x].nodelist;
diff -Nru a/cudd/cudd.h b/cudd/cudd.h
--- a/cudd/cudd.h	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cudd.h	2024-05-03 15:06:21.835159836 +0200
@@ -50,7 +50,7 @@
   ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   POSSIBILITY OF SUCH DAMAGE.]
 
-  Revision    [$Id: cudd.h,v 1.170 2005/05/18 06:07:41 fabio Exp $]
+  Revision    [$Id: cudd.h,v 1.1.2.1 2010-02-04 10:41:15 nusmv Exp $]
 
 ******************************************************************************/
 
@@ -61,8 +61,22 @@
 /* Nested includes                                                           */
 /*---------------------------------------------------------------------------*/
 
+/* NuSMV: added begin */
+#if HAVE_CONFIG_H
+# include "nusmv-config.h"
+#endif
+struct node;
+/* NuSMV: added end */
+
 #include "mtr.h"
+
+/* NuSMV: added begin */
+#if 0
+/* NuSMV: added end */
+/* NuSMV: added begin */
 #include "epd.h"
+#endif
+/* NuSMV: added end */
 
 #ifdef __cplusplus
 extern "C" {
@@ -74,16 +88,6 @@
 
 #define CUDD_VERSION "2.4.1"
 
-#ifndef SIZEOF_VOID_P
-#define SIZEOF_VOID_P 4
-#endif
-#ifndef SIZEOF_INT
-#define SIZEOF_INT 4
-#endif
-#ifndef SIZEOF_LONG
-#define SIZEOF_LONG 4
-#endif
-
 #ifndef TRUE
 #define TRUE 1
 #endif
@@ -91,7 +95,15 @@
 #define FALSE 0
 #endif
 
+/* NuSMV: added begin */
+#if 0
+/* NuSMV: added end */
 #define CUDD_VALUE_TYPE		double
+/* NuSMV: added begin */
+#endif
+#define CUDD_VALUE_TYPE	  struct node* /* The node type for dd leaves */
+/* NuSMV: added end */
+
 #define CUDD_OUT_OF_MEM		-1
 /* The sizes of the subtables and the cache must be powers of two. */
 #define CUDD_UNIQUE_SLOTS	256	/* initial size of subtables */
@@ -102,11 +114,17 @@
 #define CUDD_RESIDUE_MSB	1
 #define CUDD_RESIDUE_TC		2
 
+/* NuSMV: added begin */
+#if !defined(NUSMV_SIZEOF_VOID_P) || !defined(NUSMV_SIZEOF_LONG) || !defined(NUSMV_SIZEOF_INT)
+#error Constants NUSMV_SIZEOF_VOID_P, NUSMV_SIZEOF_LONG and NUSMV_SIZEOF_INT must be defined
+#endif
+/* NuSMV: added end */
+
 /* CUDD_MAXINDEX is defined in such a way that on 32-bit and 64-bit
 ** machines one can cast an index to (int) without generating a negative
 ** number.
 */
-#if SIZEOF_VOID_P == 8 && SIZEOF_INT == 4
+#if NUSMV_SIZEOF_VOID_P == 8 && NUSMV_SIZEOF_INT == 4
 #define CUDD_MAXINDEX		(((DdHalfWord) ~0) >> 1)
 #else
 #define CUDD_MAXINDEX		((DdHalfWord) ~0)
@@ -135,6 +153,21 @@
 /* Type declarations                                                         */
 /*---------------------------------------------------------------------------*/
 
+/* NuSMV: added begin */
+#if NUSMV_SIZEOF_VOID_P == 8 && NUSMV_SIZEOF_INT == 4
+  #if NUSMV_SIZEOF_LONG == 8
+typedef long ptrint;
+typedef unsigned long ptruint;
+  #else
+typedef long long ptrint;
+typedef unsigned long long ptruint;
+  #endif
+#else
+typedef int ptrint;
+typedef unsigned int ptruint;
+#endif
+/* NuSMV: added end */
+
 /**Enum************************************************************************
 
   Synopsis    [Type of reordering algorithm.]
@@ -250,7 +283,7 @@
 } Cudd_VariableType;
 
 
-#if SIZEOF_VOID_P == 8 && SIZEOF_INT == 4
+#if NUSMV_SIZEOF_VOID_P == 8 && NUSMV_SIZEOF_INT == 4
 typedef unsigned int   DdHalfWord;
 #else
 typedef unsigned short DdHalfWord;
@@ -290,7 +323,16 @@
 /* These typedefs for arbitrary precision arithmetic should agree with
 ** the corresponding constant definitions above. */
 typedef unsigned short int DdApaDigit;
+
+/* NuSMV: added begin */
+#if NUSMV_SIZEOF_LONG == 8
 typedef unsigned long int DdApaDoubleDigit;
+#else
+typedef unsigned long long DdApaDoubleDigit;
+#endif
+/* WAS: typedef unsigned long int DdApaDoubleDigit;*/
+/* NuSMV: added end */
+
 typedef DdApaDigit * DdApaNumber;
 
 /* Return type for function computing two-literal clauses. */
@@ -309,7 +351,10 @@
 typedef DdNode * (*DD_CTFP)(DdManager *, DdNode *, DdNode *);
 typedef DdNode * (*DD_CTFP1)(DdManager *, DdNode *);
 /* Type of memory-out function. */
-typedef void (*DD_OOMFP)(long);
+/* NuSMV: added begin */
+typedef void (*DD_OOMFP)(size_t);
+/* WAS: typedef void (*DD_OOMFP)(long); */
+/* NuSMV: added end */
 /* Type of comparison function for qsort. */
 typedef int (*DD_QSFP)(const void *, const void *);
 
@@ -352,8 +397,10 @@
   SeeAlso      [Cudd_NotCond]
 
 ******************************************************************************/
-#define Cudd_Not(node) ((DdNode *)((long)(node) ^ 01))
-
+/* NuSMV: added begin */
+#define Cudd_Not(node) ((DdNode *)((ptrint)(node) ^ 01))
+  /* WAS: #define Cudd_Not(node) ((DdNode *)((long)(node) ^ 01)) */
+/* NuSMV: added end */
 
 /**Macro***********************************************************************
 
@@ -368,8 +415,10 @@
   SeeAlso      [Cudd_Not]
 
 ******************************************************************************/
-#define Cudd_NotCond(node,c) ((DdNode *)((long)(node) ^ (c)))
-
+/* NuSMV: added begin */
+#define Cudd_NotCond(node,c) ((DdNode *)((ptrint)(node) ^ (c)))
+  /* WAS: #define Cudd_NotCond(node,c) ((DdNode *)((long)(node) ^ (c))) */
+/* NuSMV: added end */
 
 /**Macro***********************************************************************
 
@@ -382,8 +431,10 @@
   SeeAlso      [Cudd_Complement Cudd_IsComplement]
 
 ******************************************************************************/
-#define Cudd_Regular(node) ((DdNode *)((unsigned long)(node) & ~01))
-
+/* NuSMV: added begin */
+#define Cudd_Regular(node) ((DdNode *)((ptruint)(node) & ~01))
+  /* WAS: #define Cudd_Regular(node) ((DdNode *)((unsigned long)(node) & ~01)) */
+/* NuSMV: added end */
 
 /**Macro***********************************************************************
 
@@ -396,8 +447,10 @@
   SeeAlso      [Cudd_Regular Cudd_IsComplement]
 
 ******************************************************************************/
-#define Cudd_Complement(node) ((DdNode *)((unsigned long)(node) | 01))
-
+/* NuSMV: added begin */
+#define Cudd_Complement(node) ((DdNode *)((ptruint)(node) | 01))
+  /* WAS: #define Cudd_Complement(node) ((DdNode *)((unsigned long)(node) | 01)) */
+/* NuSMV: added end */
 
 /**Macro***********************************************************************
 
@@ -410,8 +463,10 @@
   SeeAlso      [Cudd_Regular Cudd_Complement]
 
 ******************************************************************************/
-#define Cudd_IsComplement(node)	((int) ((long) (node) & 01))
-
+/* NuSMV: added begin */
+#define Cudd_IsComplement(node)	((int) ((ptrint) (node) & 01))
+  /* WAS: #define Cudd_IsComplement(node)	((int) ((long) (node) & 01)) */
+/* NuSMV: added end */
 
 /**Macro***********************************************************************
 
@@ -617,6 +672,19 @@
 /* Function prototypes                                                       */
 /*---------------------------------------------------------------------------*/
 
+/* NuSMV: added begin */
+extern DdNode * Cudd_addCubeDiff (DdManager *dd, DdNode *a, DdNode *b);
+extern DdNode * Cudd_bddCubeDiff (DdManager *dd, DdNode *a, DdNode *b);
+extern int Cudd_BddGetLowestVar (DdManager *dd, DdNode * N);
+extern CUDD_VALUE_TYPE Cudd_add_value (DdNode * a);
+  extern void Cudd_addWalkLeaves (DdManager* dd, void (*op)(void*, CUDD_VALUE_TYPE), DdNode * f, void* arg);
+extern DdNode * Cudd_addAnd (DdManager *dd, DdNode *a, DdNode *b);
+extern DdNode * Cudd_addNot (DdManager *dd, DdNode *a);
+extern DdNode * Cudd_addIfThen (DdManager *dd, DdNode *I, DdNode *T);
+extern DdNode * Cudd_bddPickOneMintermNR (DdManager *dd, DdNode *fn, DdNode **vars, int n);
+extern int Cudd_PickAllTerms (DdManager *dd, DdNode *minterm, DdNode **vars, int n, DdNode **result);
+/* NuSMV: added end */
+
 extern DdNode * Cudd_addNewVar (DdManager *dd);
 extern DdNode * Cudd_addNewVarAtLevel (DdManager *dd, int level);
 extern DdNode * Cudd_bddNewVar (DdManager *dd);
@@ -640,9 +708,21 @@
 extern void Cudd_bddRealignEnable (DdManager *unique);
 extern void Cudd_bddRealignDisable (DdManager *unique);
 extern DdNode * Cudd_ReadOne (DdManager *dd);
+/* NuSMV: added begin */
+#if 0
+/* NuSMV: added end */
 extern DdNode * Cudd_ReadZddOne (DdManager *dd, int i);
+/* NuSMV: added begin */
+#endif
+extern DdNode * Cudd_ReadZddTrue (DdManager *dd, int i);
+/* NuSMV: added end */
 extern DdNode * Cudd_ReadZero (DdManager *dd);
 extern DdNode * Cudd_ReadLogicZero (DdManager *dd);
+/* NuSMV: added begin */
+extern DdNode * Cudd_ReadTrue (DdManager *dd);
+extern DdNode * Cudd_ReadFalse (DdManager *dd);
+extern DdNode * Cudd_ReadLogicFalse (DdManager *dd);
+/* NuSMV: added end */
 extern DdNode * Cudd_ReadPlusInfinity (DdManager *dd);
 extern DdNode * Cudd_ReadMinusInfinity (DdManager *dd);
 extern DdNode * Cudd_ReadBackground (DdManager *dd);
@@ -717,7 +797,12 @@
 extern void Cudd_SetPopulationSize (DdManager *dd, int populationSize);
 extern int Cudd_ReadNumberXovers (DdManager *dd);
 extern void Cudd_SetNumberXovers (DdManager *dd, int numberXovers);
-extern unsigned long Cudd_ReadMemoryInUse (DdManager *dd);
+
+/* NuSMV: added begin */
+extern ptruint Cudd_ReadMemoryInUse (DdManager *dd);
+  /* WAS: extern unsigned long Cudd_ReadMemoryInUse (DdManager *dd); */
+/* NuSMV: added end */
+
 extern int Cudd_PrintInfo (DdManager *dd, FILE *fp);
 extern long Cudd_ReadPeakNodeCount (DdManager *dd);
 extern int Cudd_ReadPeakLiveNodeCount (DdManager * dd);
@@ -742,15 +827,30 @@
 extern double Cudd_ReadSwapSteps (DdManager *dd);
 extern unsigned int Cudd_ReadMaxLive (DdManager *dd);
 extern void Cudd_SetMaxLive (DdManager *dd, unsigned int maxLive);
-extern unsigned long Cudd_ReadMaxMemory (DdManager *dd);
-extern void Cudd_SetMaxMemory (DdManager *dd, unsigned long maxMemory);
+
+/* NUSMV: add begin */
+extern ptruint Cudd_ReadMaxMemory (DdManager *dd);
+extern void Cudd_SetMaxMemory (DdManager *dd, ptruint maxMemory);
+  /* WAS: extern unsigned long Cudd_ReadMaxMemory (DdManager *dd);
+          extern void Cudd_SetMaxMemory (DdManager *dd, unsigned long maxMemory); */
+/* NUSMV: add end */
+
 extern int Cudd_bddBindVar (DdManager *dd, int index);
 extern int Cudd_bddUnbindVar (DdManager *dd, int index);
 extern int Cudd_bddVarIsBound (DdManager *dd, int index);
 extern DdNode * Cudd_addExistAbstract (DdManager *manager, DdNode *f, DdNode *cube);
 extern DdNode * Cudd_addUnivAbstract (DdManager *manager, DdNode *f, DdNode *cube);
 extern DdNode * Cudd_addOrAbstract (DdManager *manager, DdNode *f, DdNode *cube);
+/* NuSMV: add begin */
+#if 0
+/* NuSMV: add end */
 extern DdNode * Cudd_addApply (DdManager *dd, DdNode * (*)(DdManager *, DdNode **, DdNode **), DdNode *f, DdNode *g);
+/* NuSMV: add begin */
+#endif
+extern DdNode * Cudd_addApply (DdManager *dd, CUDD_VALUE_TYPE (*op)(), DdNode *f, DdNode *g, void* arg);
+extern DdNode * Cudd_addAbstract (DdManager *dd, CUDD_VALUE_TYPE (*op)(), DdNode *f, DdNode *cube, void* arg);
+/* NuSMV: add end */
+
 extern DdNode * Cudd_addPlus (DdManager *dd, DdNode **f, DdNode **g);
 extern DdNode * Cudd_addTimes (DdManager *dd, DdNode **f, DdNode **g);
 extern DdNode * Cudd_addThreshold (DdManager *dd, DdNode **f, DdNode **g);
@@ -762,16 +862,35 @@
 extern DdNode * Cudd_addOneZeroMaximum (DdManager *dd, DdNode **f, DdNode **g);
 extern DdNode * Cudd_addDiff (DdManager *dd, DdNode **f, DdNode **g);
 extern DdNode * Cudd_addAgreement (DdManager *dd, DdNode **f, DdNode **g);
+/* NuSMV: add begin */
+#if 0
+/* NuSMV: add end */
 extern DdNode * Cudd_addOr (DdManager *dd, DdNode **f, DdNode **g);
+/* NuSMV: add begin */
+#endif
+extern DdNode * Cudd_addOr (DdManager *dd, DdNode *f, DdNode *g);
+/* NuSMV: add end */
 extern DdNode * Cudd_addNand (DdManager *dd, DdNode **f, DdNode **g);
 extern DdNode * Cudd_addNor (DdManager *dd, DdNode **f, DdNode **g);
+/* NuSMV: add begin */
+#if 0
+/* NuSMV: add end */
 extern DdNode * Cudd_addXor (DdManager *dd, DdNode **f, DdNode **g);
+/* NuSMV: add begin */
+#endif
+extern DdNode * Cudd_addXor (DdManager *dd, DdNode *f, DdNode *g);
+/* NuSMV: add end */
 extern DdNode * Cudd_addXnor (DdManager *dd, DdNode **f, DdNode **g);
 extern DdNode * Cudd_addMonadicApply (DdManager * dd, DdNode * (*op)(DdManager *, DdNode *), DdNode * f);
 extern DdNode * Cudd_addLog (DdManager * dd, DdNode * f);
 extern DdNode * Cudd_addFindMax (DdManager *dd, DdNode *f);
 extern DdNode * Cudd_addFindMin (DdManager *dd, DdNode *f);
-extern DdNode * Cudd_addIthBit (DdManager *dd, DdNode *f, int bit);
+
+/* NuSMV: add begin */
+extern DdNode * Cudd_addIthBit (DdManager *dd, DdNode *f, ptrint bit);
+  /* WAS: extern DdNode * Cudd_addIthBit (DdManager *dd, DdNode *f, long bit); */
+/* NuSMV: add end */
+
 extern DdNode * Cudd_addScalarInverse (DdManager *dd, DdNode *f, DdNode *epsilon);
 extern DdNode * Cudd_addIte (DdManager *dd, DdNode *f, DdNode *g, DdNode *h);
 extern DdNode * Cudd_addIteConstant (DdManager *dd, DdNode *f, DdNode *g, DdNode *h);
@@ -827,11 +946,22 @@
 extern DdNode * Cudd_bddXor (DdManager *dd, DdNode *f, DdNode *g);
 extern DdNode * Cudd_bddXnor (DdManager *dd, DdNode *f, DdNode *g);
 extern int Cudd_bddLeq (DdManager *dd, DdNode *f, DdNode *g);
+/* NuSMV: add begin */
+extern DdNode * Cudd_addBddBooleanMap (DdManager *dd, DdNode *f);
+/* NuSMV: add end */
 extern DdNode * Cudd_addBddThreshold (DdManager *dd, DdNode *f, CUDD_VALUE_TYPE value);
 extern DdNode * Cudd_addBddStrictThreshold (DdManager *dd, DdNode *f, CUDD_VALUE_TYPE value);
 extern DdNode * Cudd_addBddInterval (DdManager *dd, DdNode *f, CUDD_VALUE_TYPE lower, CUDD_VALUE_TYPE upper);
-extern DdNode * Cudd_addBddIthBit (DdManager *dd, DdNode *f, int bit);
+
+/* NuSMV: add begin */
+extern DdNode * Cudd_addBddIthBit (DdManager *dd, DdNode *f, ptrint bit);
+  /* WAS: extern DdNode * Cudd_addBddIthBit (DdManager *dd, DdNode *f, long bit); */
+/* NuSMV: add end */
+
 extern DdNode * Cudd_BddToAdd (DdManager *dd, DdNode *B);
+/* NuSMV: add begin */
+extern DdNode * Cudd_BddTo01Add (DdManager *dd, DdNode *B);
+/* NuSMV: add end */
 extern DdNode * Cudd_addBddPattern (DdManager *dd, DdNode *f);
 extern DdNode * Cudd_bddTransfer (DdManager *ddSource, DdManager *ddDestination, DdNode *f);
 extern int Cudd_DebugCheck (DdManager *table);
@@ -886,7 +1016,25 @@
 extern DdNode * Cudd_SupersetCompress (DdManager *dd, DdNode *f, int nvars, int threshold);
 extern MtrNode * Cudd_MakeTreeNode (DdManager *dd, unsigned int low, unsigned int size, unsigned int type);
 extern int Cudd_addHarwell (FILE *fp, DdManager *dd, DdNode **E, DdNode ***x, DdNode ***y, DdNode ***xn, DdNode ***yn_, int *nx, int *ny, int *m, int *n, int bx, int sx, int by, int sy, int pr);
-extern DdManager * Cudd_Init (unsigned int numVars, unsigned int numVarsZ, unsigned int numSlots, unsigned int cacheSize, unsigned long maxMemory);
+
+/* NuSMV: add begin */
+extern DdManager * Cudd_Init(unsigned int numVars,
+                             unsigned int numVarsZ,
+                             unsigned int numSlots,
+                             unsigned int cacheSize,
+                             ptruint maxMemory,
+                             CUDD_VALUE_TYPE zero_number,
+                             CUDD_VALUE_TYPE one_number,
+                             CUDD_VALUE_TYPE false_const,
+                             CUDD_VALUE_TYPE true_const,
+                             int   (*print_fun)(DdManager*, FILE*, CUDD_VALUE_TYPE, void*),
+                             char* (*sprint_fun)(struct DdManager*, CUDD_VALUE_TYPE, void*),
+                             void  (*type_error_fun)(DdManager*, FILE*, CUDD_VALUE_TYPE, void*),
+                             void  (*fatal_error_fun)(DdManager*, FILE*, const char*, void*),
+                             void   *env_arg);
+  /* WAS: extern DdManager * Cudd_Init (unsigned int numVars, unsigned int numVarsZ, unsigned int numSlots, unsigned int cacheSize, unsigned long maxMemory); */
+/* NuSMV: add end */
+
 extern void Cudd_Quit (DdManager *unique);
 extern int Cudd_PrintLinear (DdManager *table);
 extern int Cudd_ReadLinear (DdManager *table, int x, int y);
@@ -937,6 +1085,9 @@
 extern void Cudd_SymmProfile (DdManager *table, int lower, int upper);
 extern unsigned int Cudd_Prime (unsigned int p);
 extern int Cudd_PrintMinterm (DdManager *manager, DdNode *node);
+/* NuSMV: added begin */
+extern char * Cudd_PrintMintermString(DdManager * manager, DdNode * node, int *success);
+/* NuSMV: added end */
 extern int Cudd_bddPrintCover (DdManager *dd, DdNode *l, DdNode *u);
 extern int Cudd_PrintDebug (DdManager *dd, DdNode *f, int n, int pr);
 extern int Cudd_DagSize (DdNode *node);
@@ -944,9 +1095,15 @@
 extern int Cudd_EstimateCofactorSimple (DdNode * node, int i);
 extern int Cudd_SharingSize (DdNode **nodeArray, int n);
 extern double Cudd_CountMinterm (DdManager *manager, DdNode *node, int nvars);
+/* NuSMV: added begin */
+#if 0
+/* NuSMV: added end */
 extern int Cudd_EpdCountMinterm (DdManager *manager, DdNode *node, int nvars, EpDouble *epd);
+/* NuSMV: added begin */
+#endif
+/* NuSMV: added end */
 extern double Cudd_CountPath (DdNode *node);
-extern double Cudd_CountPathsToNonZero (DdNode *node);
+extern double Cudd_CountPathsToNonZero (DdManager * manager, DdNode *node);
 extern DdNode * Cudd_Support (DdManager *dd, DdNode *f);
 extern int * Cudd_SupportIndex (DdManager *dd, DdNode *f);
 extern int Cudd_SupportSize (DdManager *dd, DdNode *f);
@@ -977,7 +1134,10 @@
 extern long Cudd_Random (void);
 extern void Cudd_Srandom (long seed);
 extern double Cudd_Density (DdManager *dd, DdNode *f, int nvars);
-extern void Cudd_OutOfMem (long size);
+/* NuSMV: added begin */
+extern void Cudd_OutOfMem (size_t size);
+/* WAS: extern void Cudd_OutOfMem (long size); */
+/* NuSMV: added end */
 extern int Cudd_zddCount (DdManager *zdd, DdNode *P);
 extern double Cudd_zddCountDouble (DdManager *zdd, DdNode *P);
 extern DdNode	* Cudd_zddProduct (DdManager *dd, DdNode *f, DdNode *g);
diff -Nru a/cudd/cuddHarwell.c b/cudd/cuddHarwell.c
--- a/cudd/cuddHarwell.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddHarwell.c	2024-05-03 15:06:21.838493208 +0200
@@ -71,7 +71,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddHarwell.c,v 1.9 2004/08/13 18:04:49 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddHarwell.c,v 1.1.2.1 2010-02-04 10:41:15 nusmv Exp $";
 #endif
 
 /*---------------------------------------------------------------------------*/
@@ -154,8 +154,9 @@
 
     if (*nx < 0 || *ny < 0) return(0);
 
-    one = DD_ONE(dd);
-    zero = DD_ZERO(dd);
+#warning [AMa] ???, think TF
+    one = DD_TRUE(dd);
+    zero = DD_FALSE(dd);
 
     /* Read the header */
     err = fscanf(fp, "%72c %8c", title, key);
diff -Nru a/cudd/cuddInit.c b/cudd/cuddInit.c
--- a/cudd/cuddInit.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddInit.c	2024-05-03 15:06:21.838493208 +0200
@@ -79,7 +79,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddInit.c,v 1.32 2004/08/13 18:04:49 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddInit.c,v 1.1.2.1 2010-02-04 10:41:15 nusmv Exp $";
 #endif
 
 /*---------------------------------------------------------------------------*/
@@ -101,6 +101,7 @@
 /* Definition of exported functions                                          */
 /*---------------------------------------------------------------------------*/
 
+/* NuSMV: added begin */
 /**Function********************************************************************
 
   Synopsis    [Creates a new DD manager.]
@@ -123,7 +124,133 @@
   unsigned int numVarsZ /* initial number of ZDD variables (i.e., subtables) */,
   unsigned int numSlots /* initial size of the unique tables */,
   unsigned int cacheSize /* initial size of the cache */,
-  unsigned long maxMemory /* target maximum memory occupation */)
+  ptruint maxMemory /* target maximum memory occupation */,
+  CUDD_VALUE_TYPE zero_number,
+  CUDD_VALUE_TYPE one_number,
+  CUDD_VALUE_TYPE false_const,
+  CUDD_VALUE_TYPE true_const,
+  int   (*print_fun)(DdManager*, FILE*, CUDD_VALUE_TYPE, void*),
+  char* (*sprint_fun)(struct DdManager*, CUDD_VALUE_TYPE, void*),
+  void  (*type_error_fun)(DdManager*, FILE*, CUDD_VALUE_TYPE, void*),
+  void  (*fatal_error_fun)(DdManager*, FILE*, const char*, void*),
+  void   *env_arg)
+{
+    DdManager *unique;
+    int i,result;
+    DdNode *val_true, *val_false;
+    unsigned int maxCacheSize;
+    unsigned int looseUpTo;
+    extern DD_OOMFP MMoutOfMemory;
+    DD_OOMFP saveHandler;
+
+    if (maxMemory == 0) {
+        maxMemory = getSoftDataLimit();
+    }
+    looseUpTo = (unsigned int) ((maxMemory / sizeof(DdNode)) /
+                                DD_MAX_LOOSE_FRACTION);
+    unique = cuddInitTable(numVars,numVarsZ,numSlots,looseUpTo);
+    /* NuSMV: add begin */
+    unique->maxmem = (ptruint) maxMemory / 10 * 9;
+      /* WAS: unique->maxmem = (unsigned long) maxMemory / 10 * 9; */
+    /* NuSMV: add end */
+    if (unique == NULL) return(NULL);
+    maxCacheSize = (unsigned int) ((maxMemory / sizeof(DdCache)) /
+                                   DD_MAX_CACHE_FRACTION);
+    result = cuddInitCache(unique,cacheSize,maxCacheSize);
+    if (result == 0) return(NULL);
+
+    saveHandler = MMoutOfMemory;
+    MMoutOfMemory = Cudd_OutOfMem;
+    unique->stash = ALLOC(char,(maxMemory / DD_STASH_FRACTION) + 4);
+    MMoutOfMemory = saveHandler;
+    if (unique->stash == NULL) {
+        (void) fprintf(unique->err,"Unable to set aside memory\n");
+    }
+
+    /* Initialize constants. */
+    unique->val_true = cuddUniqueConst(unique, true_const);
+    if (unique->val_true == NULL) return(0);
+    cuddRef(unique->val_true);
+
+    unique->val_false = cuddUniqueConst(unique, false_const);
+    if (unique->val_false == NULL) return(0);
+    cuddRef(unique->val_false);
+
+    unique->env_arg = env_arg;
+    unique->print_fun = print_fun;
+    unique->sprint_fun = sprint_fun;
+    unique->type_error_fun = type_error_fun;
+    unique->fatal_error_fun = fatal_error_fun;
+
+    unique->one = cuddUniqueConst(unique, one_number);
+    if (unique->one == NULL) return(0);
+    cuddRef(unique->one);
+
+    unique->zero = cuddUniqueConst(unique, zero_number);
+    if (unique->zero == NULL) return(0);
+    cuddRef(unique->zero);
+
+#ifdef HAVE_IEEE_754
+    if (DD_PLUS_INF_VAL != DD_PLUS_INF_VAL * 3 ||
+        DD_PLUS_INF_VAL != DD_PLUS_INF_VAL / 3) {
+        (void) fprintf(unique->err,"Warning: Crippled infinite values\n");
+        (void) fprintf(unique->err,"Recompile without -DHAVE_IEEE_754\n");
+    }
+#endif
+
+    unique->plusinfinity = (DdNode *)(-1);
+    unique->minusinfinity = (DdNode *)(-1);
+    unique->background = unique->val_false;
+
+    /* The logical false is different from the CUDD_VALUE_TYPE false! */
+    val_true = unique->val_true;
+    val_false = Cudd_Not(val_true);
+    /* Create the projection functions. */
+    unique->vars = ALLOC(DdNodePtr,unique->maxSize);
+    if (unique->vars == NULL) {
+        unique->errorCode = CUDD_MEMORY_OUT;
+        return(NULL);
+    }
+    for (i = 0; i < unique->size; i++) {
+        unique->vars[i] = cuddUniqueInter(unique,i,val_true,val_false);
+        if (unique->vars[i] == NULL) return(0);
+        cuddRef(unique->vars[i]);
+    }
+
+    if (unique->sizeZ)
+        cuddZddInitUniv(unique);
+
+    unique->memused += sizeof(DdNode *) * unique->maxSize;
+
+    return(unique);
+
+} /* end of Cudd_Init */
+/* NuSMV: added end */
+
+#if 0
+/**Function********************************************************************
+
+  Synopsis    [Creates a new DD manager.]
+
+  Description [Creates a new DD manager, initializes the table, the
+  basic constants and the projection functions. If maxMemory is 0,
+  Cudd_Init decides suitable values for the maximum size of the cache
+  and for the limit for fast unique table growth based on the available
+  memory. Returns a pointer to the manager if successful; NULL
+  otherwise.]
+
+  SideEffects [None]
+
+  SeeAlso     [Cudd_Quit]
+
+******************************************************************************/
+DdManager *
+Cudd_Init(
+  unsigned int numVars /* initial number of BDD variables (i.e., subtables) */,
+  unsigned int numVarsZ /* initial number of ZDD variables (i.e., subtables) */,
+  unsigned int numSlots /* initial size of the unique tables */,
+  unsigned int cacheSize /* initial size of the cache */,
+  ptruint maxMemory /* target maximum memory occupation */)
 {
     DdManager *unique;
     int i,result;
@@ -132,6 +259,10 @@
     unsigned int looseUpTo;
     extern DD_OOMFP MMoutOfMemory;
     DD_OOMFP saveHandler;
+    /* NuSMV: added begin */
+    extern CUDD_VALUE_TYPE false_const;
+    extern CUDD_VALUE_TYPE true_const;
+    /* NuSMV: added end */
 
     if (maxMemory == 0) {
 	maxMemory = getSoftDataLimit();
@@ -139,7 +270,10 @@
     looseUpTo = (unsigned int) ((maxMemory / sizeof(DdNode)) /
 				DD_MAX_LOOSE_FRACTION);
     unique = cuddInitTable(numVars,numVarsZ,numSlots,looseUpTo);
-    unique->maxmem = (unsigned long) maxMemory / 10 * 9;
+    /* NuSMV: add begin */
+    unique->maxmem = (ptruint) maxMemory / 10 * 9;
+      /* WAS: unique->maxmem = (unsigned long) maxMemory / 10 * 9; */
+    /* NuSMV: add end */
     if (unique == NULL) return(NULL);
     maxCacheSize = (unsigned int) ((maxMemory / sizeof(DdCache)) /
 				   DD_MAX_CACHE_FRACTION);
@@ -155,10 +289,25 @@
     }
 
     /* Initialize constants. */
+    /* NuSMV: added begin */
+#if 0
+    /* NuSMV: added end */
     unique->one = cuddUniqueConst(unique,1.0);
+    /* NuSMV: added begin */
+#endif
+    unique->one = cuddUniqueConst(unique, true_const);
+    /* NuSMV: added end */
+
     if (unique->one == NULL) return(0);
     cuddRef(unique->one);
+    /* NuSMV: added begin */
+#if 0
+    /* NuSMV: added end */
     unique->zero = cuddUniqueConst(unique,0.0);
+    /* NuSMV: added begin */
+#endif
+    unique->zero = cuddUniqueConst(unique, false_const);
+    /* NuSMV: added end */
     if (unique->zero == NULL) return(0);
     cuddRef(unique->zero);
 #ifdef HAVE_IEEE_754
@@ -168,12 +317,20 @@
 	(void) fprintf(unique->err,"Recompile without -DHAVE_IEEE_754\n");
     }
 #endif
+    /* NuSMV: added begin */
+#if 0
+    /* NuSMV: added end */
     unique->plusinfinity = cuddUniqueConst(unique,DD_PLUS_INF_VAL);
     if (unique->plusinfinity == NULL) return(0);
     cuddRef(unique->plusinfinity);
     unique->minusinfinity = cuddUniqueConst(unique,DD_MINUS_INF_VAL);
     if (unique->minusinfinity == NULL) return(0);
     cuddRef(unique->minusinfinity);
+    /* NuSMV: added begin */
+#endif
+    unique->plusinfinity = (DdNode *)(-1);
+    unique->minusinfinity = (DdNode *)(-1);
+    /* NuSMV: added end */
     unique->background = unique->zero;
 
     /* The logical zero is different from the CUDD_VALUE_TYPE zero! */
@@ -199,7 +356,7 @@
     return(unique);
 
 } /* end of Cudd_Init */
-
+#endif
 
 /**Function********************************************************************
 
@@ -254,7 +411,7 @@
 	return(0);
     }
 
-    res = DD_ONE(zdd);
+    res = DD_TRUE(zdd);
     cuddRef(res);
     for (i = zdd->sizeZ - 1; i >= 0; i--) {
 	unsigned int index = zdd->invpermZ[i];
diff -Nru a/cudd/cuddInteract.c b/cudd/cuddInteract.c
--- a/cudd/cuddInteract.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddInteract.c	2024-05-03 15:06:21.838493208 +0200
@@ -81,7 +81,7 @@
 /* Constant declarations                                                     */
 /*---------------------------------------------------------------------------*/
 
-#if SIZEOF_LONG == 8
+#if NUSMV_SIZEOF_LONG == 8
 #define BPL 64
 #define LOGBPL 6
 #else
@@ -104,7 +104,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddInteract.c,v 1.12 2004/08/13 18:04:49 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddInteract.c,v 1.1.2.1 2010-02-04 10:41:15 nusmv Exp $";
 #endif
 
 /*---------------------------------------------------------------------------*/
@@ -154,15 +154,29 @@
   int  x,
   int  y)
 {
-    int posn, word, bit;
+  int posn, word, bit;
+  /* NuSMV: begin add */
+  size_t xt = (size_t)x;
+  size_t yt = (size_t)y;
+  size_t n = (size_t)table->size;
+  /* NuSMV: end add */
 
 #ifdef DD_DEBUG
     assert(x < y);
     assert(y < table->size);
     assert(x >= 0);
 #endif
-
+    /* NuSMV: begin add */
+#if 0
+    /* NuSMV: end add */
     posn = ((((table->size << 1) - x - 3) * x) >> 1) + y - 1;
+    /* NuSMV: begin add */
+#endif
+    posn = (int)(((((n << 1) - xt - 3) * xt) >> 1) + yt + 1);
+#ifdef DD_DEBUG
+    assert(posn >= 0);
+#endif
+    /* NuSMV: end add */
     word = posn >> LOGBPL;
     bit = posn & (BPL-1);
     table->interact[word] |= 1L << bit;
@@ -191,6 +205,12 @@
 {
     int posn, word, bit, result;
 
+    /* NuSMV: begin add */
+    size_t xt;
+    size_t yt;
+    size_t n;
+    /* NuSMV: end add */
+
     if (x > y) {
 	int tmp = x;
 	x = y;
@@ -202,7 +222,21 @@
     assert(x >= 0);
 #endif
 
+    /* NuSMV: begin add */
+#if 0
+    /* NuSMV: end add */
     posn = ((((table->size << 1) - x - 3) * x) >> 1) + y - 1;
+    /* NuSMV: begin add */
+#endif
+    xt = (size_t)x;
+    yt = (size_t)y;
+    n = (size_t)table->size;
+    posn = (int)(((((n << 1) - xt - 3) * xt) >> 1) + yt + 1);
+#ifdef DD_DEBUG
+    assert(posn >= 0);
+#endif
+    /* NuSMV: end add */
+
     word = posn >> LOGBPL;
     bit = posn & (BPL-1);
     result = (table->interact[word] >> bit) & 1L;
@@ -242,8 +276,19 @@
     DdNodePtr *nodelist;
     int slots;
     int n = table->size;
-
+    /* NuSMV: begin add */
+#if 0
+    /* NuSMV: end add */
     words = ((n * (n-1)) >> (1 + LOGBPL)) + 1;
+    /* NuSMV: begin add */
+#endif
+    size_t nt = (size_t)n;
+    words = (int)(((nt * (nt-1)) >> (1 + LOGBPL)) + 1);
+#ifdef DD_DEBUG
+    assert(words >= 0);
+#endif
+    /* NuSMV: end add */
+
     table->interact = interact = ALLOC(long,words);
     if (interact == NULL) {
 	table->errorCode = CUDD_MEMORY_OUT;
diff -Nru a/cudd/cuddInt.h b/cudd/cuddInt.h
--- a/cudd/cuddInt.h	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddInt.h	2024-05-03 15:06:21.838493208 +0200
@@ -44,7 +44,7 @@
   ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   POSSIBILITY OF SUCH DAMAGE.]
 
-  Revision    [$Id: cuddInt.h,v 1.138 2004/08/13 18:04:49 fabio Exp $]
+  Revision    [$Id: cuddInt.h,v 1.1.2.1 2010-02-04 10:41:15 nusmv Exp $]
 
 ******************************************************************************/
 
@@ -61,7 +61,7 @@
 #include "list.h"
 #include "st.h"
 #include "espresso.h"
-#include "node.h"
+
 #ifdef SIS
 #include "graph.h"
 #include "astg.h"
@@ -105,7 +105,7 @@
 #define DD_MEM_CHUNK		1022
 
 /* These definitions work for CUDD_VALUE_TYPE == double */
-#define DD_ONE_VAL		(1.0)
+#define DD_TRUE_VAL		(1.0)
 #define DD_ZERO_VAL		(0.0)
 #define DD_EPSILON		(1.0e-12)
 
@@ -248,14 +248,6 @@
     struct DdHook *next;	/* next element in the list */
 } DdHook;
 
-#if SIZEOF_VOID_P == 8 && SIZEOF_INT == 4
-typedef long ptrint;
-typedef unsigned long ptruint;
-#else
-typedef int ptrint;
-typedef unsigned int ptruint;
-#endif
-
 #ifdef __osf__
 #pragma pointer_size save
 #pragma pointer_size short
@@ -339,6 +331,15 @@
     DdNode sentinel;		/* for collision lists */
     DdNode *one;		/* constant 1 */
     DdNode *zero;		/* constant 0 */
+/* NuSMV: add begin */
+    DdNode *val_true;		/* constant TRUE */
+    DdNode *val_false;		/* constant FALSE */
+    void   *env_arg;
+    int   (*print_fun)(struct DdManager*, FILE*, CUDD_VALUE_TYPE, void*);
+    char* (*sprint_fun)(struct DdManager*, CUDD_VALUE_TYPE, void*);
+    void  (*type_error_fun)(struct DdManager*, FILE*, CUDD_VALUE_TYPE, void*);
+    void  (*fatal_error_fun)(struct DdManager*, FILE*, const char*, void*);
+/* NuSMV: add end */
     DdNode *plusinfinity;	/* plus infinity */
     DdNode *minusinfinity;	/* minus infinity */
     DdNode *background;		/* background value */
@@ -440,9 +441,16 @@
 #endif
     Cudd_ErrorType errorCode;	/* info on last error */
     /* Statistical counters. */
-    unsigned long memused;	/* total memory allocated for the manager */
-    unsigned long maxmem;	/* target maximum memory */
-    unsigned long maxmemhard;	/* hard limit for maximum memory */
+
+  /* NuSMV: add begin */
+    ptruint memused;	/* total memory allocated for the manager */
+    ptruint maxmem;	/* target maximum memory */
+    ptruint maxmemhard;	/* hard limit for maximum memory */
+    /* WAS: unsigned long memused;	total memory allocated for the manager
+            unsigned long maxmem;	target maximum memory 
+            unsigned long maxmemhard;	hard limit for maximum memory */
+  /* NuSMV: add end */
+
     int garbageCollections;	/* number of garbage collections */
     long GCTime;		/* total time spent in garbage collection */
     long reordTime;		/* total time spent in reordering */
@@ -706,14 +714,19 @@
   SeeAlso     [ddCHash ddCHash2]
 
 ******************************************************************************/
-#if SIZEOF_VOID_P == 8 && SIZEOF_INT == 4
-#define ddHash(f,g,s) \
-((((unsigned)(unsigned long)(f) * DD_P1 + \
-   (unsigned)(unsigned long)(g)) * DD_P2) >> (s))
-#else
-#define ddHash(f,g,s) \
-((((unsigned)(f) * DD_P1 + (unsigned)(g)) * DD_P2) >> (s))
-#endif
+/* NuSMV: add begin */
+#define ddHash(f,g,s)                     \
+  ((((unsigned)(ptruint)(f) * DD_P1 +           \
+     (unsigned)(ptruint)(g)) * DD_P2) >> (s))
+  /* WAS: #if NUSMV_SIZEOF_VOID_P == 8 && NUSMV_SIZEOF_INT == 4
+          #define ddHash(f,g,s) \
+          ((((unsigned)(unsigned long)(f) * DD_P1 +     \
+          (unsigned)(unsigned long)(g)) * DD_P2) >> (s))
+          #else
+          #define ddHash(f,g,s)                                 \
+          ((((unsigned)(f) * DD_P1 + (unsigned)(g)) * DD_P2) >> (s))
+          #endif */
+/* NuSMV: add end */
 
 
 /**Macro***********************************************************************
@@ -727,17 +740,22 @@
   SeeAlso     [ddHash ddCHash2]
 
 ******************************************************************************/
-#if SIZEOF_VOID_P == 8 && SIZEOF_INT == 4
-#define ddCHash(o,f,g,h,s) \
-((((((unsigned)(unsigned long)(f) + (unsigned)(unsigned long)(o)) * DD_P1 + \
-    (unsigned)(unsigned long)(g)) * DD_P2 + \
-   (unsigned)(unsigned long)(h)) * DD_P3) >> (s))
-#else
-#define ddCHash(o,f,g,h,s) \
-((((((unsigned)(f) + (unsigned)(o)) * DD_P1 + (unsigned)(g)) * DD_P2 + \
-   (unsigned)(h)) * DD_P3) >> (s))
-#endif
-
+/* NuSMV: add begin */
+#define ddCHash(o,f,g,h,s)                                            \
+  ((((((unsigned)(ptruint)(f) + (unsigned)(ptruint)(o)) * DD_P1 +     \
+      (unsigned)(ptruint)(g)) * DD_P2 +                               \
+     (unsigned)(ptruint)(h)) * DD_P3) >> (s))
+  /* WAS: #if NUSMV_SIZEOF_VOID_P == 8 && NUSMV_SIZEOF_INT == 4
+          #define ddCHash(o,f,g,h,s)                                         \
+          ((((((unsigned)(unsigned long)(f) + (unsigned)(unsigned long)(o)) * DD_P1 + \
+          (unsigned)(unsigned long)(g)) * DD_P2 +                       \
+          (unsigned)(unsigned long)(h)) * DD_P3) >> (s))
+          #else
+          #define ddCHash(o,f,g,h,s)                                    \
+          ((((((unsigned)(f) + (unsigned)(o)) * DD_P1 + (unsigned)(g)) * DD_P2 + \
+          (unsigned)(h)) * DD_P3) >> (s))
+          #endif */
+/* NuSMV: add end */
 
 /**Macro***********************************************************************
 
@@ -751,15 +769,19 @@
   SeeAlso     [ddHash ddCHash]
 
 ******************************************************************************/
-#if SIZEOF_VOID_P == 8 && SIZEOF_INT == 4
-#define ddCHash2(o,f,g,s) \
-(((((unsigned)(unsigned long)(f) + (unsigned)(unsigned long)(o)) * DD_P1 + \
-   (unsigned)(unsigned long)(g)) * DD_P2) >> (s))
-#else
-#define ddCHash2(o,f,g,s) \
-(((((unsigned)(f) + (unsigned)(o)) * DD_P1 + (unsigned)(g)) * DD_P2) >> (s))
-#endif
-
+/* NuSMV: add begin */
+#define ddCHash2(o,f,g,s)                                            \
+  (((((unsigned)(ptruint)(f) + (unsigned)(ptruint)(o)) * DD_P1 +     \
+     (unsigned)(ptruint)(g)) * DD_P2) >> (s))
+  /* WAS: #if NUSMV_SIZEOF_VOID_P == 8 && NUSMV_SIZEOF_INT == 4
+          #define ddCHash2(o,f,g,s)                                          \
+          (((((unsigned)(unsigned long)(f) + (unsigned)(unsigned long)(o)) * DD_P1 + \
+          (unsigned)(unsigned long)(g)) * DD_P2) >> (s))
+          #else
+          #define ddCHash2(o,f,g,s)                                     \
+          (((((unsigned)(f) + (unsigned)(o)) * DD_P1 + (unsigned)(g)) * DD_P2) >> (s))
+          #endif */
+/* NuSMV: add end */
 
 /**Macro***********************************************************************
 
@@ -843,7 +865,7 @@
   SeeAlso     [cuddSatDec]
 
 ******************************************************************************/
-#if SIZEOF_VOID_P == 8 && SIZEOF_INT == 4
+#if NUSMV_SIZEOF_VOID_P == 8 && NUSMV_SIZEOF_INT == 4
 #define cuddSatInc(x) ((x)++)
 #else
 #define cuddSatInc(x) ((x) += (x) != (DdHalfWord)DD_MAXREF)
@@ -861,13 +883,12 @@
   SeeAlso     [cuddSatInc]
 
 ******************************************************************************/
-#if SIZEOF_VOID_P == 8 && SIZEOF_INT == 4
+#if NUSMV_SIZEOF_VOID_P == 8 && NUSMV_SIZEOF_INT == 4
 #define cuddSatDec(x) ((x)--)
 #else
 #define cuddSatDec(x) ((x) -= (x) != (DdHalfWord)DD_MAXREF)
 #endif
 
-
 /**Macro***********************************************************************
 
   Synopsis    [Returns the constant 1 node.]
@@ -888,7 +909,7 @@
 
   Description [Returns the arithmetic 0 constant node. This is different
   from the logical zero. The latter is obtained by
-  Cudd_Not(DD_ONE(dd)).]
+  Cudd_Not(DD_TRUE(dd)).]
 
   SideEffects [none]
 
@@ -897,6 +918,35 @@
 ******************************************************************************/
 #define DD_ZERO(dd) ((dd)->zero)
 
+/* NuSMV: add begin */
+/**Macro***********************************************************************
+
+  Synopsis    [Returns the constant TRUE node.]
+
+  Description []
+
+  SideEffects [none]
+
+  SeeAlso     [DD_FALSE DD_PLUS_INFINITY DD_MINUS_INFINITY]
+
+******************************************************************************/
+#define DD_TRUE(dd)		((dd)->val_true)
+
+/**Macro***********************************************************************
+
+  Synopsis    [Returns the constant FALSE node.]
+
+  Description [Returns the constant FALSE node. This is different
+  from the logical zero. The latter is obtained by
+  Cudd_Not(DD_TRUE(dd)).]
+
+  SideEffects [none]
+
+  SeeAlso     [DD_TRUE Cudd_Not DD_PLUS_INFINITY DD_MINUS_INFINITY]
+
+******************************************************************************/
+#define DD_FALSE(dd) ((dd)->val_false)
+/* NuSMV: add end */
 
 /**Macro***********************************************************************
 
@@ -906,7 +956,7 @@
 
   SideEffects [none]
 
-  SeeAlso     [DD_ONE DD_ZERO DD_MINUS_INFINITY]
+  SeeAlso     [DD_TRUE DD_FALSE DD_MINUS_INFINITY]
 
 ******************************************************************************/
 #define DD_PLUS_INFINITY(dd) ((dd)->plusinfinity)
@@ -920,7 +970,7 @@
 
   SideEffects [none]
 
-  SeeAlso     [DD_ONE DD_ZERO DD_PLUS_INFINITY]
+  SeeAlso     [DD_TRUE DD_FALSE DD_PLUS_INFINITY]
 
 ******************************************************************************/
 #define DD_MINUS_INFINITY(dd) ((dd)->minusinfinity)
@@ -1008,6 +1058,27 @@
 #define statLine(dd)
 #endif
 
+/* NuSMV: added begin */
+extern int node_is_failure(struct node* x);
+#if !defined(NODE_PTR)
+# define NODE_PTR(x) ((struct node*) x)
+#endif
+
+
+/**Macro***********************************************************************
+
+  Synopsis    [Used to handle FAILURE noded (this is an extension 
+  required by NuSMV]
+
+  Description []
+
+  SeeAlso     []
+
+******************************************************************************/
+#define HANDLE_FAILURE(dd, n) \
+   if (cuddIsConstant(n) && node_is_failure(NODE_PTR(cuddV(n)))) return(n)
+/* NuSMV: added end */
+
 
 /**AutomaticStart*************************************************************/
 
@@ -1018,7 +1089,24 @@
 extern DdNode * cuddAddExistAbstractRecur (DdManager *manager, DdNode *f, DdNode *cube);
 extern DdNode * cuddAddUnivAbstractRecur (DdManager *manager, DdNode *f, DdNode *cube);
 extern DdNode * cuddAddOrAbstractRecur (DdManager *manager, DdNode *f, DdNode *cube);
+/* NuSMV: added begin */
+extern DdNode * cudd_addApplyRecur (DdManager *dd, CUDD_VALUE_TYPE (*op)(), DdNode *f, DdNode *g, void* arg);
+extern DdNode * cudd_addAndRecur (DdManager *manager, DdNode *f, DdNode *g);
+extern DdNode * cudd_addOrRecur (DdManager *manager, DdNode *f, DdNode *g);
+extern DdNode * cudd_addXorRecur (DdManager *manager, DdNode *f, DdNode *g);
+extern DdNode * cudd_addNotRecur (DdManager *manager, DdNode *f);
+extern DdNode * cudd_addIfThenRecur (DdManager *manager, DdNode *f, DdNode *g);
+extern DdNode * cudd_addElseRecur (DdManager *manager, DdNode *f, DdNode *g);
+extern DdNode * cudd_addCubeDiffRecur (DdManager *dd, DdNode *f, DdNode *g);
+extern DdNode * cudd_bddCubeDiffRecur (DdManager *dd, DdNode *f, DdNode *g);
+extern int Cudd_BddGetLowestVarRecur (DdManager *dd, DdNode * N, int index);
+extern DdNode * Cudd_AddMakeVarMaskRecur (DdManager *dd, DdNode * N, int n, int l, int offset);
+#if 0
+/* NuSMV: added end */
 extern DdNode * cuddAddApplyRecur (DdManager *dd, DdNode * (*)(DdManager *, DdNode **, DdNode **), DdNode *f, DdNode *g);
+/* NuSMV: added begin */
+#endif
+/* NuSMV: added end */
 extern DdNode * cuddAddMonadicApplyRecur (DdManager * dd, DdNode * (*op)(DdManager *, DdNode *), DdNode * f);
 extern DdNode * cuddAddScalarInverseRecur (DdManager *dd, DdNode *f, DdNode *epsilon);
 extern DdNode * cuddAddIteRecur (DdManager *dd, DdNode *f, DdNode *g, DdNode *h);
diff -Nru a/cudd/cuddLCache.c b/cudd/cuddLCache.c
--- a/cudd/cuddLCache.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddLCache.c	2024-05-03 15:06:21.838493208 +0200
@@ -96,7 +96,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddLCache.c,v 1.21 2004/08/13 18:04:49 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddLCache.c,v 1.1.2.1 2010-02-04 10:41:15 nusmv Exp $";
 #endif
 
 /*---------------------------------------------------------------------------*/
@@ -114,15 +114,20 @@
   SeeAlso     [ddLCHash3 ddLCHash]
 
 ******************************************************************************/
-#if SIZEOF_VOID_P == 8 && SIZEOF_INT == 4
-#define ddLCHash2(f,g,shift) \
-((((unsigned)(unsigned long)(f) * DD_P1 + \
-   (unsigned)(unsigned long)(g)) * DD_P2) >> (shift))
-#else
-#define ddLCHash2(f,g,shift) \
-((((unsigned)(f) * DD_P1 + (unsigned)(g)) * DD_P2) >> (shift))
-#endif
-
+/* NuSMV: add begin */
+#define ddLCHash2(f,g,shift)                        \
+  ((((unsigned)(ptruint)(f) * DD_P1 +               \
+     (unsigned)(ptruint)(g)) * DD_P2) >> (shift))
+
+  /* WAS: #if NUSMV_SIZEOF_VOID_P == 8 && NUSMV_SIZEOF_INT == 4
+          #define ddLCHash2(f,g,shift) \
+          ((((unsigned)(unsigned long)(f) * DD_P1 +     \
+          (unsigned)(unsigned long)(g)) * DD_P2) >> (shift))
+          #else
+          #define ddLCHash2(f,g,shift)                          \
+          ((((unsigned)(f) * DD_P1 + (unsigned)(g)) * DD_P2) >> (shift))
+          #endif */
+/* NuSMV: add end */
 
 /**Macro***********************************************************************
 
@@ -430,13 +435,19 @@
   DdLocalCache * cache)
 {
     double count, mean, meansq, stddev, expected;
-    long max, min;
+    /* NuSMV: add begin */
+    ptrint max, min;
+      /* WAS: long max, min; */
+    /* NuSMV: add end */
     int imax, imin;
     int i, retval, slots;
     long *hystogram;
     int nbins = DD_HYSTO_BINS;
     int bin;
-    long thiscount;
+    /* NuSMV: add begin */
+    ptrint thiscount;
+      /* WAS: long thiscount; */
+    /* NuSMV: add end */
     double totalcount;
     int nzeroes;
     DdLocalCacheItem *entry;
@@ -445,7 +456,10 @@
     slots = cache->slots;
 
     meansq = mean = expected = 0.0;
-    max = min = (long) cache->item[0].count;
+    /* NuSMV: add begin */
+    max = min = (ptrint) cache->item[0].count;
+      /* WAS: max = min = (long) cache->item[0].count; */
+    /* NuSMV: add end */
     imax = imin = nzeroes = 0;
     totalcount = 0.0;
 
@@ -460,7 +474,10 @@
     for (i = 0; i < slots; i++) {
 	entry = (DdLocalCacheItem *) ((char *) cache->item +
 				      i * cache->itemsize);
-	thiscount = (long) entry->count;
+        /* NuSMV: add begin */
+	thiscount = (ptrint) entry->count;
+          /* WAS: thiscount = (long) entry->count; */
+        /* NuSMV: add end */
 	if (thiscount > max) {
 	    max = thiscount;
 	    imax = i;
diff -Nru a/cudd/cuddLevelQ.c b/cudd/cuddLevelQ.c
--- a/cudd/cuddLevelQ.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddLevelQ.c	2024-05-03 15:06:21.838493208 +0200
@@ -98,7 +98,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddLevelQ.c,v 1.12 2004/08/13 18:04:49 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddLevelQ.c,v 1.1.2.1 2010-02-04 10:41:15 nusmv Exp $";
 #endif
 
 /*---------------------------------------------------------------------------*/
@@ -117,14 +117,17 @@
   SeeAlso     [hashInsert hashLookup hashDelete]
 
 ******************************************************************************/
-#if SIZEOF_VOID_P == 8 && SIZEOF_INT == 4
-#define lqHash(key,shift) \
-(((unsigned)(unsigned long)(key) * DD_P1) >> (shift))
-#else
-#define lqHash(key,shift) \
-(((unsigned)(key) * DD_P1) >> (shift))
-#endif
-
+/* NuSMV: add begin */
+#define lqHash(key,shift)                               \
+  (((unsigned)(ptruint)(key) * DD_P1) >> (shift))
+  /* WAS: #if NUSMV_SIZEOF_VOID_P == 8 && NUSMV_SIZEOF_INT == 4
+          #define lqHash(key,shift) \
+          (((unsigned)(unsigned long)(key) * DD_P1) >> (shift))
+          #else
+          #define lqHash(key,shift)             \
+          (((unsigned)(key) * DD_P1) >> (shift))
+          #endif */
+/* NuSMV: add end */
 
 /**AutomaticStart*************************************************************/
 
diff -Nru a/cudd/cuddLinear.c b/cudd/cuddLinear.c
--- a/cudd/cuddLinear.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddLinear.c	2024-05-03 15:06:21.838493208 +0200
@@ -71,7 +71,7 @@
 #define CUDD_SWAP_MOVE 0
 #define CUDD_LINEAR_TRANSFORM_MOVE 1
 #define CUDD_INVERSE_TRANSFORM_MOVE 2
-#if SIZEOF_LONG == 8
+#if NUSMV_SIZEOF_LONG == 8
 #define BPL 64
 #define LOGBPL 6
 #else
@@ -92,7 +92,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddLinear.c,v 1.26 2004/08/13 18:04:49 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddLinear.c,v 1.1.2.1 2010-02-04 10:41:15 nusmv Exp $";
 #endif
 
 static	int	*entry;
@@ -381,6 +381,10 @@
     int    count, idcheck;
 #endif
 
+    /* NuSMV: add begin */
+    last = (DdNode*) NULL;
+    /* NuSMV: add end */
+
 #ifdef DD_DEBUG
     assert(x < y);
     assert(cuddNextHigh(table,x) == y);
diff -Nru a/cudd/cuddLiteral.c b/cudd/cuddLiteral.c
--- a/cudd/cuddLiteral.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddLiteral.c	2024-05-03 15:06:21.838493208 +0200
@@ -73,7 +73,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddLiteral.c,v 1.8 2004/08/13 18:04:50 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddLiteral.c,v 1.1.2.1 2010-02-04 10:41:15 nusmv Exp $";
 #endif
 
 /*---------------------------------------------------------------------------*/
@@ -154,8 +154,8 @@
     DdNode *res, *tmp;
     DdNode *F, *G;
     DdNode *fc, *gc;
-    DdNode *one;
-    DdNode *zero;
+    DdNode *_true;
+    DdNode *_false;
     unsigned int topf, topg, comple;
     int phasef, phaseg;
 
@@ -164,15 +164,15 @@
 
     F = Cudd_Regular(f);
     G = Cudd_Regular(g);
-    one = DD_ONE(dd);
+    _true = DD_TRUE(dd);
 
     /* Here f != g. If F == G, then f and g are complementary.
     ** Since they are two cubes, this case only occurs when f == v,
     ** g == v', and v is a variable or its complement.
     */
-    if (F == G) return(one);
+    if (F == G) return(_true);
 
-    zero = Cudd_Not(one);
+    _false = Cudd_Not(_true);
     topf = cuddI(dd,F->index);
     topg = cuddI(dd,G->index);
     /* Look for a variable common to both cubes. If there are none, this
@@ -183,7 +183,7 @@
 	    comple = f != F;
 	    f = cuddT(F);
 	    if (comple) f = Cudd_Not(f);
-	    if (f == zero) {
+	    if (f == _false) {
 		f = cuddE(F);
 		if (comple) f = Cudd_Not(f);
 	    }
@@ -193,7 +193,7 @@
 	    comple = g != G;
 	    g = cuddT(G);
 	    if (comple) g = Cudd_Not(g);
-	    if (g == zero) {
+	    if (g == _false) {
 		g = cuddE(G);
 		if (comple) g = Cudd_Not(g);
 	    }
@@ -202,8 +202,8 @@
 	}
     }
 
-    /* At this point, f == one <=> g == 1. It suffices to test one of them. */
-    if (f == one) return(one);
+    /* At this point, f == _true <=> g == 1. It suffices to test one of them. */
+    if (f == _true) return(_true);
 
     res = cuddCacheLookup2(dd,Cudd_bddLiteralSetIntersection,f,g);
     if (res != NULL) {
@@ -215,7 +215,7 @@
     fc = cuddT(F);
     phasef = 1;
     if (comple) fc = Cudd_Not(fc);
-    if (fc == zero) {
+    if (fc == _false) {
 	fc = cuddE(F);
 	phasef = 0;
 	if (comple) fc = Cudd_Not(fc);
@@ -224,7 +224,7 @@
     gc = cuddT(G);
     phaseg = 1;
     if (comple) gc = Cudd_Not(gc);
-    if (gc == zero) {
+    if (gc == _false) {
 	gc = cuddE(G);
 	phaseg = 0;
 	if (comple) gc = Cudd_Not(gc);
diff -Nru a/cudd/cuddMatMult.c b/cudd/cuddMatMult.c
--- a/cudd/cuddMatMult.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddMatMult.c	2024-05-03 15:06:21.838493208 +0200
@@ -80,7 +80,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddMatMult.c,v 1.17 2004/08/13 18:04:50 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddMatMult.c,v 1.1.2.1 2010-02-04 10:41:15 nusmv Exp $";
 #endif
 
 /*---------------------------------------------------------------------------*/
@@ -190,9 +190,10 @@
     tmp = Cudd_addApply(dd,Cudd_addTimes,A,B);
     if (tmp == NULL) return(NULL);
     Cudd_Ref(tmp);
-    Cudd_Ref(cube = DD_ONE(dd));
+#warning [AMa] Not sure if 1 or TRUE
+    Cudd_Ref(cube = DD_TRUE(dd));
     for (i = nz-1; i >= 0; i--) {
-	 w = Cudd_addIte(dd,z[i],cube,DD_ZERO(dd));
+	 w = Cudd_addIte(dd,z[i],cube,DD_FALSE(dd));
 	 if (w == NULL) {
 	    Cudd_RecursiveDeref(dd,tmp);
 	    return(NULL);
@@ -351,7 +352,8 @@
     DD_CTFP cacheOp;
 
     statLine(dd);
-    zero = DD_ZERO(dd);
+#warning [AMa] Not sure, think 0
+    zero = DD_FALSE(dd);
 
     if (A == zero || B == zero) {
         return(zero);
diff -Nru a/cudd/cuddPriority.c b/cudd/cuddPriority.c
--- a/cudd/cuddPriority.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddPriority.c	2024-05-03 15:06:21.838493208 +0200
@@ -95,7 +95,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddPriority.c,v 1.26 2004/08/13 18:04:50 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddPriority.c,v 1.1.2.1 2010-02-04 10:41:15 nusmv Exp $";
 #endif
 
 /*---------------------------------------------------------------------------*/
@@ -207,7 +207,7 @@
     }
 
     /* Initialize abstraction cube. */
-    zcube = DD_ONE(dd);
+    zcube = DD_TRUE(dd);
     cuddRef(zcube);
     for (i = n - 1; i >= 0; i--) {
 	DdNode *tmpp;
@@ -407,9 +407,9 @@
     DdNode *one, *zero;
     DdNode *u, *v, *w;
     int     i;
-
-    one = DD_ONE(dd);
-    zero = DD_ZERO(dd);
+#warning [AMa] Rename variables?
+    one = DD_TRUE(dd);
+    zero = DD_FALSE(dd);
 
     /* Build bottom part of ADD outside loop. */
     v = Cudd_addIte(dd, y[N-1], one, zero);
@@ -494,8 +494,8 @@
     DdNode *one, *zero;
     DdNode *z1, *z2, *z3, *z4, *y1_, *y2, *x1;
     int     i;
-
-    one = DD_ONE(dd);
+#warning [AMa] Rename variables?
+    one = DD_TRUE(dd);
     zero = Cudd_Not(one);
 
     /* Build bottom part of BDD outside loop. */
@@ -622,7 +622,8 @@
     DdNode *z1, *z2, *z3, *z4, *y1_, *y2, *x1;
     int     i;
 
-    one = DD_ONE(dd);
+#warning [AMa] Rename variables?
+    one = DD_TRUE(dd);
     zero = Cudd_Not(one);
 
     /* Build bottom part of BDD outside loop. */
@@ -797,7 +798,8 @@
     DdNode  *tempAdd,*temp;
     int     i;
 
-    result = DD_ZERO(dd);
+#warning [AMa] Here it should be 0?
+    result = DD_FALSE(dd);
     cuddRef(result);
 
     for (i = 0; i < nVars; i++) {
@@ -807,6 +809,7 @@
 	    return(NULL);
 	}
 	cuddRef(tempBdd);
+#warning [AMa] Maybe it should use Cudd_BddTo01Add
 	tempAdd = Cudd_BddToAdd(dd,tempBdd);
 	if (tempAdd == NULL) {
 	    Cudd_RecursiveDeref(dd,tempBdd);
@@ -966,8 +969,9 @@
     DdNode *res, *res1, *res2, *resA;
     DdNode *r, *y, *RT, *RE, *YT, *YE, *Yrest, *Ra, *Ran, *Gamma, *Alpha;
     unsigned int topR, topY, top, index;
-    DdNode *one = DD_ONE(dd);
+    DdNode *one = DD_TRUE(dd);
 
+#warning [AMa] Rename variables?
     statLine(dd);
     if (Y == one) return(R);
 
@@ -1187,9 +1191,10 @@
     DdNode *res, *F, *G, *ft, *fe, *gt, *ge, *tt, *ee;
     DdNode *ctt, *cee, *cte, *cet;
     CUDD_VALUE_TYPE minD, dtt, dee, dte, det;
-    DdNode *one = DD_ONE(dd);
+#warning [AMa] ??? Rename vars.
+    DdNode *one = DD_TRUE(dd);
     DdNode *lzero = Cudd_Not(one);
-    DdNode *azero = DD_ZERO(dd);
+    DdNode *azero = DD_FALSE(dd);
     unsigned int topf, topg, index;
 
     statLine(dd);
@@ -1364,7 +1369,7 @@
 /* Definition of static functions                                            */
 /*---------------------------------------------------------------------------*/
 
-
+#warning [AMa] Check doc, possibly rename vars
 /**Function********************************************************************
 
   Synopsis    [Performs the recursive step of Cudd_MinHammingDist.]
@@ -1407,7 +1412,7 @@
     F = Cudd_Regular(f);
 
     if (cuddIsConstant(F)) {
-	zero = Cudd_Not(DD_ONE(dd));
+	zero = Cudd_Not(DD_TRUE(dd));
 	if (f == dd->background || f == zero) {
 	    return(upperBound);
 	} else {
@@ -1479,7 +1484,8 @@
 
     /* One and zero are special cases because the distance is implied. */
     if (Cudd_IsConstant(f)) {
-	*distance = (f == DD_ONE(dd)) ? 0.0 :
+#warning [AMa] ??
+	*distance = (f == DD_TRUE(dd)) ? 0.0 :
 	    (1.0 + (CUDD_VALUE_TYPE) CUDD_CONST_INDEX);
 	return(f);
     }
@@ -1489,16 +1495,16 @@
     t = cuddT(f);
     if (Cudd_IsConstant(t) && cuddV(t) <= 0) {
 #ifdef DD_DEBUG
-	assert(!Cudd_IsConstant(cuddE(f)) || cuddE(f) == DD_ONE(dd));
+	assert(!Cudd_IsConstant(cuddE(f)) || cuddE(f) == DD_TRUE(dd));
 #endif
 	*distance = -cuddV(t);
-	cube = cuddUniqueInter(dd, f->index, DD_ZERO(dd), cuddE(f));
+	cube = cuddUniqueInter(dd, f->index, DD_FALSE(dd), cuddE(f));
     } else {
 #ifdef DD_DEBUG
-	assert(!Cudd_IsConstant(t) || t == DD_ONE(dd));
+	assert(!Cudd_IsConstant(t) || t == DD_TRUE(dd));
 #endif
 	*distance = -cuddV(cuddE(f));
-	cube = cuddUniqueInter(dd, f->index, t, DD_ZERO(dd));
+	cube = cuddUniqueInter(dd, f->index, t, DD_FALSE(dd));
     }
 
     return(cube);
@@ -1528,6 +1534,7 @@
 {
     DdNode *res, *constant;
 
+#warning [AMa] Review comment, if TF is correct
     /* Special case.  The cube is either one or zero, and we do not
     ** add any variables.  Hence, the result is also one or zero,
     ** and the distance remains implied by the value of the constant. */
@@ -1539,7 +1546,7 @@
 
     if (index == CUDD_CONST_INDEX) {
 	/* Replace the top node. */
-	if (cuddT(cube) == DD_ZERO(dd)) {
+	if (cuddT(cube) == DD_FALSE(dd)) {
 	    res = cuddUniqueInter(dd,cube->index,constant,cuddE(cube));
 	} else {
 	    res = cuddUniqueInter(dd,cube->index,cuddT(cube),constant);
diff -Nru a/cudd/cuddRead.c b/cudd/cuddRead.c
--- a/cudd/cuddRead.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddRead.c	2024-05-03 15:06:21.838493208 +0200
@@ -74,7 +74,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddRead.c,v 1.6 2004/08/13 18:04:50 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddRead.c,v 1.1.2.1 2010-02-04 10:41:15 nusmv Exp $";
 #endif
 
 /*---------------------------------------------------------------------------*/
@@ -163,9 +163,9 @@
     int lnx, lny;
     CUDD_VALUE_TYPE val;
     DdNode **lx, **ly, **lxn, **lyn;
-
-    one = DD_ONE(dd);
-    zero = DD_ZERO(dd);
+#warning [AMa] Here should be ok to use T/F
+    one = DD_TRUE(dd);
+    zero = DD_FALSE(dd);
 
     err = fscanf(fp, "%d %d", &u, &v);
     if (err == EOF) {
@@ -264,7 +264,7 @@
 	} else if (u >= *m || v >= *n || u < 0 || v < 0) {
 	    return(0);
 	}
- 
+ #warning [AMa] Here I think that "1" should be used
 	minterm1 = one; cuddRef(minterm1);
 
 	/* Build minterm1 corresponding to this arc */
@@ -377,15 +377,15 @@
   int  by /* first index of column variables */,
   int  sy /* step of column variables */)
 {
-    DdNode *one, *zero;
+    DdNode *_true, *_false;
     DdNode *w;
     DdNode *minterm1;
     int u, v, err, i, nv;
     int lnx, lny;
     DdNode **lx, **ly;
 
-    one = DD_ONE(dd);
-    zero = Cudd_Not(one);
+    _true = DD_TRUE(dd);
+    _false = Cudd_Not(_true);
 
     err = fscanf(fp, "%d %d", &u, &v);
     if (err == EOF) {
@@ -428,7 +428,7 @@
     for (i = *nx, nv = bx + (*nx) * sx; i < lnx; i++, nv += sx) {
 	do {
 	    dd->reordered = 0;
-	    lx[i] = cuddUniqueInter(dd, nv, one, zero);
+	    lx[i] = cuddUniqueInter(dd, nv, _true, _false);
 	} while (dd->reordered == 1);
 	if (lx[i] == NULL) return(0);
         cuddRef(lx[i]);
@@ -436,7 +436,7 @@
     for (i = *ny, nv = by + (*ny) * sy; i < lny; i++, nv += sy) {
 	do {
 	    dd->reordered = 0;
-	    ly[i] = cuddUniqueInter(dd, nv, one, zero);
+	    ly[i] = cuddUniqueInter(dd, nv, _true, _false);
 	} while (dd->reordered == 1);
 	if (ly[i] == NULL) return(0);
 	cuddRef(ly[i]);
@@ -444,7 +444,7 @@
     *nx = lnx;
     *ny = lny;
 
-    *E = zero; /* this call will never cause reordering */
+    *E = _false; /* this call will never cause reordering */
     cuddRef(*E);
 
     while (! feof(fp)) {
@@ -457,7 +457,7 @@
 	    return(0);
 	}
  
-	minterm1 = one; cuddRef(minterm1);
+	minterm1 = _true; cuddRef(minterm1);
 
 	/* Build minterm1 corresponding to this arc. */
 	for (i = lnx - 1; i>=0; i--) {
diff -Nru a/cudd/cuddRef.c b/cudd/cuddRef.c
--- a/cudd/cuddRef.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddRef.c	2024-05-03 15:06:21.838493208 +0200
@@ -88,7 +88,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddRef.c,v 1.28 2004/08/13 18:04:50 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddRef.c,v 1.1.2.1 2010-02-04 10:41:15 nusmv Exp $";
 #endif
 
 /*---------------------------------------------------------------------------*/
@@ -291,7 +291,7 @@
 #else
     if (cuddIsConstant(n) || n->ref > 1) {
 #ifdef DD_DEBUG
-	assert(n->ref != 1 && (!cuddIsConstant(n) || n == DD_ONE(table)));
+	assert(n->ref != 1 && (!cuddIsConstant(n) || n == DD_TRUE(table)));
 #endif
 	cuddSatDec(n->ref);
 	return;
@@ -538,11 +538,25 @@
 	node = nodelist[j];
 	while (node != NULL) {
 	    if (node->ref != 0 && node->ref != DD_MAXREF) {
+  /* NuSMV: add begin */
+#if 0
+  /* NuSMV: add end */
 		if (node == manager->one) {
+  /* NuSMV: add begin */
+#endif
+                if (node == manager->val_true) {
+  /* NuSMV: add end */
 		    if ((int) node->ref != remain) {
 			count++;
 		    }
+  /* NuSMV: add begin */
+#if 0
+  /* NuSMV: add end */
 		} else if (node == manager->zero ||
+  /* NuSMV: add begin */
+#endif
+                } else if (node == manager->val_false ||
+  /* NuSMV: add end */
 		node == manager->plusinfinity ||
 		node == manager->minusinfinity) {
 		    if (node->ref != 1) {
diff -Nru a/cudd/cuddReorder.c b/cudd/cuddReorder.c
--- a/cudd/cuddReorder.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddReorder.c	2024-05-03 15:06:21.838493208 +0200
@@ -95,7 +95,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddReorder.c,v 1.67 2004/08/13 18:04:50 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddReorder.c,v 1.1.2.1 2010-02-04 10:41:15 nusmv Exp $";
 #endif
 
 static	int	*entry;
@@ -269,6 +269,11 @@
 	result = cuddTreeSifting(table,heuristic);
     }
 
+    /* NuSMV Change begins */
+    /* Fixes the groups tree after the reordering */
+    if (result != 0) { bddFixTree(table, table->tree); }
+    /* NuSMV Change ends   */
+
 #ifdef DD_STATS
     (void) fprintf(table->out,"\n");
     finalSize = table->keys - table->isolated;
@@ -302,7 +307,10 @@
     /* Run hook functions. */
     hook = table->postReorderingHook;
     while (hook != NULL) {
-	int res = (hook->f)(table, "BDD", (void *)localTime);
+      /* NuSMV: add begin */
+	int res = (hook->f)(table, "BDD", (void *)(ptruint)localTime);
+          /* WAS: int res = (hook->f)(table, "BDD", (void *)localTime); */
+        /* NuSMV: add end */
 	if (res == 0) return(0);
 	hook = hook->next;
     }
@@ -373,6 +381,11 @@
 
     if (!ddReorderPostprocess(table)) return(0);
 
+    /* NuSMV Change begins */
+    /* Fixes the groups tree after the reordering */
+    if (result != 0) { bddFixTree(table, table->tree); }
+    /* NuSMV Change ends   */
+
     return(result);
 
 } /* end of Cudd_ShuffleHeap */
@@ -440,7 +453,10 @@
 #endif
 	    return(NULL);
 	} else {	/* successful allocation; slice memory */
-	    unsigned long offset;
+          /* NuSMV: add begin */
+	    ptruint offset;
+              /* WAS: unsigned long offset; */
+            /* NuSMV: add end */
 	    table->memused += (DD_MEM_CHUNK + 1) * sizeof(DdNode);
 	    mem[0] = (DdNode *) table->memoryList;
 	    table->memoryList = mem;
@@ -449,10 +465,16 @@
 	    ** power of 2 and a multiple of the size of a pointer.
 	    ** If we align one node, all the others will be aligned
 	    ** as well. */
-	    offset = (unsigned long) mem & (sizeof(DdNode) - 1);
+            /* NuSMV: add begin */
+	    offset = (ptruint) mem & (sizeof(DdNode) - 1);
+              /* WAS: offset = (unsigned long) mem & (sizeof(DdNode) - 1); */
+            /* NuSMV: add end */
 	    mem += (sizeof(DdNode) - offset) / sizeof(DdNodePtr);
 #ifdef DD_DEBUG
-	    assert(((unsigned long) mem & (sizeof(DdNode) - 1)) == 0);
+            /* NuSMV: add begin */
+	    assert(((ptruint) mem & (sizeof(DdNode) - 1)) == 0);
+              /* WAS: assert(((unsigned long) mem & (sizeof(DdNode) - 1)) == 0); */
+            /* NuSMV: add end */
 #endif
 	    list = (DdNode *) mem;
 
@@ -610,6 +632,11 @@
     int	modulo;
     int result;
 
+    /* NuSMV: add begin */
+    pivot = 0;
+    /* NuSMV: add end */
+
+
 #ifdef DD_DEBUG
     /* Sanity check */
     assert(lower >= 0 && upper < table->size && lower <= upper);
diff -Nru a/cudd/cuddSat.c b/cudd/cuddSat.c
--- a/cudd/cuddSat.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddSat.c	2024-05-03 15:06:21.838493208 +0200
@@ -96,10 +96,10 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddSat.c,v 1.34 2004/08/13 18:04:50 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddSat.c,v 1.1.2.1 2010-02-04 10:41:15 nusmv Exp $";
 #endif
 
-static	DdNode	*one, *zero;
+static	DdNode	*_true, *_false;
 
 /*---------------------------------------------------------------------------*/
 /* Macro declarations                                                        */
@@ -158,6 +158,10 @@
     int comple;
     DdNode *ptr;
 
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     comple = Cudd_IsComplement(f);
     ptr = Cudd_Regular(f);
 
@@ -207,9 +211,12 @@
     cuddPathPair *rootPair;
     int		complement, cost;
     int		i;
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
 
-    one = DD_ONE(manager);
-    zero = DD_ZERO(manager);
+    _true = DD_TRUE(manager);
+    _false = DD_FALSE(manager);
 
     /* Initialize support. Support does not depend on variable order.
     ** Hence, it does not need to be reinitialized if reordering occurs.
@@ -220,9 +227,9 @@
       }
     }
 
-    if (f == Cudd_Not(one) || f == zero) {
+    if (f == Cudd_Not(_true) || f == _false) {
       *length = DD_BIGGY;
-      return(Cudd_Not(one));
+      return(Cudd_Not(_true));
     }
     /* From this point on, a path exists. */
 
@@ -289,12 +296,12 @@
     cuddPathPair *rootPair;
     int		complement, cost;
 
-    one = DD_ONE(manager);
-    zero = DD_ZERO(manager);
+    _true = DD_TRUE(manager);
+    _false = DD_FALSE(manager);
 
-    if (f == Cudd_Not(one) || f == zero) {
+    if (f == Cudd_Not(_true) || f == _false) {
 	*length = DD_BIGGY;
-	return(Cudd_Not(one));
+	return(Cudd_Not(_true));
     }
     /* From this point on, a path exists. */
 
@@ -358,11 +365,13 @@
     st_table	*visited;
     cuddPathPair *my_pair;
     int		complement, cost;
+    _true = DD_TRUE(manager);
+    _false = DD_FALSE(manager);
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
 
-    one = DD_ONE(manager);
-    zero = DD_ZERO(manager);
-
-    if (f == Cudd_Not(one) || f == zero) {
+    if (f == Cudd_Not(_true) || f == _false) {
 	return(DD_BIGGY);
     }
 
@@ -400,7 +409,7 @@
 
   Description [Determines whether the function represented by BDD f is
   negative unate (monotonic decreasing) in variable i. Returns the
-  constant one is f is unate and the (logical) constant zero if it is not.
+  constant true is f is unate and the (logical) constant false if it is not.
   This function does not generate any new nodes.]
 
   SideEffects [None]
@@ -431,7 +440,7 @@
     */
     level = (unsigned) dd->perm[i];
     if (topf > level) {
-	return(DD_ONE(dd));
+	return(DD_TRUE(dd));
     }
 
     /* From now on, f is not constant. */
@@ -457,12 +466,12 @@
 	** monotonic decreasing in i.
 	*/
 	if (!Cudd_IsComplement(fv) && Cudd_IsComplement(fvn)) {
-	    return(Cudd_Not(DD_ONE(dd)));
+	    return(Cudd_Not(DD_TRUE(dd)));
 	}
-	res = Cudd_bddLeq(dd,fv,fvn) ? DD_ONE(dd) : Cudd_Not(DD_ONE(dd));
+	res = Cudd_bddLeq(dd,fv,fvn) ? DD_TRUE(dd) : Cudd_Not(DD_TRUE(dd));
     } else {
 	res = Cudd_Decreasing(dd,fv,i);
-	if (res == DD_ONE(dd)) {
+	if (res == DD_TRUE(dd)) {
 	    res = Cudd_Decreasing(dd,fvn,i);
 	}
     }
@@ -494,6 +503,10 @@
   DdNode * f,
   int  i)
 {
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     return(Cudd_Decreasing(dd,Cudd_Not(f),i));
 
 } /* end of Cudd_Increasing */
@@ -501,10 +514,10 @@
 
 /**Function********************************************************************
 
-  Synopsis    [Tells whether F and G are identical wherever D is 0.]
+  Synopsis    [Tells whether F and G are identical wherever D is FALSE.]
 
-  Description [Tells whether F and G are identical wherever D is 0.  F
-  and G are either two ADDs or two BDDs.  D is either a 0-1 ADD or a
+  Description [Tells whether F and G are identical wherever D is FALSE.  F
+  and G are either two ADDs or two BDDs.  D is either a FALSE-TRUE ADD or a
   BDD.  The function returns 1 if F and G are equivalent, and 0
   otherwise.  No new nodes are created.]
 
@@ -520,17 +533,19 @@
   DdNode * G,
   DdNode * D)
 {
-    DdNode *tmp, *One, *Gr, *Dr;
+    DdNode *tmp, *True, *Gr, *Dr;
     DdNode *Fv, *Fvn, *Gv, *Gvn, *Dv, *Dvn;
     int res;
     unsigned int flevel, glevel, dlevel, top;
-
-    One = DD_ONE(dd);
+    True = DD_TRUE(dd);
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
 
     statLine(dd);
     /* Check terminal cases. */
-    if (D == One || F == G) return(1);
-    if (D == Cudd_Not(One) || D == DD_ZERO(dd) || F == Cudd_Not(G)) return(0);
+    if (D == True || F == G) return(1);
+    if (D == Cudd_Not(True) || D == DD_FALSE(dd) || F == Cudd_Not(G)) return(0);
 
     /* From now on, D is non-constant. */
 
@@ -549,7 +564,7 @@
 
     /* Check cache. */
     tmp = cuddCacheLookup(dd,DD_EQUIV_DC_TAG,F,G,D);
-    if (tmp != NULL) return(tmp == One);
+    if (tmp != NULL) return(tmp == True);
 
     /* Find splitting variable. */
     flevel = cuddI(dd,F->index);
@@ -593,7 +608,7 @@
     if (res != 0) {
 	res = Cudd_EquivDC(dd,Fvn,Gvn,Dvn);
     }
-    cuddCacheInsert(dd,DD_EQUIV_DC_TAG,F,G,D,(res) ? One : Cudd_Not(One));
+    cuddCacheInsert(dd,DD_EQUIV_DC_TAG,F,G,D,(res) ? True : Cudd_Not(True));
 
     return(res);
 
@@ -602,10 +617,10 @@
 
 /**Function********************************************************************
 
-  Synopsis    [Tells whether f is less than of equal to G unless D is 1.]
+  Synopsis    [Tells whether f is less than of equal to G unless D is TRUE.]
 
   Description [Tells whether f is less than of equal to G unless D is
-  1.  f, g, and D are BDDs.  The function returns 1 if f is less than
+  TRUE.  f, g, and D are BDDs.  The function returns 1 if f is less than
   of equal to G, and 0 otherwise.  No new nodes are created.]
 
   SideEffects [None]
@@ -620,23 +635,25 @@
   DdNode *g,
   DdNode *D)
 {
-    DdNode *tmp, *One, *F, *G;
+    DdNode *tmp, *True, *F, *G;
     DdNode *Ft, *Fe, *Gt, *Ge, *Dt, *De;
     int res;
     unsigned int flevel, glevel, dlevel, top;
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
 
     statLine(dd);
-
-    One = DD_ONE(dd);
+    True = DD_TRUE(dd);
 
     /* Check terminal cases. */
-    if (f == g || g == One || f == Cudd_Not(One) || D == One ||
+    if (f == g || g == True || f == Cudd_Not(True) || D == True ||
 	D == f || D == Cudd_Not(g)) return(1);
     /* Check for two-operand cases. */
-    if (D == Cudd_Not(One) || D == g || D == Cudd_Not(f))
+    if (D == Cudd_Not(True) || D == g || D == Cudd_Not(f))
 	return(Cudd_bddLeq(dd,f,g));
-    if (g == Cudd_Not(One) || g == Cudd_Not(f)) return(Cudd_bddLeq(dd,f,D));
-    if (f == One) return(Cudd_bddLeq(dd,Cudd_Not(g),D));
+    if (g == Cudd_Not(True) || g == Cudd_Not(f)) return(Cudd_bddLeq(dd,f,D));
+    if (f == True) return(Cudd_bddLeq(dd,Cudd_Not(g),D));
 
     /* From now on, f, g, and D are non-constant, distinct, and
     ** non-complementary. */
@@ -720,7 +737,7 @@
 
     /* Check cache. */
     tmp = cuddCacheLookup(dd,DD_BDD_LEQ_UNLESS_TAG,f,g,D);
-    if (tmp != NULL) return(tmp == One);
+    if (tmp != NULL) return(tmp == True);
 
     /* Find splitting variable. */
     F = Cudd_Regular(f);
@@ -764,13 +781,15 @@
     if (res != 0) {
 	res = Cudd_bddLeqUnless(dd,Fe,Ge,De);
     }
-    cuddCacheInsert(dd,DD_BDD_LEQ_UNLESS_TAG,f,g,D,Cudd_NotCond(One,!res));
+    cuddCacheInsert(dd,DD_BDD_LEQ_UNLESS_TAG,f,g,D,Cudd_NotCond(True,!res));
 
     return(res);
 
 } /* end of Cudd_bddLeqUnless */
 
-
+/* NuSMV: added begin */
+#if 0
+/* NuSMV: added end */
 /**Function********************************************************************
 
   Synopsis    [Compares two ADDs for equality within tolerance.]
@@ -807,20 +826,32 @@
 	} else {
 	    if (pr>0) {
 		(void) fprintf(dd->out,"Offending nodes:\n");
-#if SIZEOF_VOID_P == 8
+#if NUSMV_SIZEOF_VOID_P == 8
 		(void) fprintf(dd->out,
 			       "f: address = %lx\t value = %40.30f\n",
-			       (unsigned long) f, cuddV(f));
+                               /* NuSMV: add begin */
+			       (ptruint) f, cuddV(f));
+                                 /* WAS: (unsigned long) f, cuddV(f)); */
+                               /* NuSMV: add end */
 		(void) fprintf(dd->out,
 			       "g: address = %lx\t value = %40.30f\n",
-			       (unsigned long) g, cuddV(g));
+                               /* NuSMV: add begin */
+			       (ptruint) g, cuddV(g));
+                                  /* WAS:(unsigned long) g, cuddV(g));  */
+                                /* NuSMV: add end */
 #else
 		(void) fprintf(dd->out,
 			       "f: address = %x\t value = %40.30f\n",
-			       (unsigned) f, cuddV(f));
+                               /* NuSMV: add begin */
+			       (ptruint) f, cuddV(f));
+                                 /* WAS: (unsigned) f, cuddV(f)); */
+                               /* NuSMV: add end */
 		(void) fprintf(dd->out,
 			       "g: address = %x\t value = %40.30f\n",
-			       (unsigned) g, cuddV(g));
+                               /* NuSMV: add begin */
+			       (ptruint) g, cuddV(g));
+                                 /* WAS: (unsigned) g, cuddV(g)); */
+                               /* NuSMV: add end */
 #endif
 	    }
 	    return(0);
@@ -844,12 +875,15 @@
     if (!Cudd_EqualSupNorm(dd,fv,gv,tolerance,pr)) return(0);
     if (!Cudd_EqualSupNorm(dd,fvn,gvn,tolerance,pr)) return(0);
 
-    cuddCacheInsert2(dd,(DD_CTFP)Cudd_EqualSupNorm,f,g,DD_ONE(dd));
+    cuddCacheInsert2(dd,(DD_CTFP)Cudd_EqualSupNorm,f,g,DD_TRUE(dd));
 
     return(1);
 
 } /* end of Cudd_EqualSupNorm */
 
+/* NuSMV: added begin */
+#endif
+/* NuSMV: added end */
 
 /**Function********************************************************************
 
@@ -909,7 +943,7 @@
     DdNode *scan;
     DdNode *t, *e;
     DdNode *res = cube;
-    DdNode *zero = Cudd_Not(DD_ONE(dd));
+    DdNode *_false = Cudd_Not(DD_TRUE(dd));
 
     Cudd_Ref(res);
     scan = cube;
@@ -928,9 +962,9 @@
 	    Cudd_RecursiveDeref(dd,expanded);
 	}
 	cuddGetBranches(scan,&t,&e);
-	if (t == zero) {
+	if (t == _false) {
 	    scan = e;
-	} else if (e == zero) {
+	} else if (e == _false) {
 	    scan = t;
 	} else {
 	    Cudd_RecursiveDeref(dd,res);
@@ -938,7 +972,7 @@
 	}
     }
 
-    if (scan == DD_ONE(dd)) {
+    if (scan == DD_TRUE(dd)) {
 	Cudd_Deref(res);
 	return(res);
     } else {
@@ -1027,7 +1061,7 @@
     ** dichotomy of 0 and != 0.
     */
     if (cuddIsConstant(my_root)) {
-	if (my_root != zero) {
+	if (my_root != _false) {
 	    res_pair.pos = 0;
 	    res_pair.neg = DD_BIGGY;
 	} else {
@@ -1110,7 +1144,7 @@
     my_dd = Cudd_Regular(f);
     complement = Cudd_IsComplement(f);
 
-    sol = one;
+    sol = _true;
     cuddRef(sol);
 
     while (!cuddIsConstant(my_dd)) {
@@ -1208,12 +1242,12 @@
     }
 
     /* In the case of a BDD the following test is equivalent to
-    ** testing whether the BDD is the constant 1. This formulation,
+    ** testing whether the BDD is the constant TRUE. This formulation,
     ** however, works for ADDs as well, by assuming the usual
-    ** dichotomy of 0 and != 0.
+    ** dichotomy of FALSE and != FALSE.
     */
     if (cuddIsConstant(my_root)) {
-	if (my_root != zero) {
+	if (my_root != _false) {
 	    res_pair.pos = 0;
 	    res_pair.neg = DD_BIGGY;
 	} else {
@@ -1289,7 +1323,7 @@
     my_dd = Cudd_Regular(f);
     complement = Cudd_IsComplement(f);
 
-    sol = one;
+    sol = _true;
     cuddRef(sol);
 
     while (!cuddIsConstant(my_dd)) {
diff -Nru a/cudd/cuddSign.c b/cudd/cuddSign.c
--- a/cudd/cuddSign.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddSign.c	2024-05-03 15:06:21.838493208 +0200
@@ -76,7 +76,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddSign.c,v 1.21 2005/05/14 17:27:11 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddSign.c,v 1.1.2.1 2010-02-04 10:41:15 nusmv Exp $";
 #endif
 
 static int    size;
@@ -260,7 +260,7 @@
     }
 
     if (cuddIsConstant(N)) {
-	if (node == DD_ZERO(dd) || node == Cudd_Not(DD_ONE(dd))) {
+	if (node == DD_FALSE(dd) || node == Cudd_Not(DD_TRUE(dd))) {
 	    values[0] = 0.0;
 	} else {
 	    values[0] = 1.0;
diff -Nru a/cudd/cuddSolve.c b/cudd/cuddSolve.c
--- a/cudd/cuddSolve.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddSolve.c	2024-05-03 15:06:21.838493208 +0200
@@ -78,7 +78,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddSolve.c,v 1.12 2004/08/13 18:04:51 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddSolve.c,v 1.1.2.1 2010-02-04 10:41:15 nusmv Exp $";
 #endif
 
 /*---------------------------------------------------------------------------*/
@@ -212,19 +212,39 @@
   int * yIndex /* array holding the y variable indices */,
   int  i /* level of recursion */)
 {
+    /* NuSMV: add begin */
+#if 0
+    /* NuSMV: add end */
     DdNode *Fn, *Fm1, *Fv, *Fvbar, *T, *w, *nextY, *one;
+    /* NuSMV: add begin */
+#endif
+    DdNode *Fn, *Fm1, *Fv, *Fvbar, *T, *w, *nextY, *_true;
+    /* NuSMV: add end */
     DdNodePtr *variables;
 
     int j;
 
     statLine(bdd);
     variables = bdd->vars;
-    one = DD_ONE(bdd);
+    /* NuSMV: add begin */
+#if 0
+    /* NuSMV: add end */
+    one = DD_TRUE(bdd);
 
     /* Base condition. */
     if (Y == one) {
 	return F;
     }
+    /* NuSMV: add begin */
+#endif
+    _true = DD_TRUE(bdd);
+
+    /* Base condition. */
+    if (Y == _true) {
+	return F;
+    }
+    /* NuSMV: add end */
+
 
     /* Cofactor of Y. */
     yIndex[i] = Y->index;
diff -Nru a/cudd/cuddSplit.c b/cudd/cuddSplit.c
--- a/cudd/cuddSplit.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddSplit.c	2024-05-03 15:06:21.838493208 +0200
@@ -129,21 +129,25 @@
   double  m)
 {
     DdNode *result;
-    DdNode *zero, *one;
+    DdNode *_false, *_true;
     double  max, num;
     st_table *mtable;
     int *varSeen;
     int i,index, size;
 
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     size = manager->size;
-    one = DD_ONE(manager);
-    zero = Cudd_Not(one);
+    _true = DD_TRUE(manager);
+    _false = Cudd_Not(_true);
 
     /* Trivial cases. */
     if (m == 0.0) {
-	return(zero);
+	return(_false);
     }
-    if (S == zero) {
+    if (S == _false) {
 	return(NULL);
     }
 
@@ -169,7 +173,7 @@
 	    varSeen[manager->invperm[index]] = 0;
 	}
 
-	if (S == one) {
+	if (S == _true) {
 	    if (m == max) 
 		return(S);
 	    result = selectMintermsFromUniverse(manager,varSeen,m);
@@ -247,15 +251,15 @@
   double  max,
   int  index)
 {
-    DdNode *one, *zero, *N, *Nv;
+    DdNode *_true, *_false, *N, *Nv;
     DdNode *Nnv, *q, *r, *v;
     DdNode *result;
     double *dummy, numT, numE;
     int variable, positive;
   
     statLine(manager);
-    one = DD_ONE(manager);
-    zero = Cudd_Not(one);
+    _true = DD_TRUE(manager);
+    _false = Cudd_Not(_true);
 
     /* If p is constant, extract n minterms from constant 1.  The procedure by
     ** construction guarantees that minterms will not be extracted from
@@ -303,7 +307,7 @@
     if (!Cudd_IsConstant(Nv)) {
 	st_lookup(mtable, Nv, &dummy);
 	numT = *dummy/(2*(1<<index));
-    } else if (Nv == one) {
+    } else if (Nv == _true) {
 	numT = max/(2*(1<<index));
     } else {
 	numT = 0;
@@ -312,13 +316,13 @@
     if (!Cudd_IsConstant(Nnv)) {
 	st_lookup(mtable, Nnv, &dummy);
 	numE = *dummy/(2*(1<<index));
-    } else if (Nnv == one) {
+    } else if (Nnv == _true) {
 	numE = max/(2*(1<<index));
     } else {
 	numE = 0;
     }
 
-    v = cuddUniqueInter(manager,variable,one,zero);
+    v = cuddUniqueInter(manager,variable,_true,_false);
     cuddRef(v);
 
     /* If perfect match. */
@@ -486,7 +490,7 @@
   array is then used to extract the required number of minterms from a constant
   1. The algorithm guarantees that the size of BDD will be utmost \log(n).]
 
-  SideEffects [None]
+  SideEffects [N_true]
 
 ******************************************************************************/
 static DdNode *
@@ -497,13 +501,13 @@
 {
     int numVars;
     int i, size, j;
-     DdNode *one, *zero, *result;
+     DdNode *_true, *_false, *result;
     DdNode **vars;
 
     numVars = 0;
     size = manager->size;
-    one = DD_ONE(manager);
-    zero = Cudd_Not(one);
+    _true = DD_TRUE(manager);
+    _false = Cudd_Not(_true);
 
     /* Count the number of variables not encountered so far in procedure
     ** cuddSplitSetRecur.
@@ -521,7 +525,7 @@
     j = 0;
     for (i = size-1; i >= 0; i--) {
 	if(varSeen[i] == 0) {
-	    vars[j] = cuddUniqueInter(manager,manager->perm[i],one,zero);
+	    vars[j] = cuddUniqueInter(manager,manager->perm[i],_true,_false);
 	    cuddRef(vars[j]);
 	    j++;
 	}
@@ -545,9 +549,9 @@
 
 /**Function********************************************************************
 
-  Synopsis    [Recursive procedure to extract n mintems from constant 1.]
+  Synopsis    [Recursive procedure to extract n mintems from constant TRUE.]
 
-  Description [Recursive procedure to extract n mintems from constant 1.]
+  Description [Recursive procedure to extract n mintems from constant TRUE.]
 
   SideEffects [None]
 
@@ -565,7 +569,7 @@
     double max, max2;
     
     statLine(manager);
-    one = DD_ONE(manager);
+    one = DD_TRUE(manager);
     zero = Cudd_Not(one);
 
     max = pow(2.0, (double)numVars);
@@ -640,7 +644,7 @@
     statLine(manager);
     N = Cudd_Regular(node);
     if (cuddIsConstant(N)) {
-	if (node == DD_ONE(manager)) {
+	if (node == DD_TRUE(manager)) {
 	    return(max);
 	} else {
 	    return(0.0);
diff -Nru a/cudd/cuddSubsetHB.c b/cudd/cuddSubsetHB.c
--- a/cudd/cuddSubsetHB.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddSubsetHB.c	2024-05-03 15:06:21.838493208 +0200
@@ -68,7 +68,7 @@
 
 ******************************************************************************/
 
-#ifdef __STDC__
+#if defined(__STDC__) || defined(_MSC_VER)
 #include <float.h>
 #else
 #define DBL_MAX_EXP 1024
@@ -113,7 +113,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddSubsetHB.c,v 1.35 2004/08/13 18:04:51 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddSubsetHB.c,v 1.1.2.1 2010-02-04 10:41:15 nusmv Exp $";
 #endif
 
 static int memOut;
@@ -260,15 +260,15 @@
 {
     DdNode *subset, *g;
 
-    g = Cudd_Not(f);    
+    g = Cudd_Not(f);
     memOut = 0;
     do {
 	dd->reordered = 0;
 	subset = cuddSubsetHeavyBranch(dd, g, numVars, threshold);
     } while ((dd->reordered == 1) && (!memOut));
-    
+
     return(Cudd_NotCond(subset, (subset != NULL)));
-    
+
 } /* end of Cudd_SupersetHeavyBranch */
 
 
@@ -313,7 +313,7 @@
     st_table *storeTable, *approxTable;
     char *key, *value;
     st_generator *stGen;
-    
+
     if (f == NULL) {
 	fprintf(dd->err, "Cannot subset, nil object\n");
 	dd->errorCode = CUDD_INVALID_ARG;
@@ -519,7 +519,7 @@
   counts.  The procedure  moves the counter to the next page when the
   end of the page is reached and allocates new pages when necessary.]
 
-  SideEffects [Changes the size of minterm pages, page, page index, maximum 
+  SideEffects [Changes the size of minterm pages, page, page index, maximum
   number of pages freeing stuff in case of memory out. ]
 
   SeeAlso     []
@@ -711,7 +711,7 @@
 	/* store the cofactors */
 	Nv = Cudd_T(N);
 	Nnv = Cudd_E(N);
-	
+
 	Nv = Cudd_NotCond(Nv, Cudd_IsComplement(node));
 	Nnv = Cudd_NotCond(Nnv, Cudd_IsComplement(node));
 
@@ -891,7 +891,7 @@
     N  = Cudd_Regular(node);
     Nv = Cudd_T(N);
     Nnv = Cudd_E(N);
-    
+
     Nv = Cudd_NotCond(Nv, Cudd_IsComplement(node));
     Nnv = Cudd_NotCond(Nnv, Cudd_IsComplement(node));
 
@@ -1136,7 +1136,7 @@
 
 /**Function********************************************************************
 
-  Synopsis    [Builds the subset BDD using the heavy branch method.] 
+  Synopsis    [Builds the subset BDD using the heavy branch method.]
 
   Description [The procedure carries out the building of the subset BDD
   starting at the root. Using the three different counts labelling each node,
@@ -1263,7 +1263,7 @@
 	    cuddRef(ElseBranch);
 	  }
 	}
-	
+
     }
     else {
         /* recur with the Else branch */
@@ -1303,7 +1303,7 @@
     Cudd_RecursiveDeref(dd, ThenBranch);
     Cudd_RecursiveDeref(dd, ElseBranch);
 
-      
+
     if (neW == NULL)
 	return(NULL);
     else {
@@ -1325,4 +1325,3 @@
         return(neW);
     }
 } /* end of BuildSubsetBdd */
-
diff -Nru a/cudd/cuddSubsetSP.c b/cudd/cuddSubsetSP.c
--- a/cudd/cuddSubsetSP.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddSubsetSP.c	2024-05-03 15:06:21.838493208 +0200
@@ -122,7 +122,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddSubsetSP.c,v 1.32 2004/08/13 18:04:51 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddSubsetSP.c,v 1.1.2.1 2010-02-04 10:41:16 nusmv Exp $";
 #endif
 
 #ifdef DD_DEBUG
@@ -326,7 +326,7 @@
     struct AssortedInfo *info;
     st_table *subsetNodeTable;
 
-    one = DD_ONE(dd);
+    one = DD_TRUE(dd);
     zero = Cudd_Not(one);
 
     if (numVars == 0) {
@@ -1265,6 +1265,12 @@
     int tiebreakChild;
     int  processingDone, thenDone, elseDone;
 
+    /* NuSMV: add begin */
+    NvPathLength = 0;
+    NnvPathLength = 0;
+    regNv = (DdNode*) NULL;
+    regNnv = (DdNode*) NULL;
+    /* NuSMV: add end */
 
 #ifdef DD_DEBUG
     numCalls++;
@@ -1326,7 +1332,7 @@
     /* if then child constant, branch is the child */
     if (Cudd_IsConstant(Nv)) {
 	/*shortest path found */
-	if ((Nv == DD_ONE(dd)) && (info->findShortestPath)) {
+	if ((Nv == DD_TRUE(dd)) && (info->findShortestPath)) {
 	    info->findShortestPath = 0;
 	}
 
@@ -1370,7 +1376,7 @@
     /* if else child constant, branch is the child */
     if (Cudd_IsConstant(Nnv)) {
 	/*shortest path found */
-	if ((Nnv == DD_ONE(dd)) && (info->findShortestPath)) {
+	if ((Nnv == DD_TRUE(dd)) && (info->findShortestPath)) {
 	    info->findShortestPath = 0;
 	}
 
diff -Nru a/cudd/cuddSymmetry.c b/cudd/cuddSymmetry.c
--- a/cudd/cuddSymmetry.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddSymmetry.c	2024-05-03 15:06:21.838493208 +0200
@@ -87,7 +87,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddSymmetry.c,v 1.25 2004/08/13 18:04:51 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddSymmetry.c,v 1.1.2.1 2010-02-04 10:41:16 nusmv Exp $";
 #endif
 
 static	int	*entry;
@@ -201,7 +201,7 @@
     DdNodePtr *list;
     int slots;
     DdNode *sentinel = &(table->sentinel);
-#ifdef DD_DEBUG
+#if defined(DD_DEBUG) && defined(DD_VERBOSE)
     int xindex;
 #endif
 
@@ -239,7 +239,7 @@
 		    /* If f is an isolated projection function it is
 		    ** allowed to bypass layer y.
 		    */
-		    if (f1 != DD_ONE(table) || f0 != DD_ONE(table) || f->ref != 1)
+		    if (f1 != DD_TRUE(table) || f0 != DD_TRUE(table) || f->ref != 1)
 			return(0); /* f bypasses layer y */
 		}
 		f11 = f10 = f1;
@@ -255,7 +255,7 @@
 		f00 = Cudd_Not(f00);
 	    }
 
-	    if (f1 != DD_ONE(table) || f0 != DD_ONE(table) || f->ref != 1) {
+	    if (f1 != DD_TRUE(table) || f0 != DD_TRUE(table) || f->ref != 1) {
 		xsymmy &= f01 == f10;
 		xsymmyp &= f11 == f00;
 		if ((xsymmy == 0) && (xsymmyp == 0))
@@ -1477,6 +1477,13 @@
     int  xtop,xbot,xsize,ytop,ybot,ysize,newxtop;
     int  swapx,swapy;
 
+    /* NuSMV: add begin */
+    swapy = 0;
+    swapx = 0;
+    size = 0;
+    /* NuSMV: add end */
+
+
 #if DD_DEBUG
     assert(x < y);	/* we assume that x < y */
 #endif
@@ -1555,6 +1562,10 @@
     int i,j;
     int	xtop,xbot,xsize,ytop,ybot,ysize,newxtop;
 
+    /* NuSMV: add begin */
+    size = 0;
+    /* NuSMV: add end */
+
 #if DD_DEBUG
     assert(x < y); /* We assume that x < y */
 #endif
diff -Nru a/cudd/cuddTable.c b/cudd/cuddTable.c
--- a/cudd/cuddTable.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddTable.c	2024-05-03 15:06:21.838493208 +0200
@@ -104,8 +104,8 @@
 
 /* This is a hack for when CUDD_VALUE_TYPE is double */
 typedef union hack {
-    CUDD_VALUE_TYPE value;
-    unsigned int bits[2];
+  CUDD_VALUE_TYPE value;
+  unsigned int bits[2];
 } hack;
 
 /*---------------------------------------------------------------------------*/
@@ -117,7 +117,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddTable.c,v 1.119 2004/08/13 18:04:52 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddTable.c,v 1.1.2.1 2010-02-04 10:41:16 nusmv Exp $";
 #endif
 
 /*---------------------------------------------------------------------------*/
@@ -360,7 +360,14 @@
     cuddT(sentinel) = NULL;
     cuddE(sentinel) = NULL;
     sentinel->next = NULL;
+    /* NuSMV: added begin */
+#if 0
+    /* NuSMV: added end */
     unique->epsilon = DD_EPSILON;
+    /* NuSMV: added begin */
+#endif
+    unique->epsilon = (CUDD_VALUE_TYPE)(-1);
+    /* NuSMV: added end */
     unique->maxGrowth = DD_MAX_REORDER_GROWTH;
     unique->maxGrowthAlt = 2.0 * DD_MAX_REORDER_GROWTH;
     unique->reordCycle = 0;	/* do not use alternate threshold */
@@ -544,7 +551,10 @@
     unique->errorCode = CUDD_NO_ERROR;
 
     /* Initialize statistical counters. */
-    unique->maxmemhard = (unsigned long) ((~ (unsigned long) 0) >> 1);
+    /* NuSMV: add begin */
+    unique->maxmemhard = (ptruint) ((~ (ptruint) 0) >> 1);
+      /* WAS: unique->maxmemhard = (unsigned long) ((~ (unsigned long) 0) >> 1); */
+    /* NuSMV: add end */
     unique->garbageCollections = 0;
     unique->GCTime = 0;
     unique->reordTime = 0;
@@ -969,7 +979,11 @@
 {
     DdNode	*node;
 
-    if (T == DD_ZERO(zdd))
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
+    if (T == DD_FALSE(zdd))
 	return(E);
     node = cuddUniqueInterZdd(zdd, id, T, E);
     return(node);
@@ -1001,10 +1015,14 @@
   DdNode * h)
 {
     DdNode	*f, *r, *t;
-    DdNode	*zdd_one = DD_ONE(dd);
-    DdNode	*zdd_zero = DD_ZERO(dd);
+    DdNode	*zdd_true = DD_TRUE(dd);
+    DdNode	*zdd_false = DD_FALSE(dd);
 
-    f = cuddUniqueInterZdd(dd, index, zdd_one, zdd_zero);
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
+    f = cuddUniqueInterZdd(dd, index, zdd_true, zdd_false);
     if (f == NULL) {
 	return(NULL);
     }
@@ -1231,8 +1249,8 @@
     DdNode *result;
     DdNode *v;
 
-    v = cuddUniqueInter(unique, index, DD_ONE(unique),
-			Cudd_Not(DD_ONE(unique)));
+    v = cuddUniqueInter(unique, index, DD_TRUE(unique),
+			Cudd_Not(DD_TRUE(unique)));
     if (v == NULL)
 	return(NULL);
     cuddRef(v);
@@ -1390,14 +1408,28 @@
 	}
     }
 
+    /* NuSMV: added begin */
+#if 0
+    /* NuSMV: added end */
     cuddAdjust(value); /* for the case of crippled infinities */
 
     if (ddAbs(value) < unique->epsilon) {
 	value = 0.0;
     }
+    /* NuSMV: Added begin */
+#endif
+    /* NuSMV: Added end */
     split.value = value;
 
+    /* NuSMV: added begin */
+#if NUSMV_SIZEOF_VOID_P == 8
+    /* NuSMV: added end */
     pos = ddHash(split.bits[0], split.bits[1], unique->constants.shift);
+    /* NuSMV: Added begin */
+#else
+    pos = ddHash(split.bits[0], split.bits[0], unique->constants.shift);
+#endif
+    /* NuSMV: Added end */
     nodelist = unique->constants.nodelist;
     looking = nodelist[pos];
 
@@ -1407,8 +1439,15 @@
      * every X.
      */
     while (looking != NULL) {
+      /* NuSMV: Added begin */
+#if 0
+      /* NuSMV: Added end */
         if (looking->type.value == value ||
 	ddEqualVal(looking->type.value,value,unique->epsilon)) {
+      /* NuSMV: Added begin */
+#endif
+        if (looking->type.value == value ) {
+      /* NuSMV: Added end */
 	    if (looking->ref == 0) {
 		cuddReclaim(unique,looking);
 	    }
@@ -1585,7 +1624,15 @@
 	    while (node != NULL) {
 		next = node->next;
 		split.value = cuddV(node);
+                /* NuSMV: Added begin */
+#if NUSMV_SIZEOF_VOID_P == 8
+                /* NuSMV: Added end */
 		pos = ddHash(split.bits[0], split.bits[1], shift);
+                /* NuSMV: Added begin */
+#else
+		pos = ddHash(split.bits[0], split.bits[0], shift);
+#endif
+                /* NuSMV: Added end */
 		node->next = nodelist[pos];
 		nodelist[pos] = node;
 		node = next;
@@ -1690,7 +1737,10 @@
     }
     FREE(oldnodelist);
 
-    unique->memused += ((long) slots - (long) oldslots) * sizeof(DdNode *);
+    /* NuSMV: add begin */
+    unique->memused += ((ptrint) slots - (ptrint) oldslots) * sizeof(DdNode *);
+      /* WAS: unique->memused += ((long) slots - (long) oldslots) * sizeof(DdNode *); */
+    /* NuSMV: add end */
     unique->slots += slots - oldslots;
     unique->minDead = (unsigned) (unique->gcFrac * (double) unique->slots);
     unique->cacheSlack = (int)
@@ -1729,6 +1779,10 @@
     int *newperm, *newinvperm, *newmap;
     DdNode *one, *zero;
 
+    /* NuSMV: add begin */
+    newmap = (int*) NULL;
+    /* NuSMV: add end */
+
 #ifdef DD_DEBUG
     assert(n > 0 && level < unique->size);
 #endif
@@ -1950,8 +2004,16 @@
     ** projection functions. We need to temporarily disable reordering,
     ** because we cannot reorder without projection functions in place.
     **/
+  /* NuSMV: add begin */
+#if 0
+  /* NuSMV: add end */
     one = unique->one;
     zero = Cudd_Not(one);
+  /* NuSMV: add begin */
+#endif
+    one = unique->val_true;
+    zero = Cudd_Not(one);
+  /* NuSMV: add end */
 
     reorderSave = unique->autoDyn;
     unique->autoDyn = 0;
@@ -2455,7 +2517,11 @@
     int i,j,reorderSave;
     int numSlots = unique->initSlots;
     int *newperm, *newinvperm, *newmap;
-    DdNode *one, *zero;
+    DdNode *_true, *_false;
+
+    /* NuSMV: add begin */
+    newmap = (int*) NULL;
+    /* NuSMV: add end */
 
     oldsize = unique->size;
     /* Easy case: there is still room in the current table. */
@@ -2629,8 +2695,16 @@
     ** projection functions. We need to temporarily disable reordering,
     ** because we cannot reorder without projection functions in place.
     **/
+  /* NuSMV: add begin */
+#if 0
+  /* NuSMV: add end */
     one = unique->one;
     zero = Cudd_Not(one);
+  /* NuSMV: add begin */
+#endif
+    _true = unique->val_true;
+    _false = Cudd_Not(_true);
+  /* NuSMV: add end */
 
     unique->size = index + 1;
     unique->slots += (index + 1 - oldsize) * numSlots;
@@ -2639,7 +2713,7 @@
     reorderSave = unique->autoDyn;
     unique->autoDyn = 0;
     for (i = oldsize; i <= index; i++) {
-	unique->vars[i] = cuddUniqueInter(unique,i,one,zero);
+	unique->vars[i] = cuddUniqueInter(unique,i,_true,_false);
 	if (unique->vars[i] == NULL) {
 	    unique->autoDyn = reorderSave;
 	    for (j = oldsize; j < i; j++) {
diff -Nru a/cudd/cuddUtil.c b/cudd/cuddUtil.c
--- a/cudd/cuddUtil.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddUtil.c	2024-05-03 15:06:21.838493208 +0200
@@ -138,15 +138,21 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddUtil.c,v 1.78 2005/05/14 17:27:12 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddUtil.c,v 1.1.2.1 2010-02-04 10:41:16 nusmv Exp $";
 #endif
 
-static	DdNode	*background, *zero;
+static	DdNode	*background, *val_false;
 
-static	long cuddRand = 0;
-static	long cuddRand2;
-static	long shuffleSelect;
-static 	long shuffleTable[STAB_SIZE];
+/* NuSMV: add begin */
+static	ptrint cuddRand = 0;
+static	ptrint cuddRand2;
+static	ptrint shuffleSelect;
+static 	ptrint shuffleTable[STAB_SIZE];
+  /* WAS: static long cuddRand = 0;
+          static long cuddRand2;
+          static long shuffleSelect;
+          static long shuffleTable[STAB_SIZE]; */
+/* NuSMV: add end */
 
 /*---------------------------------------------------------------------------*/
 /* Macro declarations                                                        */
@@ -166,21 +172,39 @@
 
 static int dp2 (DdManager *dd, DdNode *f, st_table *t);
 static void ddPrintMintermAux (DdManager *dd, DdNode *node, int *list);
+/* NuSMV: added begin */
+static void ddPrintMintermStringAux (DdManager *dd, DdNode *node, int *list, char *string);
+/* NuSMV: added end */
 static int ddDagInt (DdNode *n);
 static int cuddNodeArrayRecur (DdNode *f, DdNodePtr *table, int index);
 static int cuddEstimateCofactor (DdManager *dd, st_table *table, DdNode * node, int i, int phase, DdNode ** ptr);
 static DdNode * cuddUniqueLookup (DdManager * unique, int  index, DdNode * T, DdNode * E);
 static int cuddEstimateCofactorSimple (DdNode * node, int i);
+/* NuSMV: added begin */
+#if 0
+/* NuSMV: added end */
 static double ddCountMintermAux (DdNode *node, double max, DdHashTable *table);
+/* NuSMV: added begin */
+#endif
+static double ddCountMintermAux (DdNode *node, double max, st_table *table);
+/* NuSMV: added end */
+/* NuSMV: added begin */
+#if 0
+/* NuSMV: added end */
 static int ddEpdCountMintermAux (DdNode *node, EpDouble *max, EpDouble *epd, st_table *table);
+/* NuSMV: added begin */
+#endif
 static double ddCountPathAux (DdNode *node, st_table *table);
-static double ddCountPathsToNonZero (DdNode * N, st_table * table);
+static double ddCountPathsToNonZero (DdManager * manager, DdNode * N, st_table * table);
 static void ddSupportStep (DdNode *f, int *support);
 static void ddClearFlag (DdNode *f);
 static int ddLeavesInt (DdNode *n);
 static int ddPickArbitraryMinterms (DdManager *dd, DdNode *node, int nvars, int nminterms, char **string);
 static int ddPickRepresentativeCube (DdManager *dd, DdNode *node, int nvars, double *weight, char *string);
-static enum st_retval ddEpdFree (char * key, char * value, char * arg);
+
+  /* NuSMV: remove begin */
+  /* static enum st_retval ddEpdFree (char * key, char * value, char * arg); */
+  /* NuSMV: remove end */
 
 /**AutomaticEnd***************************************************************/
 
@@ -199,13 +223,13 @@
 
   Description [Prints a disjoint sum of product cover for the function
   rooted at node. Each product corresponds to a path from node to a
-  leaf node different from the logical zero, and different from the
+  leaf node different from the logical false, and different from the
   background value. Uses the package default output file.  Returns 1
   if successful; 0 otherwise.]
 
   SideEffects [None]
 
-  SeeAlso     [Cudd_PrintDebug Cudd_bddPrintCover]
+  SeeAlso     [Cudd_PrintDebug Cudd_bddPrintCover Cudd_PrintMintermString]
 
 ******************************************************************************/
 int
@@ -216,7 +240,14 @@
     int		i, *list;
 
     background = manager->background;
+    /* NuSMV: add begin */
+#if 0
+    /* NuSMV: add end */
     zero = Cudd_Not(manager->one);
+    /* NuSMV: add begin */
+#endif
+    val_false = Cudd_Not(DD_TRUE(manager));
+    /* NuSMV: add end */
     list = ALLOC(int,manager->size);
     if (list == NULL) {
 	manager->errorCode = CUDD_MEMORY_OUT;
@@ -230,6 +261,67 @@
 } /* end of Cudd_PrintMinterm */
 
 
+/* NuSMV: added begin */
+/**Function********************************************************************
+
+  Synopsis    [Returns a string with a disjoint sum of products.]
+
+  Description [Returns a string with a disjoint sum of product cover for the 
+  function rooted at node. Each product corresponds to a path from node to a
+  leaf node different from the logical false, and different from the
+  background value. Uses the package default output file.  Parameter 'success'
+  is set to 1 if successful; to 0 otherwise.
+  The returned string must be freed by the caller.]
+
+  SideEffects [None]
+
+  SeeAlso     [Cudd_PrintDebug Cudd_bddPrintCover Cudd_PrintMinterm]
+
+******************************************************************************/
+char * Cudd_PrintMintermString(DdManager* manager, DdNode* node, int* success)
+{
+  int i;
+  int* list;
+  char *string;
+  ptruint string_length;
+  double num_paths;
+  num_paths = Cudd_CountPathsToNonZero(manager, node);
+
+  /* The following works only for BDDs and ZDDs. ADDs might have constants
+     which need more than one character. */
+  string_length = (ptruint)(num_paths * (manager->size + 3) + 1);
+  string = ALLOC(char, string_length);
+  if (string == NULL) {
+    manager->errorCode = CUDD_MEMORY_OUT;
+    *success = 0;
+    return(NULL);
+  }
+  background = manager->background;
+  /* NuSMV: add begin */
+#if 0
+  /* NuSMV: add end */
+  zero = Cudd_Not(manager->one);
+  /* NuSMV: add begin */
+#endif
+  val_false = Cudd_Not(DD_TRUE(manager));
+  /* NuSMV: add end */
+  list = ALLOC(int, manager->size);
+  if (list == NULL) {
+    FREE(string);
+    manager->errorCode = CUDD_MEMORY_OUT;
+    *success = 0;
+    return(NULL);
+  }
+  for (i = 0; i < manager->size; i++) list[i] = 2;
+  *string = '\0';
+  ddPrintMintermStringAux(manager, node, list, string);
+  FREE(list);
+  *success = 1;
+  return(string);
+
+} /* end of Cudd_PrintMintermString */
+/* NuSMV: added end */
+
 /**Function********************************************************************
 
   Synopsis    [Prints a sum of prime implicants of a BDD.]
@@ -257,16 +349,19 @@
 #ifdef DD_DEBUG
     DdNode *cover;
 #endif
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
 
     array = ALLOC(int, Cudd_ReadSize(dd));
     if (array == NULL) return(0);
     lb = l;
     cuddRef(lb);
 #ifdef DD_DEBUG
-    cover = Cudd_ReadLogicZero(dd);
+    cover = Cudd_ReadLogicFalse(dd);
     cuddRef(cover);
 #endif
-    while (lb != Cudd_ReadLogicZero(dd)) {
+    while (lb != Cudd_ReadLogicFalse(dd)) {
 	DdNode *implicant, *prime, *tmp;
 	int length;
 	implicant = Cudd_LargestCube(dd,lb,&length);
@@ -356,7 +451,7 @@
   The statistics include the number of nodes, the number of leaves, and
   the number of minterms. (The number of minterms is the number of
   assignments to the variables that cause the function to be different
-  from the logical zero (for BDDs) and from the background value (for
+  from the logical FALSE (for BDDs) and from the background value (for
   ADDs.) The statistics are printed if pr &gt; 0. Specifically:
   <ul>
   <li> pr = 0 : prints nothing
@@ -387,15 +482,19 @@
     double minterms;
     int    retval = 1;
 
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     if (f == NULL) {
 	(void) fprintf(dd->out,": is the NULL DD\n");
 	(void) fflush(dd->out);
 	return(0);
     }
-    azero = DD_ZERO(dd);
-    bzero = Cudd_Not(DD_ONE(dd));
+    azero = DD_FALSE(dd);
+    bzero = Cudd_Not(DD_TRUE(dd));
     if ((f == azero || f == bzero) && pr > 0){
-       (void) fprintf(dd->out,": is the zero DD\n");
+       (void) fprintf(dd->out,": is the FALSE DD\n");
        (void) fflush(dd->out);
        return(1);
     }
@@ -480,6 +579,9 @@
     int	val;
     DdNode *ptr;
     st_table *table;
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
 
     table = st_init_table(st_ptrcmp,st_ptrhash);
     if (table == NULL) return(CUDD_OUT_OF_MEM);
@@ -515,6 +617,9 @@
   int i)
 {
     int	val;	
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
 
     val = cuddEstimateCofactorSimple(Cudd_Regular(node),i);
     ddClearFlag(Cudd_Regular(node));
@@ -543,6 +648,10 @@
 {
     int	i,j;	
 
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     i = 0;
     for (j = 0; j < n; j++) {
 	i += ddDagInt(Cudd_Regular(nodeArray[j]));
@@ -570,6 +679,40 @@
   SeeAlso     [Cudd_PrintDebug Cudd_CountPath]
 
 ******************************************************************************/
+/* NuSMV: added begin */
+double
+Cudd_CountMinterm(
+  DdManager * manager,
+  DdNode * node,
+  int  nvars)
+{
+    double	max;
+    st_table	*table;
+    double	i;	
+
+    background = manager->background;
+    /* NuSMV: add begin */
+#if 0
+    /* NuSMV: add end */
+    zero = Cudd_Not(manager->one);
+    /* NuSMV: add begin */
+#endif
+    val_false = Cudd_Not(DD_TRUE(manager));
+    /* NuSMV: add end */
+    
+    max = pow(2.0,(double)nvars);
+    table = st_init_table(st_ptrcmp,st_ptrhash);
+    if (table == NULL) {
+	return((double)CUDD_OUT_OF_MEM);
+    }
+    i = ddCountMintermAux(node,max,table);
+    st_foreach(table, cuddStCountfree, NULL);
+    st_free_table(table);
+
+    return(i);
+} /* end of Cudd_CountMinterm */
+#if 0
+/* NuSMV: added end */
 double
 Cudd_CountMinterm(
   DdManager * manager,
@@ -582,7 +725,14 @@
     CUDD_VALUE_TYPE epsilon;
 
     background = manager->background;
+    /* NuSMV: add begin */
+#if 0
+    /* NuSMV: add end */
     zero = Cudd_Not(manager->one);
+    /* NuSMV: add begin */
+#endif
+    val_false = Cudd_Not(DD_TRUE(manager));
+    /* NuSMV: add end */
     
     max = pow(2.0,(double)nvars);
     table = cuddHashTableInit(manager,1,2);
@@ -598,6 +748,9 @@
     return(res);
 
 } /* end of Cudd_CountMinterm */
+/* NuSMV: added begin */
+#endif
+/* NuSMV: added end */
 
 
 /**Function********************************************************************
@@ -623,6 +776,10 @@
     st_table	*table;
     double	i;	
 
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     table = st_init_table(st_ptrcmp,st_ptrhash);
     if (table == NULL) {
 	return((double)CUDD_OUT_OF_MEM);
@@ -634,7 +791,9 @@
 
 } /* end of Cudd_CountPath */
 
-
+/* NuSMV: added begin */
+#if 0
+/* NuSMV: added end */
 /**Function********************************************************************
 
   Synopsis    [Counts the number of minterms of a DD with extended precision.]
@@ -660,8 +819,19 @@
     st_table	*table;
     int		status;
 
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     background = manager->background;
+    /* NuSMV: add begin */
+#if 0
+    /* NuSMV: add end */
     zero = Cudd_Not(manager->one);
+    /* NuSMV: add begin */
+#endif
+    val_false = Cudd_Not(DD_TRUE(manager));
+    /* NuSMV: add end */
     
     EpdPow2(nvars, &max);
     table = st_init_table(EpdCmp, st_ptrhash);
@@ -683,6 +853,9 @@
     return(0);
 
 } /* end of Cudd_EpdCountMinterm */
+/* NuSMV: added begin */
+#endif
+/* NuSMV: added end */
 
 
 /**Function********************************************************************
@@ -701,17 +874,22 @@
 ******************************************************************************/
 double
 Cudd_CountPathsToNonZero(
+  DdManager * manager,
   DdNode * node)
 {
 
     st_table	*table;
     double	i;	
 
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     table = st_init_table(st_ptrcmp,st_ptrhash);
     if (table == NULL) {
 	return((double)CUDD_OUT_OF_MEM);
     }
-    i = ddCountPathsToNonZero(node,table);
+    i = ddCountPathsToNonZero(manager, node,table);
     st_foreach(table, cuddStCountfree, NULL);
     st_free_table(table);
     return(i);
@@ -760,7 +938,7 @@
     /* Transform support from array to cube. */
     do {
 	dd->reordered = 0;
-	res = DD_ONE(dd);
+	res = DD_TRUE(dd);
 	cuddRef(res);
 	for (j = size - 1; j >= 0; j--) { /* for each level bottom-up */
 	    i = (j >= dd->size) ? j : dd->invperm[j];
@@ -768,7 +946,15 @@
 	        /* The following call to cuddUniqueInter is guaranteed
 		** not to trigger reordering because the node we look up
 		** already exists. */ 
-		var = cuddUniqueInter(dd,i,dd->one,Cudd_Not(dd->one));
+              /* NuSMV: add begin */
+#if 0
+              /* NuSMV: add end */
+              var = cuddUniqueInter(dd,i,dd->one,Cudd_Not(dd->one));
+              /* NuSMV: add begin */
+#endif
+              var = cuddUniqueInter(dd,i,DD_TRUE(dd),Cudd_Not(DD_TRUE(dd)));
+              /* NuSMV: add end */
+
 		cuddRef(var);
 		tmp = cuddBddAndRecur(dd,res,var);
 		if (tmp == NULL) {
@@ -816,6 +1002,10 @@
     int	i;
     int size;
 
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     /* Allocate and initialize support array for ddSupportStep. */
     size = ddMax(dd->size, dd->sizeZ);
     support = ALLOC(int,size);
@@ -859,6 +1049,10 @@
     int size;
     int count;
 
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     /* Allocate and initialize support array for ddSupportStep. */
     size = ddMax(dd->size, dd->sizeZ);
     support = ALLOC(int,size);
@@ -931,12 +1125,19 @@
     }
 
     /* Transform support from array to cube. */
-    res = DD_ONE(dd);
+    res = DD_TRUE(dd);
     cuddRef(res);
     for (j = size - 1; j >= 0; j--) { /* for each level bottom-up */
 	i = (j >= dd->size) ? j : dd->invperm[j];
 	if (support[i] == 1) {
-	    var = cuddUniqueInter(dd,i,dd->one,Cudd_Not(dd->one));
+              /* NuSMV: add begin */
+#if 0
+              /* NuSMV: add end */
+              var = cuddUniqueInter(dd,i,dd->one,Cudd_Not(dd->one));
+              /* NuSMV: add begin */
+#endif
+              var = cuddUniqueInter(dd,i,DD_TRUE(dd),Cudd_Not(DD_TRUE(dd)));
+              /* NuSMV: add end */
 	    cuddRef(var);
 	    tmp = Cudd_bddAnd(dd,res,var);
 	    if (tmp == NULL) {
@@ -982,6 +1183,10 @@
     int	i;
     int size;
 
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     /* Allocate and initialize support array for ddSupportStep. */
     size = ddMax(dd->size, dd->sizeZ);
     support = ALLOC(int,size);
@@ -1031,6 +1236,10 @@
     int size;
     int count;
 
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     /* Allocate and initialize support array for ddSupportStep. */
     size = ddMax(dd->size, dd->sizeZ);
     support = ALLOC(int,size);
@@ -1116,12 +1325,19 @@
     ddClearFlag(Cudd_Regular(g));
 
     /* Classify variables and create cubes. */
-    *common = *onlyF = *onlyG = DD_ONE(dd);
+    *common = *onlyF = *onlyG = DD_TRUE(dd);
     cuddRef(*common); cuddRef(*onlyF); cuddRef(*onlyG);
     for (j = size - 1; j >= 0; j--) { /* for each level bottom-up */
 	i = (j >= dd->size) ? j : dd->invperm[j];
 	if (supportF[i] == 0 && supportG[i] == 0) continue;
-	var = cuddUniqueInter(dd,i,dd->one,Cudd_Not(dd->one));
+        /* NuSMV: add begin */
+#if 0
+        /* NuSMV: add end */
+        var = cuddUniqueInter(dd,i,dd->one,Cudd_Not(dd->one));
+        /* NuSMV: add begin */
+#endif
+        var = cuddUniqueInter(dd,i,DD_TRUE(dd),Cudd_Not(DD_TRUE(dd)));
+        /* NuSMV: add end */
 	cuddRef(var);
 	if (supportG[i] == 0) {
 	    tmp = Cudd_bddAnd(dd,*onlyF,var);
@@ -1192,6 +1408,10 @@
 {
     int	i;	
 
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     i = ddLeavesInt(Cudd_Regular(node));
     ddClearFlag(Cudd_Regular(node));
     return(i);
@@ -1220,22 +1440,22 @@
   char * string)
 {
     DdNode *N, *T, *E;
-    DdNode *one, *bzero;
+    DdNode *_true, *_false;
     char   dir;
     int    i;
 
     if (string == NULL || node == NULL) return(0);
 
     /* The constant 0 function has no on-set cubes. */
-    one = DD_ONE(ddm);
-    bzero = Cudd_Not(one);
-    if (node == bzero) return(0);
+    _true = DD_TRUE(ddm);
+    _false = Cudd_Not(_true);
+    if (node == _false) return(0);
 
     for (i = 0; i < ddm->size; i++) string[i] = 2;
 
     for (;;) {
 
-	if (node == one) break;
+	if (node == _true) break;
 
 	N = Cudd_Regular(node);
 
@@ -1243,10 +1463,10 @@
 	if (Cudd_IsComplement(node)) {
 	    T = Cudd_Not(T); E = Cudd_Not(E);
 	}
-	if (T == bzero) {
+	if (T == _false) {
 	    string[N->index] = 0;
 	    node = E;
-	} else if (E == bzero) {
+	} else if (E == _false) {
 	    string[N->index] = 1;
 	    node = T;
 	} else {
@@ -1259,6 +1479,72 @@
 
 } /* end of Cudd_bddPickOneCube */
 
+/* NuSMV: added begin */
+/**Function********************************************************************
+
+  Synopsis    [Picks one on-set cube deterministically from the given DD.]
+
+  Description [Picks one on-set cube deterministically from the given DD. The
+  cube is written into an array of characters.  The array must have at
+  least as many entries as there are variables. Returns 1 if
+  successful; 0 otherwise.]
+
+  SideEffects [None]
+
+  SeeAlso     [Cudd_bddPickOneCube Cudd_bddPickOneMinterm Cudd_bddPickOneMintermNR]
+
+******************************************************************************/
+int
+Cudd_bddPickOneCubeNR(
+DdManager *ddm,
+DdNode    *node,
+char      *string)
+{
+    DdNode *N, *T, *E;
+    DdNode *_true, *_false;
+    int    i;
+
+    if (string == NULL || node == NULL) return(0);
+
+    /* The constant FALSE function has no on-set cubes. */
+    _true = DD_TRUE(ddm);
+    _false = Cudd_Not(_true);
+    if (node == _false) return(0);
+
+    for (i = 0; i < ddm->size; i++) string[i] = 2;
+
+    if (node == DD_TRUE(ddm)) return(1);
+
+    for (;;) {
+	N = Cudd_Regular(node);
+
+	T = cuddT(N);
+	E = cuddE(N);
+	if (Cudd_IsComplement(node)) {
+	    T = Cudd_Not(T);
+	    E = Cudd_Not(E);
+	}
+	if (T == _true) {
+	    string[N->index] = 1;
+	    break;
+	} else if (E == _true) {
+	    string[N->index] = 0;
+	    break;
+	} else if (T == _false) {
+	    string[N->index] = 0;
+	    node = E;
+	} else if (E == _false) {
+	    string[N->index] = 1;
+	    node = T;
+	} else {
+	    node = T;
+	    string[N->index] = 1;
+	}
+    }
+    return(1);
+
+} /* end of Cudd_bddPickOneCubeNR */
+/* NuSMV: added end */
 
 /**Function********************************************************************
 
@@ -1327,7 +1613,7 @@
     }
 
     /* Build result BDD. */
-    old = Cudd_ReadOne(dd);
+    old = Cudd_ReadTrue(dd);
     cuddRef(old);
 
     for (i = n-1; i >= 0; i--) {
@@ -1361,6 +1647,105 @@
 
 }  /* end of Cudd_bddPickOneMinterm */
 
+/* NuSMV: added begin */
+/**Function********************************************************************
+
+  Synopsis [Picks one on-set minterm deterministically from the given DD.]
+
+  Description [Picks one on-set minterm deterministically from the
+  given DD. The minterm is in terms of vars. Builds a BDD for the
+  minterm and returns a pointer to it if successful; NULL
+  otherwise. There are two reasons why the procedure may fail: It may
+  run out of memory; or the function f may be the constant 0.]
+
+  SideEffects [None]
+
+  SeeAlso     [Cudd_bddPickOneCube]
+
+******************************************************************************/
+DdNode *
+Cudd_bddPickOneMintermNR(
+DdManager *dd,
+DdNode *f,
+DdNode **vars,
+int n)
+{
+    char *string;
+    int i, size;
+    int *indices;
+    int result;
+    DdNode *zero, *old, *new;
+
+    size = dd->size;
+    string = ALLOC(char, size);
+    if (string == NULL)
+	return(NULL);
+    indices = ALLOC(int,n);
+    if (indices == NULL) {
+	FREE(string);
+	return(NULL);
+    }
+
+    for (i = 0; i < n; i++) {
+        indices[i] = vars[i]->index;
+    }
+
+    result = Cudd_bddPickOneCubeNR(dd,f,string);
+    if (result == 0) {
+	FREE(string);
+	FREE(indices);
+	return(NULL);
+    }
+
+    /*
+      Don't cares always set to 0.
+      A cube is represented as an array of literals, which are integers in
+      {0, 1, 2}; 0 represents a complemented literal, 1 represents an
+      uncomplemented literal, and 2 stands for don't care.
+    */
+    for (i = 0; i < n; i++) {
+      if (string[indices[i]] == 2) {
+        /* For dont care we choose false */
+        string[indices[i]] = 0;
+      }
+    }
+
+    /* Build result BDD. */
+    old = Cudd_ReadTrue(dd);
+    cuddRef(old);
+    zero = Cudd_Not(Cudd_ReadTrue(dd));
+
+    for (i = 0; i < n; i++) {
+	if (string[indices[i]] == 0) {
+	    new = Cudd_bddIte(dd,old,Cudd_Not(vars[i]),zero);
+	} else {
+	    new = Cudd_bddIte(dd,old,vars[i],zero);
+	}
+	if (new == NULL) {
+	    FREE(string);
+	    FREE(indices);
+	    Cudd_RecursiveDeref(dd,old);
+	    return(NULL);
+	}
+	cuddRef(new);
+	Cudd_RecursiveDeref(dd,old);
+	old = new;
+    }
+
+    /* Test. */
+    if (Cudd_bddLeq(dd,old,f)) {
+	cuddDeref(old);
+    } else {
+	Cudd_RecursiveDeref(dd,old);
+	old = NULL;
+    }
+
+    FREE(string);
+    FREE(indices);
+    return(old);
+
+}  /* end of Cudd_bddPickOneMintermNR */
+/* NuSMV: added end */
 
 /**Function********************************************************************
 
@@ -1402,6 +1787,14 @@
     char *saveString;
     int saveFlag, savePoint, isSame;
 
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
+  /* NuSMV: add begin */
+    savePoint = 0;
+  /* NuSMV: add end */
+
     minterms = Cudd_CountMinterm(dd,f,n);
     if ((double)k > minterms) {
 	return(NULL);
@@ -1520,7 +1913,7 @@
 	    }
 	}
 
-	old[i] = Cudd_ReadOne(dd);
+	old[i] = Cudd_ReadTrue(dd);
 	cuddRef(old[i]);
 
 	for (j = 0; j < n; j++) {
@@ -1611,11 +2004,23 @@
     DdNode	*cof;
 
     DdNode	*support;
+
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     support = Cudd_Support(dd,f);
     cuddRef(support);
     Cudd_RecursiveDeref(dd,support);
-
+    /* NuSMV: add begin */
+#if 0
+    /* NuSMV: add end */
     zero = Cudd_Not(dd->one);
+    /* NuSMV: add begin */
+#endif
+    zero = Cudd_Not(DD_TRUE(dd));
+    /* NuSMV: add end */
+
     size = dd->size;
     
     weight = ALLOC(double,size);
@@ -1673,9 +2078,9 @@
 	return(NULL);
     }
 
-    cube = Cudd_ReadOne(dd);
+    cube = Cudd_ReadTrue(dd);
     cuddRef(cube);
-    zero = Cudd_Not(Cudd_ReadOne(dd));
+    zero = Cudd_Not(Cudd_ReadTrue(dd));
     for (i = 0; i < nvars; i++) {
 	if (string[indices[i]] == '0') {
 	    newCube = Cudd_bddIte(dd,cube,Cudd_Not(vars[i]),zero);
@@ -1712,9 +2117,9 @@
 	}
     }
 
-    cube = Cudd_ReadOne(dd);
+    cube = Cudd_ReadTrue(dd);
     cuddRef(cube);
-    zero = Cudd_Not(Cudd_ReadOne(dd));
+    zero = Cudd_Not(Cudd_ReadTrue(dd));
 
     /* Build result BDD. */
     for (i = 0; i < nvars; i++) {
@@ -1756,7 +2161,6 @@
 
 } /* end of Cudd_SubsetWithMaskVars */
 
-
 /**Function********************************************************************
 
   Synopsis    [Finds the first cube of a decision diagram.]
@@ -1809,7 +2213,15 @@
     gen->type = CUDD_GEN_CUBES;
     gen->status = CUDD_GEN_EMPTY;
     gen->gen.cubes.cube = NULL;
+    /* NuSMV: added begin */
+#if 0
+    /* NuSMV: added end */
     gen->gen.cubes.value = DD_ZERO_VAL;
+    /* NuSMV: added begin */
+#endif
+    gen->gen.cubes.value = cuddV(DD_FALSE(dd));
+    /* NuSMV: added end */
+
     gen->stack.sp = 0;
     gen->stack.stack = NULL;
     gen->node = NULL;
@@ -1848,7 +2260,7 @@
 	    next = cuddE(treg);
 	    if (top != treg) next = Cudd_Not(next);
 	    gen->stack.stack[gen->stack.sp] = next; gen->stack.sp++;
-	} else if (top == Cudd_Not(DD_ONE(dd)) || top == dd->background) {
+	} else if (top == Cudd_Not(DD_TRUE(dd)) || top == dd->background) {
 	    /* Backtrack */
 	    while (1) {
 		if (gen->stack.sp == 1) {
@@ -1944,7 +2356,7 @@
 	    next = cuddE(treg);
 	    if (top != treg) next = Cudd_Not(next);
 	    gen->stack.stack[gen->stack.sp] = next; gen->stack.sp++;
-	} else if (top == Cudd_Not(DD_ONE(dd)) || top == dd->background) {
+	} else if (top == Cudd_Not(DD_TRUE(dd)) || top == dd->background) {
 	    /* Backtrack */
 	    while (1) {
 		if (gen->stack.sp == 1) {
@@ -2024,6 +2436,10 @@
     DdNode *implicant, *prime, *tmp;
     int length, result;
 
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     /* Sanity Check. */
     if (dd == NULL || l == NULL || u == NULL) return(NULL);
 
@@ -2051,7 +2467,7 @@
 	return(NULL);
     }
 
-    if (gen->node == Cudd_ReadLogicZero(dd)) {
+    if (gen->node == Cudd_ReadLogicFalse(dd)) {
 	gen->status = CUDD_GEN_EMPTY;
     } else {
 	implicant = Cudd_LargestCube(dd,gen->node,&length);
@@ -2124,7 +2540,11 @@
     DdManager *dd = gen->manager;
     int length, result;
 
-    if (gen->node == Cudd_ReadLogicZero(dd)) {
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
+    if (gen->node == Cudd_ReadLogicFalse(dd)) {
 	gen->status = CUDD_GEN_EMPTY;
     } else {
 	implicant = Cudd_LargestCube(dd,gen->node,&length);
@@ -2192,7 +2612,11 @@
     DdNode 	*fn;
     int         i;
 
-    cube = DD_ONE(dd);
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
+    cube = DD_TRUE(dd);
     cuddRef(cube);
 
     for (i = n - 1; i >= 0; i--) {
@@ -2242,9 +2666,13 @@
     DdNode 	*fn;
     int         i;
 
-    cube = DD_ONE(dd);
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
+    cube = DD_TRUE(dd);
     cuddRef(cube);
-    zero = DD_ZERO(dd);
+    zero = DD_FALSE(dd);
 
     for (i = n - 1; i >= 0; i--) {
 	if (phase == NULL || phase[i] != 0) {
@@ -2292,7 +2720,11 @@
     int i;
     int size = Cudd_ReadSize(dd);
 
-    cube = DD_ONE(dd);
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
+    cube = DD_TRUE(dd);
     cuddRef(cube);
     for (i = size - 1; i >= 0; i--) {
 	if ((array[i] & ~1) == 0) {
@@ -2312,7 +2744,6 @@
 
 } /* end of Cudd_CubeArrayToBdd */
 
-
 /**Function********************************************************************
 
   Synopsis    [Builds a positional array from the BDD of a cube.]
@@ -2340,7 +2771,11 @@
     DdNode *scan, *t, *e;
     int i;
     int size = Cudd_ReadSize(dd);
-    DdNode *zero = Cudd_Not(DD_ONE(dd));
+    DdNode *zero = Cudd_Not(DD_TRUE(dd));
+
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
 
     for (i = size-1; i >= 0; i--) {
 	array[i] = 2;
@@ -2547,7 +2982,7 @@
     DdNode *cube, *tmp;
     int i;
 
-    cube = DD_ONE(dd);
+    cube = DD_TRUE(dd);
     cuddRef(cube);
     for (i = n - 1; i >= 0; i--) {
 	tmp = Cudd_bddAnd(dd,Cudd_bddIthVar(dd,array[i]),cube);
@@ -2608,7 +3043,10 @@
     double temeasured, nextmeasured;
     int i, j;
     int slots, nvars;
-    long diff;
+    /* NuSMV: add begin */
+    ptrint diff;
+      /* WAS: long diff; */
+    /* NuSMV: add end */
     DdNode *scan;
     DdNodePtr *nodelist;
     DdNode *sentinel = &(dd->sentinel);
@@ -2631,13 +3069,22 @@
 	for (j = 0; j < slots; j++) {
 	    scan = nodelist[j];
 	    while (scan != sentinel) {
-		diff = (long) scan - (long) cuddT(scan);
+              /* NuSMV: add begin */
+		diff = (ptrint) scan - (ptrint) cuddT(scan);
+                  /* WAS: diff = (long) scan - (long) cuddT(scan); */
+                /* NuSMV: add end */
 		tesubtotal += (double) ddAbs(diff);
-		diff = (long) scan - (long) Cudd_Regular(cuddE(scan));
+                /* NuSMV: add begin */
+		diff = (ptrint) scan - (ptrint) Cudd_Regular(cuddE(scan));
+                  /* WAS: diff = (long) scan - (long) Cudd_Regular(cuddE(scan)); */
+                /* NuSMV: add end */
 		tesubtotal += (double) ddAbs(diff);
 		temeasured += 2.0;
 		if (scan->next != NULL) {
-		    diff = (long) scan - (long) scan->next;
+                  /* NuSMV: add begin */
+		    diff = (ptrint) scan - (ptrint) scan->next;
+                      /* WAS: diff = (long) scan - (long) scan->next; */
+                    /* NuSMV: add end */
 		    nextsubtotal += (double) ddAbs(diff);
 		    nextmeasured += 1.0;
 		}
@@ -2656,7 +3103,10 @@
 	scan = nodelist[j];
 	while (scan != NULL) {
 	    if (scan->next != NULL) {
-		diff = (long) scan - (long) scan->next;
+              /* NuSMV: add begin */
+		diff = (ptrint) scan - (ptrint) scan->next;
+                  /* WAS: diff = (long) scan - (long) scan->next; */
+                /* NuSMV: add end */
 		nextsubtotal += (double) ddAbs(diff);
 		nextmeasured += 1.0;
 	    }
@@ -2824,10 +3274,10 @@
 ******************************************************************************/
 void
 Cudd_OutOfMem(
-  long size /* size of the allocation that failed */)
+  size_t size /* size of the allocation that failed */)
 {
     (void) fflush(stdout);
-    (void) fprintf(stderr, "\nunable to allocate %ld bytes\n", size);
+    (void) fprintf(stderr, "\nunable to allocate %" PRIuPTR " bytes\n", size);
     return;
 
 } /* end of Cudd_OutOfMem */
@@ -3017,14 +3467,24 @@
     }
     g = Cudd_Regular(f);
     if (cuddIsConstant(g)) {
-#if SIZEOF_VOID_P == 8
-        (void) fprintf(dd->out,"ID = %c0x%lx\tvalue = %-9g\n", bang(f),
-		(unsigned long) g / (unsigned long) sizeof(DdNode),cuddV(g));
+      /* NuSMV: add begin */
+#if NUSMV_SIZEOF_VOID_P == 8
+      (void) fprintf(dd->out,"ID = %c0x%lx\tvalue = %-9g\n", bang(f),
+                     (ptruint) g / (ptruint) sizeof(DdNode), (double)(ptruint)cuddV(g));
 #else
-        (void) fprintf(dd->out,"ID = %c0x%x\tvalue = %-9g\n", bang(f),
-		(unsigned) g / (unsigned) sizeof(DdNode),cuddV(g));
+      (void) fprintf(dd->out,"ID = %c0x%x\tvalue = %-9g\n", bang(f),
+                     (unsigned) g / (unsigned) sizeof(DdNode), (double)(ptruint)cuddV(g));
 #endif
-	return(1);
+        /* WAS: #if NUSMV_SIZEOF_VOID_P == 8
+                (void) fprintf(dd->out,"ID = %c0x%lx\tvalue = %-9g\n", bang(f),
+		(unsigned long) g / (unsigned long) sizeof(DdNode),cuddV(g));
+                #else
+                (void) fprintf(dd->out,"ID = %c0x%x\tvalue = %-9g\n", bang(f),
+		(unsigned) g / (unsigned) sizeof(DdNode),cuddV(g));
+                #endif */
+      /* NuSMV: add end */
+
+      return(1);
     }
     if (st_is_member(t,(char *) g) == 1) {
         return(1);
@@ -3032,47 +3492,80 @@
     if (st_add_direct(t,(char *) g,NULL) == ST_OUT_OF_MEM)
 	return(0);
 #ifdef DD_STATS
-#if SIZEOF_VOID_P == 8
+    /* NuSMV: add begin */
+#if NUSMV_SIZEOF_VOID_P == 8
     (void) fprintf(dd->out,"ID = %c0x%lx\tindex = %d\tr = %d\t", bang(f),
-		(unsigned long) g / (unsigned long) sizeof(DdNode), g->index, g->ref);
+                   (ptruint) g / (ptruint) sizeof(DdNode), g->index, g->ref);
 #else
     (void) fprintf(dd->out,"ID = %c0x%x\tindex = %d\tr = %d\t", bang(f),
-		(unsigned) g / (unsigned) sizeof(DdNode),g->index,g->ref);
+                   (unsigned) g / (unsigned) sizeof(DdNode),g->index,g->ref);
 #endif
+      /* WAS: #if NUSMV_SIZEOF_VOID_P == 8
+              (void) fprintf(dd->out,"ID = %c0x%lx\tindex = %d\tr = %d\t", bang(f),
+              (unsigned long) g / (unsigned long) sizeof(DdNode), g->index, g->ref);
+              #else
+              (void) fprintf(dd->out,"ID = %c0x%x\tindex = %d\tr = %d\t", bang(f),
+              (unsigned) g / (unsigned) sizeof(DdNode),g->index,g->ref);
+              #endif */
+    /* NuSMV: add end */
 #else
-#if SIZEOF_VOID_P == 8
+#if NUSMV_SIZEOF_VOID_P == 8
+    /* NuSMV: add begin */
     (void) fprintf(dd->out,"ID = %c0x%lx\tindex = %d\t", bang(f),
-		(unsigned long) g / (unsigned long) sizeof(DdNode),g->index);
+		(ptruint) g / (ptruint) sizeof(DdNode),g->index);
 #else
+
     (void) fprintf(dd->out,"ID = %c0x%x\tindex = %d\t", bang(f),
 		(unsigned) g / (unsigned) sizeof(DdNode),g->index);
 #endif
+      /* WAS: #if NUSMV_SIZEOF_VOID_P == 8
+              (void) fprintf(dd->out,"ID = %c0x%lx\tindex = %d\t", bang(f),
+              (unsigned long) g / (unsigned long) sizeof(DdNode),g->index);
+              #else
+              (void) fprintf(dd->out,"ID = %c0x%x\tindex = %d\t", bang(f),
+              (unsigned) g / (unsigned) sizeof(DdNode),g->index);
+              #endif */
+    /* NuSMV: add end */
 #endif
     n = cuddT(g);
     if (cuddIsConstant(n)) {
-        (void) fprintf(dd->out,"T = %-9g\t",cuddV(n));
+      (void) fprintf(dd->out,"T = %-9g\t", (double)(ptruint)cuddV(n));
 	T = 1;
     } else {
-#if SIZEOF_VOID_P == 8
-        (void) fprintf(dd->out,"T = 0x%lx\t",(unsigned long) n / (unsigned long) sizeof(DdNode));
+      /* NuSMV: add begin */
+#if NUSMV_SIZEOF_VOID_P == 8
+      (void) fprintf(dd->out,"T = 0x%lx\t",(ptruint) n / (ptruint) sizeof(DdNode));
 #else
-        (void) fprintf(dd->out,"T = 0x%x\t",(unsigned) n / (unsigned) sizeof(DdNode));
+      (void) fprintf(dd->out,"T = 0x%x\t",(unsigned) n / (unsigned) sizeof(DdNode));
 #endif
-	T = 0;
+       /* WAS: #if NUSMV_SIZEOF_VOID_P == 8
+               (void) fprintf(dd->out,"T = 0x%lx\t",(unsigned long) n / (unsigned long) sizeof(DdNode));
+               #else
+               (void) fprintf(dd->out,"T = 0x%x\t",(unsigned) n / (unsigned) sizeof(DdNode));
+               #endif */
+      /* NuSMV: add end */
+      T = 0;
     }
 
     n = cuddE(g);
     N = Cudd_Regular(n);
     if (cuddIsConstant(N)) {
-        (void) fprintf(dd->out,"E = %c%-9g\n",bang(n),cuddV(N));
+        (void) fprintf(dd->out,"E = %c%-9g\n",bang(n), (double)(ptruint)cuddV(N));
 	E = 1;
     } else {
-#if SIZEOF_VOID_P == 8
-        (void) fprintf(dd->out,"E = %c0x%lx\n", bang(n), (unsigned long) N/(unsigned long) sizeof(DdNode));
+      /* NuSMV: add begin */
+#if NUSMV_SIZEOF_VOID_P == 8
+      (void) fprintf(dd->out,"E = %c0x%lx\n", bang(n), (ptruint) N/(ptruint) sizeof(DdNode));
 #else
-        (void) fprintf(dd->out,"E = %c0x%x\n", bang(n), (unsigned) N/(unsigned) sizeof(DdNode));
+      (void) fprintf(dd->out,"E = %c0x%x\n", bang(n), (unsigned) N/(unsigned) sizeof(DdNode));
 #endif
-	E = 0;
+        /* WAS: #if NUSMV_SIZEOF_VOID_P == 8
+                (void) fprintf(dd->out,"E = %c0x%lx\n", bang(n), (unsigned long) N/(unsigned long) sizeof(DdNode));
+                #else
+                (void) fprintf(dd->out,"E = %c0x%x\n", bang(n), (unsigned) N/(unsigned) sizeof(DdNode));
+                #endif */
+      /* NuSMV: add end */
+      E = 0;
     }
     if (E == 0) {
         if (dp2(dd,N,t) == 0)
@@ -3095,6 +3588,8 @@
 
   SideEffects [None]
 
+  SeeAlso     [ddPrintMintermStringAux]
+
 ******************************************************************************/
 static void
 ddPrintMintermAux(
@@ -3110,16 +3605,25 @@
     if (cuddIsConstant(N)) {
 	/* Terminal case: Print one cube based on the current recursion
 	** path, unless we have reached the background value (ADDs) or
-	** the logical zero (BDDs).
+	** the logical FALSE (BDDs).
 	*/
-	if (node != background && node != zero) {
+	if (node != background && node != val_false) {
 	    for (i = 0; i < dd->size; i++) {
 		v = list[i];
 		if (v == 0) (void) fprintf(dd->out,"0");
 		else if (v == 1) (void) fprintf(dd->out,"1");
 		else (void) fprintf(dd->out,"-");
 	    }
+            /* NuSMV: added begin */
+#if 0
+            /* NuSMV: added end */
 	    (void) fprintf(dd->out," % g\n", cuddV(node));
+            /* NuSMV: added begin */
+#endif
+	    (void) fprintf(dd->out," ");
+            (void) dd->print_fun(dd, dd->out, cuddV(node), dd->env_arg);
+            (void) fprintf(dd->out,"\n");
+            /* NuSMV: added end */
 	}
     } else {
 	Nv  = cuddT(N);
@@ -3140,6 +3644,74 @@
 } /* end of ddPrintMintermAux */
 
 
+/* NuSMV: added begin */
+/**Function********************************************************************
+
+  Synopsis    [Performs the recursive step of Cudd_PrintMintermString.]
+
+  Description []
+
+  SideEffects [None]
+
+  SeeAlso     [ddPrintMintermAux]
+
+******************************************************************************/
+void ddPrintMintermStringAux(DdManager* dd, DdNode* node, int* list,
+                             char* string)
+{
+  DdNode* N;
+  DdNode* Nv;
+  DdNode* Nnv;
+  int i, v;
+
+  DdHalfWord index;
+  char* tmp;
+  char* tmp_base;
+
+  N = Cudd_Regular(node);
+
+  if (cuddIsConstant(N)) {
+    /* Terminal case: Print one cube based on the current recursion
+     * path, unless we have reached the background value (ADDs) or
+     * the logical zero (BDDs).
+     */
+    if (node != background && node != val_false) {
+      for (i = 0; i < dd->size; i++) {
+        v = list[i];
+        if (v == 0) (void) sprintf(string++, "0");
+        else if (v == 1) (void) sprintf(string++, "1");
+        else (void) sprintf(string++, "-");
+      }
+
+      (void) sprintf(string++, " "); 
+      tmp = dd->sprint_fun(dd, cuddV(node), dd->env_arg);
+      tmp_base = tmp;
+      while(((*(string++)) = (*(tmp++)))) ;
+      free(tmp_base);
+      string--;
+      (void) sprintf(string++, "\n");
+    }
+  }
+  else {
+    Nv  = cuddT(N);
+    Nnv = cuddE(N);
+    if (Cudd_IsComplement(node)) {
+      Nv  = Cudd_Not(Nv);
+      Nnv = Cudd_Not(Nnv);
+    }
+    index = N->index;
+    list[index] = 0;
+    ddPrintMintermStringAux(dd, Nnv, list, string);
+    while(*(string)) string++;
+    list[index] = 1;
+    ddPrintMintermStringAux(dd, Nv, list, string);
+    list[index] = 2;
+  }
+  return;
+} /* end of ddPrintMintermStringAux */
+/* NuSMV: added end */
+
+
 /**Function********************************************************************
 
   Synopsis    [Performs the recursive step of Cudd_DagSize.]
@@ -3422,6 +3994,60 @@
   SideEffects [None]
 
 ******************************************************************************/
+/* NuSMV: added begin */
+static double
+ddCountMintermAux(
+  DdNode * node,
+  double  max,
+  st_table * table)
+{
+    DdNode	*N, *Nt, *Ne;
+    double	min, *pmin, minT, minE;
+    double	*dummy;
+
+    N = Cudd_Regular(node);
+
+    if (cuddIsConstant(N)) {
+	if (node == background || node == val_false) {
+	    return(0.0);
+	} else {
+	    return(max);
+	}
+    }
+    if (st_lookup(table, (char *)node, (char**)((char*)&dummy))) {
+	min = *dummy;
+	return(min);
+    }
+
+    Nt = cuddT(N); Ne = cuddE(N);
+    if (Cudd_IsComplement(node)) {
+	Nt = Cudd_Not(Nt); Ne = Cudd_Not(Ne);
+    }
+
+    minT = ddCountMintermAux(Nt, max, table);
+    if (minT == (double)CUDD_OUT_OF_MEM) return((double)CUDD_OUT_OF_MEM);
+    minT *= 0.5;
+    minE = ddCountMintermAux(Ne, max, table);
+    if (minE == (double)CUDD_OUT_OF_MEM) return((double)CUDD_OUT_OF_MEM);
+    minE *= 0.5;
+    min = minT + minE;
+    
+    pmin = ALLOC(double, 1);
+    if (pmin == NULL) {
+	return((double)CUDD_OUT_OF_MEM);
+    }
+
+    *pmin = min;
+
+    if (st_add_direct(table, (char *)node, (char *)pmin) == ST_OUT_OF_MEM) {
+	FREE(pmin);
+	return((double)CUDD_OUT_OF_MEM);
+    }
+    return(min);
+
+} /* end of ddCountMintermAux */
+#if 0
+/* NuSMV: added end */
 static double
 ddCountMintermAux(
   DdNode * node,
@@ -3476,6 +4102,9 @@
     return(min);
 
 } /* end of ddCountMintermAux */
+/* NuSMV: added begin */
+#endif
+/* NuSMV: added end */
 
 
 /**Function********************************************************************
@@ -3537,7 +4166,9 @@
 
 } /* end of ddCountPathAux */
 
-
+/* NuSMV: added begin */
+#if 0
+/* NuSMV: added end */
 /**Function********************************************************************
 
   Synopsis    [Performs the recursive step of Cudd_EpdCountMinterm.]
@@ -3610,6 +4241,9 @@
     return(0);
 
 } /* end of ddEpdCountMintermAux */
+/* NuSMV: added begin */
+#endif
+/* NuSMV: added end */
 
 
 /**Function********************************************************************
@@ -3630,6 +4264,7 @@
 ******************************************************************************/
 static double
 ddCountPathsToNonZero(
+  DdManager * manager,
   DdNode * N,
   st_table * table)
 {
@@ -3640,7 +4275,14 @@
 
     node = Cudd_Regular(N);
     if (cuddIsConstant(node)) {
+      /* NuSMV: added begin */
+#if 0
+      /* NuSMV: added end */
 	return((double) !(Cudd_IsComplement(N) || cuddV(node)==DD_ZERO_VAL));
+      /* NuSMV: added begin */
+#endif
+	return((double) !(Cudd_IsComplement(N) || cuddV(node)==cuddV(DD_FALSE(manager))));
+      /* NuSMV: added end */
     }
     if (st_lookup(table, N, &dummy)) {
 	paths = *dummy;
@@ -3652,9 +4294,9 @@
 	Nt = Cudd_Not(Nt); Ne = Cudd_Not(Ne);
     }
 
-    paths1 = ddCountPathsToNonZero(Nt,table);
+    paths1 = ddCountPathsToNonZero(manager,Nt,table);
     if (paths1 == (double)CUDD_OUT_OF_MEM) return((double)CUDD_OUT_OF_MEM);
-    paths2 = ddCountPathsToNonZero(Ne,table);
+    paths2 = ddCountPathsToNonZero(manager,Ne,table);
     if (paths2 == (double)CUDD_OUT_OF_MEM) return((double)CUDD_OUT_OF_MEM);
     paths = paths1 + paths2;
 
@@ -3794,10 +4436,14 @@
     int    i, t, result;
     double min1, min2;
 
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     if (string == NULL || node == NULL) return(0);
 
     /* The constant 0 function has no on-set cubes. */
-    one = DD_ONE(dd);
+    one = DD_TRUE(dd);
     bzero = Cudd_Not(one);
     if (nminterms == 0 || node == bzero) return(1);
     if (node == one) {
@@ -3853,15 +4499,18 @@
     DdNode *N, *T, *E;
     DdNode *one, *bzero;
 
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     if (string == NULL || node == NULL) return(0);
 
     /* The constant 0 function has no on-set cubes. */
-    one = DD_ONE(dd);
+    one = DD_TRUE(dd);
     bzero = Cudd_Not(one);
     if (node == bzero) return(0);
 
-    if (node == DD_ONE(dd)) return(1);
-
+    if (node == DD_TRUE(dd)) return(1);
     for (;;) {
 	N = Cudd_Regular(node);
 	if (N == one)
@@ -3895,6 +4544,9 @@
 } /* end of ddPickRepresentativeCube */
 
 
+/* NuSMV: added begin */
+#if 0
+/* NuSMV: added end */
 /**Function********************************************************************
 
   Synopsis [Frees the memory used to store the minterm counts recorded
@@ -3919,3 +4571,6 @@
     return(ST_CONTINUE);
 
 } /* end of ddEpdFree */
+/* NuSMV: added begin */
+#endif
+/* NuSMV: added end */
diff -Nru a/cudd/cuddWindow.c b/cudd/cuddWindow.c
--- a/cudd/cuddWindow.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddWindow.c	2024-05-03 15:06:21.838493208 +0200
@@ -81,7 +81,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddWindow.c,v 1.13 2004/08/13 18:04:52 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddWindow.c,v 1.1.2.1 2010-02-04 10:41:16 nusmv Exp $";
 #endif
 
 #ifdef DD_STATS
diff -Nru a/cudd/cuddZddCount.c b/cudd/cuddZddCount.c
--- a/cudd/cuddZddCount.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddZddCount.c	2024-05-03 15:06:21.838493208 +0200
@@ -84,7 +84,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddZddCount.c,v 1.14 2004/08/13 18:04:53 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddZddCount.c,v 1.1.2.1 2010-02-04 10:41:16 nusmv Exp $";
 #endif
 
 /*---------------------------------------------------------------------------*/
@@ -138,8 +138,8 @@
     int		res;
     DdNode	*base, *empty;
 
-    base  = DD_ONE(zdd);
-    empty = DD_ZERO(zdd);
+    base  = DD_TRUE(zdd);
+    empty = DD_FALSE(zdd);
     table = st_init_table(st_ptrcmp, st_ptrhash);
     if (table == NULL) return(CUDD_OUT_OF_MEM);
     res = cuddZddCountStep(P, table, base, empty);
@@ -177,8 +177,8 @@
     double	res;
     DdNode	*base, *empty;
 
-    base  = DD_ONE(zdd);
-    empty = DD_ZERO(zdd);
+    base  = DD_TRUE(zdd);
+    empty = DD_FALSE(zdd);
     table = st_init_table(st_ptrcmp, st_ptrhash);
     if (table == NULL) return((double)CUDD_OUT_OF_MEM);
     res = cuddZddCountDoubleStep(P, table, base, empty);
diff -Nru a/cudd/cuddZddFuncs.c b/cudd/cuddZddFuncs.c
--- a/cudd/cuddZddFuncs.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddZddFuncs.c	2024-05-03 15:06:21.838493208 +0200
@@ -98,7 +98,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddZddFuncs.c,v 1.14 2004/08/13 18:04:53 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddZddFuncs.c,v 1.1.2.1 2010-02-04 10:41:16 nusmv Exp $";
 #endif
 
 /*---------------------------------------------------------------------------*/
@@ -383,11 +383,15 @@
     DdNode	*f0, *f1, *fd, *g0, *g1, *gd;
     DdNode	*R0, *R1, *Rd, *N0, *N1;
     DdNode	*r;
-    DdNode	*one = DD_ONE(dd);
-    DdNode	*zero = DD_ZERO(dd);
+    DdNode	*one = DD_TRUE(dd);
+    DdNode	*zero = DD_FALSE(dd);
     int		flag;
     int		pv, nv;
 
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     statLine(dd);
     if (f == zero || g == zero)
         return(zero);
@@ -620,10 +624,14 @@
     DdNode	*sum1, *sum2;
     DdNode	*f0, *f1, *g0, *g1;
     DdNode	*r;
-    DdNode	*one = DD_ONE(dd);
-    DdNode	*zero = DD_ZERO(dd);
+    DdNode	*one = DD_TRUE(dd);
+    DdNode	*zero = DD_FALSE(dd);
     int		flag;
 
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     statLine(dd);
     if (f == zero || g == zero)
         return(zero);
@@ -760,13 +768,17 @@
   DdNode * g)
 {
     int		v;
-    DdNode	*one = DD_ONE(dd);
-    DdNode	*zero = DD_ZERO(dd);
+    DdNode	*one = DD_TRUE(dd);
+    DdNode	*zero = DD_FALSE(dd);
     DdNode	*f0, *f1, *fd, *g0, *g1, *gd;
     DdNode	*q, *tmp;
     DdNode	*r;
     int		flag;
 
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     statLine(dd);
     if (g == one)
 	return(f);
@@ -921,8 +933,8 @@
   DdNode * g)
 {
     int		v, top_f, top_g, vf, vg;
-    DdNode	*one = DD_ONE(dd);
-    DdNode	*zero = DD_ZERO(dd);
+    DdNode	*one = DD_TRUE(dd);
+    DdNode	*zero = DD_FALSE(dd);
     DdNode	*f0, *f1, *fd, *g0, *g1, *gd;
     DdNode	*q, *tmp;
     DdNode	*r;
@@ -930,6 +942,10 @@
     int		flag;
     int		pv, nv;
 
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     statLine(dd);
     if (g == one)
 	return(f);
@@ -1158,12 +1174,16 @@
   DdNode * g)
 {
     int		v;
-    DdNode	*one = DD_ONE(dd);
-    DdNode	*zero = DD_ZERO(dd);
+    DdNode	*one = DD_TRUE(dd);
+    DdNode	*zero = DD_FALSE(dd);
     DdNode	*f0, *f1, *g0, *g1;
     DdNode	*q, *r, *tmp;
     int		flag;
 
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     statLine(dd);
     if (g == one)
 	return(f);
@@ -1258,12 +1278,16 @@
   DdNode * g)
 {
     int		v;
-    DdNode	*one = DD_ONE(dd);
-    DdNode	*zero = DD_ZERO(dd);
+    DdNode	*one = DD_TRUE(dd);
+    DdNode	*zero = DD_FALSE(dd);
     DdNode	*f0, *f1, *g0, *g1;
     DdNode	*q, *r, *tmp;
     int		flag;
 
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     statLine(dd);
     if (g == one)
 	return(f);
@@ -1362,10 +1386,14 @@
   DdNode ** fd)
 {
     DdNode	*pc, *nc;
-    DdNode	*zero = DD_ZERO(dd);
+    DdNode	*zero = DD_FALSE(dd);
     int		top, hv, ht, pv, nv;
     int		level;
 
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     top = dd->permZ[f->index];
     level = dd->permZ[v];
     hv = level >> 1;
diff -Nru a/cudd/cuddZddGroup.c b/cudd/cuddZddGroup.c
--- a/cudd/cuddZddGroup.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddZddGroup.c	2024-05-03 15:06:21.838493208 +0200
@@ -87,7 +87,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddZddGroup.c,v 1.19 2004/08/13 18:04:53 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddZddGroup.c,v 1.1.2.1 2010-02-04 10:41:16 nusmv Exp $";
 #endif
 
 static	int	*entry;
@@ -436,6 +436,10 @@
     int result;
     unsigned int initialSize;
 
+ /* NuSMV: add begin */
+    upper = 0;
+  /* NuSMV: add end */
+
     zddFindNodeHiLo(table,treenode,&lower,&upper);
     /* If upper == -1 these variables do not exist yet. */
     if (upper == -1)
@@ -1081,6 +1085,12 @@
     int  size;
     int  i,j,xtop,xbot,xsize,ytop,ybot,ysize,newxtop;
     int  swapx,swapy;
+
+  /* NuSMV: add begin */
+    swapy = 0;
+    swapx = 0;
+  /* NuSMV: add end */
+
 #if defined(DD_DEBUG) && defined(DD_VERBOSE)
     int  initialSize,bestSize;
 #endif
diff -Nru a/cudd/cuddZddIsop.c b/cudd/cuddZddIsop.c
--- a/cudd/cuddZddIsop.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddZddIsop.c	2024-05-03 15:06:21.838493208 +0200
@@ -84,7 +84,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddZddIsop.c,v 1.17 2004/08/13 18:04:53 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddZddIsop.c,v 1.1.2.1 2010-02-04 10:41:16 nusmv Exp $";
 #endif
 
 /*---------------------------------------------------------------------------*/
@@ -233,10 +233,10 @@
   DdNode * U,
   DdNode ** zdd_I)
 {
-    DdNode	*one = DD_ONE(dd);
+    DdNode	*one = DD_TRUE(dd);
     DdNode	*zero = Cudd_Not(one);
-    DdNode	*zdd_one = DD_ONE(dd);
-    DdNode	*zdd_zero = DD_ZERO(dd);
+    DdNode	*zdd_one = DD_TRUE(dd);
+    DdNode	*zdd_zero = DD_FALSE(dd);
     int		v, top_l, top_u;
     DdNode	*Lsub0, *Usub0, *Lsub1, *Usub1, *Ld, *Ud;
     DdNode	*Lsuper0, *Usuper0, *Lsuper1, *Usuper1;
@@ -249,6 +249,10 @@
     int		index;
     DD_CTFP	cacheOp;
 
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     statLine(dd);
     if (L == zero) {
 	*zdd_I = zdd_zero;
@@ -573,7 +577,7 @@
   DdNode * L,
   DdNode * U)
 {
-    DdNode	*one = DD_ONE(dd);
+    DdNode	*one = DD_TRUE(dd);
     DdNode	*zero = Cudd_Not(one);
     int		v, top_l, top_u;
     DdNode	*Lsub0, *Usub0, *Lsub1, *Usub1, *Ld, *Ud;
@@ -585,6 +589,10 @@
     DdNode	*r;
     int		index;
 
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     statLine(dd);
     if (L == zero)
     	return(zero);
@@ -803,11 +811,25 @@
     DdNode	*b1, *b0, *bd;
     DdNode	*T, *E;
 
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     statLine(dd);
+    /* NuSMV: add begin */
+#if 0
+    /* NuSMV: add end */
     if (node == dd->one)
 	return(dd->one);
     if (node == dd->zero)
 	return(Cudd_Not(dd->one));
+    /* NuSMV: add begin */
+#endif
+    if (node == DD_TRUE(dd))
+      return DD_TRUE(dd);
+    if (node == DD_FALSE(dd))
+      return(Cudd_Not(DD_TRUE(dd)));
+    /* NuSMV: add end */
 
     /* Check cache */
     neW = cuddCacheLookup1(dd, cuddMakeBddFromZddCover, node);
@@ -839,7 +861,14 @@
     Cudd_Ref(b0);
     Cudd_RecursiveDerefZdd(dd, f1);
     Cudd_RecursiveDerefZdd(dd, f0);
+    /* NuSMV: add begin */
+#if 0
+    /* NuSMV: add end */
     if (fd != dd->zero) {
+    /* NuSMV: add begin */
+#endif
+    if (fd != DD_FALSE(dd)) {
+   /* NuSMV: add end */
 	bd = cuddMakeBddFromZddCover(dd, fd);
 	if (!bd) {
 	    Cudd_RecursiveDerefZdd(dd, fd);
diff -Nru a/cudd/cuddZddLin.c b/cudd/cuddZddLin.c
--- a/cudd/cuddZddLin.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddZddLin.c	2024-05-03 15:06:21.838493208 +0200
@@ -85,7 +85,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddZddLin.c,v 1.14 2004/08/13 18:04:53 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddZddLin.c,v 1.1.2.1 2010-02-04 10:41:16 nusmv Exp $";
 #endif
 
 extern  int	*zdd_entry;
@@ -164,7 +164,14 @@
 #endif
 
     size = table->sizeZ;
+    /* NuSMV: add begin */
+#if 0
+    /* NuSMV: add end */
     empty = table->zero;
+    /* NuSMV: add begin */
+#endif
+    empty = table->val_false;
+    /* NuSMV: add end */
 
     /* Find order in which to sift variables. */
     var = NULL;
diff -Nru a/cudd/cuddZddMisc.c b/cudd/cuddZddMisc.c
--- a/cudd/cuddZddMisc.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddZddMisc.c	2024-05-03 15:06:21.838493208 +0200
@@ -83,7 +83,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddZddMisc.c,v 1.14 2004/08/13 18:04:53 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddZddMisc.c,v 1.1.2.1 2010-02-04 10:41:16 nusmv Exp $";
 #endif
 
 /*---------------------------------------------------------------------------*/
@@ -183,8 +183,15 @@
     int		i, j;
     DdNode 	*z1, *z1_next, *base;
     DdSubtable	*ZSubTable;
-
+    /* NuSMV: add begin */
+#if 0
+    /* NuSMV: add end */
     base = table->one;
+    /* NuSMV: add begin */
+#endif
+    base = DD_TRUE(table);
+    /* NuSMV: add end */
+
     for (i = table->sizeZ - 1; i >= 0; i--) {
 	ZSubTable = &(table->subtableZ[i]);
 	printf("subtable[%d]:\n", i);
@@ -192,9 +199,12 @@
 	    z1 = ZSubTable->nodelist[j];
 	    while (z1 != NIL(DdNode)) {
 		(void) fprintf(table->out,
-#if SIZEOF_VOID_P == 8
+#if NUSMV_SIZEOF_VOID_P == 8
 		    "ID = 0x%lx\tindex = %d\tr = %d\t",
-		    (unsigned long) z1 / (unsigned long) sizeof(DdNode),
+                    /* NuSMV: add begin */
+		    (ptruint) z1 / (ptruint) sizeof(DdNode),
+                      /* WAS: (unsigned long) z1 / (unsigned long) sizeof(DdNode), */
+                    /* NuSMV: add end */
 		    z1->index, z1->ref);
 #else
 		    "ID = 0x%x\tindex = %d\tr = %d\t",
@@ -207,9 +217,12 @@
 			(z1_next == base));
 		}
 		else {
-#if SIZEOF_VOID_P == 8
+#if NUSMV_SIZEOF_VOID_P == 8
 		    (void) fprintf(table->out, "T = 0x%lx\t",
-			(unsigned long) z1_next / (unsigned long) sizeof(DdNode));
+                    /* NuSMV: add begin */
+			(ptruint) z1_next / (ptruint) sizeof(DdNode));
+                      /* WAS: (unsigned long) z1_next / (unsigned long) sizeof(DdNode)); */
+                    /* NuSMV: add end */
 #else
 		    (void) fprintf(table->out, "T = 0x%x\t",
 			(unsigned) z1_next / (unsigned) sizeof(DdNode));
@@ -221,9 +234,12 @@
 			(z1_next == base));
 		}
 		else {
-#if SIZEOF_VOID_P == 8
+#if NUSMV_SIZEOF_VOID_P == 8
 		    (void) fprintf(table->out, "E = 0x%lx\n",
-			(unsigned long) z1_next / (unsigned long) sizeof(DdNode));
+                    /* NuSMV: add begin */
+			(ptruint) z1_next / (ptruint) sizeof(DdNode));
+                      /* WAS: (unsigned long) z1_next / (unsigned long) sizeof(DdNode)); */
+                    /* NuSMV: add end */
 #else
 		    (void) fprintf(table->out, "E = 0x%x\n",
 			(unsigned) z1_next / (unsigned) sizeof(DdNode));
diff -Nru a/cudd/cuddZddPort.c b/cudd/cuddZddPort.c
--- a/cudd/cuddZddPort.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddZddPort.c	2024-05-03 15:06:21.838493208 +0200
@@ -82,7 +82,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddZddPort.c,v 1.13 2004/08/13 18:04:53 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddZddPort.c,v 1.1.2.1 2010-02-04 10:41:16 nusmv Exp $";
 #endif
 
 /*---------------------------------------------------------------------------*/
@@ -201,11 +201,11 @@
 
     statLine(dd);
     /* Terminal cases. */
-    if (B == Cudd_Not(DD_ONE(dd)))
-	return(DD_ZERO(dd));
-    if (B == DD_ONE(dd)) {
+    if (B == Cudd_Not(DD_TRUE(dd)))
+	return(DD_FALSE(dd));
+    if (B == DD_TRUE(dd)) {
 	if (expected >= dd->sizeZ) {
-	    return(DD_ONE(dd));
+	    return(DD_TRUE(dd));
 	} else {
 	    return(dd->univ[expected]);
 	}
@@ -303,20 +303,20 @@
   DdNode * f /* ZDD to be converted */,
   int  depth /* recursion depth */)
 {
-    DdNode *one, *zero, *T, *E, *res, *var;
+    DdNode *_true, *_false, *T, *E, *res, *var;
     unsigned int index;
     unsigned int level;
 
     statLine(dd);
-    one = DD_ONE(dd);
-    zero = DD_ZERO(dd);
-    if (f == zero) return(Cudd_Not(one));
+    _true = DD_TRUE(dd);
+    _false = DD_FALSE(dd);
+    if (f == _false) return(Cudd_Not(_true));
 
-    if (depth == dd->sizeZ) return(one);
+    if (depth == dd->sizeZ) return(_true);
 
     index = dd->invpermZ[depth];
     level = cuddIZ(dd,f->index);
-    var = cuddUniqueInter(dd,index,one,Cudd_Not(one));
+    var = cuddUniqueInter(dd,index,_true,Cudd_Not(_true));
     if (var == NULL) return(NULL);
     cuddRef(var);
 
@@ -327,7 +327,7 @@
 	    return(NULL);
 	}
 	cuddRef(E);
-	res = cuddBddIteRecur(dd,var,Cudd_Not(one),E);
+	res = cuddBddIteRecur(dd,var,Cudd_Not(_true),E);
 	if (res == NULL) {
 	    Cudd_RecursiveDeref(dd,var);
 	    Cudd_RecursiveDeref(dd,E);
diff -Nru a/cudd/cuddZddReord.c b/cudd/cuddZddReord.c
--- a/cudd/cuddZddReord.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddZddReord.c	2024-05-03 15:06:21.838493208 +0200
@@ -98,7 +98,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddZddReord.c,v 1.47 2004/08/13 18:04:53 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddZddReord.c,v 1.1.2.1 2010-02-04 10:41:16 nusmv Exp $";
 #endif
 
 int	*zdd_entry;
@@ -193,7 +193,14 @@
     ** we count it.
     */
     table->reorderings++;
+    /* NuSMV: add begin */
+#if 0
+    /* NuSMV: add end */
     empty = table->zero;
+    /* NuSMV: add begin */
+#endif
+    empty = DD_FALSE(table);
+    /* NuSMV: add end */
 
     localTime = util_cpu_time();
 
@@ -268,7 +275,10 @@
     /* Run hook functions. */
     hook = table->postReorderingHook;
     while (hook != NULL) {
-	int res = (hook->f)(table, "ZDD", (void *)localTime);
+      /* NuSMV: add begin */
+	int res = (hook->f)(table, "ZDD", (void *)(ptruint)localTime);
+        /* WAS: int res = (hook->f)(table, "ZDD", (void *)localTime); */
+      /* NuSMV: add end */
 	if (res == 0) return(0);
 	hook = hook->next;
     }
@@ -303,8 +313,19 @@
 {
 
     int	result;
-
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
+    /* NuSMV: add begin */
+#if 0
+    /* NuSMV: add end */
     empty = table->zero;
+    /* NuSMV: add begin */
+#endif
+    empty = DD_FALSE(table);
+    /* NuSMV: add end */
+
     zddReorderPreprocess(table);
 
     result = zddShuffle(table,permutation);
@@ -356,8 +377,15 @@
     /* We assume that a ratio of 0 is OK. */
     if (table->sizeZ == 0)
 	return(1);
-
+    /* NuSMV: add begin */
+#if 0
+    /* NuSMV: add end */
     empty = table->zero;
+    /* NuSMV: add begin */
+#endif
+    empty = DD_FALSE(table);
+    /* NuSMV: add end */
+
     M = table->sizeZ / table->size;
     /* Check whether the number of ZDD variables is a multiple of the
     ** number of BDD variables.
@@ -494,6 +522,10 @@
     DdNode	*newf1, *newf0, *next;
     DdNodePtr	g, *lastP, *previousP;
 
+ /* NuSMV: add begin */
+    newf1 = (DdNode*) NULL;
+  /* NuSMV: add end */
+
 #ifdef DD_DEBUG
     assert(x < y);
     assert(cuddZddNextHigh(table,x) == y);
@@ -756,6 +788,10 @@
     int modulo;
     int result;
 
+    /* NuSMV: add begin */
+    pivot = 0;
+    /* NuSMV: add end */
+
 #ifdef DD_DEBUG
     /* Sanity check */
     assert(lower >= 0 && upper < table->sizeZ && lower <= upper);
diff -Nru a/cudd/cuddZddSetop.c b/cudd/cuddZddSetop.c
--- a/cudd/cuddZddSetop.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddZddSetop.c	2024-05-03 15:06:21.838493208 +0200
@@ -96,7 +96,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddZddSetop.c,v 1.25 2004/08/13 18:04:54 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddZddSetop.c,v 1.1.2.1 2010-02-04 10:41:16 nusmv Exp $";
 #endif
 
 /*---------------------------------------------------------------------------*/
@@ -265,7 +265,7 @@
   DdNode * Q)
 {
     int		p_top, q_top;
-    DdNode	*empty = DD_ZERO(zdd), *t, *res;
+    DdNode	*empty = DD_FALSE(zdd), *t, *res;
     DdManager	*table = zdd;
 
     statLine(zdd);
@@ -434,7 +434,7 @@
     statLine(dd);
     /* Trivial cases. */
     /* One variable cases. */
-    if (f == (empty = DD_ZERO(dd))) {	/* ITE(0,G,H) = H */
+    if (f == (empty = DD_FALSE(dd))) {	/* ITE(0,G,H) = H */
 	return(h);
     }
     topf = cuddIZ(dd,f->index);
@@ -443,7 +443,7 @@
     v = ddMin(topg,toph);
     top  = ddMin(topf,v);
 
-    tautology = (top == CUDD_MAXINDEX) ? DD_ONE(dd) : dd->univ[top];
+    tautology = (top == CUDD_MAXINDEX) ? DD_TRUE(dd) : dd->univ[top];
     if (f == tautology) {			/* ITE(1,G,H) = G */
     	return(g);
     }
@@ -552,7 +552,7 @@
   DdNode * Q)
 {
     int		p_top, q_top;
-    DdNode	*empty = DD_ZERO(zdd), *t, *e, *res;
+    DdNode	*empty = DD_FALSE(zdd), *t, *e, *res;
     DdManager	*table = zdd;
 
     statLine(zdd);
@@ -641,7 +641,7 @@
   DdNode * Q)
 {
     int		p_top, q_top;
-    DdNode	*empty = DD_ZERO(zdd), *t, *e, *res;
+    DdNode	*empty = DD_FALSE(zdd), *t, *e, *res;
     DdManager	*table = zdd;
 
     statLine(zdd);
@@ -716,7 +716,7 @@
   DdNode * Q)
 {
     int		p_top, q_top;
-    DdNode	*empty = DD_ZERO(zdd), *t, *e, *res;
+    DdNode	*empty = DD_FALSE(zdd), *t, *e, *res;
     DdManager	*table = zdd;
 
     statLine(zdd);
@@ -799,8 +799,8 @@
 {
     int		top_var, level;
     DdNode	*res, *t, *e;
-    DdNode	*base = DD_ONE(zdd);
-    DdNode	*empty = DD_ZERO(zdd);
+    DdNode	*base = DD_TRUE(zdd);
+    DdNode	*empty = DD_FALSE(zdd);
 
     statLine(zdd);
     if (P == empty)
@@ -817,7 +817,7 @@
     level = zdd->permZ[zvar->index];
 
     if (top_var > level) {
-	res = cuddZddGetNode(zdd, zvar->index, P, DD_ZERO(zdd));
+	res = cuddZddGetNode(zdd, zvar->index, P, DD_FALSE(zdd));
 	if (res == NULL) return(NULL);
     } else if (top_var == level) {
 	res = cuddZddGetNode(zdd, zvar->index, cuddE(P), cuddT(P));
@@ -875,8 +875,8 @@
     DdNode	*zvar, *r;
     DdNode	*base, *empty;
 
-    base = DD_ONE(dd);
-    empty = DD_ZERO(dd);
+    base = DD_TRUE(dd);
+    empty = DD_FALSE(dd);
 
     zvar = cuddUniqueInterZdd(dd, var, base, empty);
     if (zvar == NULL) {
@@ -924,8 +924,8 @@
     DdNode	*zvar, *r;
     DdNode	*base, *empty;
 
-    base = DD_ONE(dd);
-    empty = DD_ZERO(dd);
+    base = DD_TRUE(dd);
+    empty = DD_FALSE(dd);
 
     zvar = cuddUniqueInterZdd(dd, var, base, empty);
     if (zvar == NULL) {
@@ -971,7 +971,7 @@
 {
     DdNode	*zvar, *res;
 
-    zvar = cuddUniqueInterZdd(dd, var, DD_ONE(dd), DD_ZERO(dd));
+    zvar = cuddUniqueInterZdd(dd, var, DD_TRUE(dd), DD_FALSE(dd));
     if (zvar == NULL) return(NULL);
     cuddRef(zvar);
 
@@ -1015,7 +1015,7 @@
     DdNode	*empty;
 
     statLine(zdd);
-    empty = DD_ZERO(zdd);
+    empty = DD_FALSE(zdd);
 
     /* Check cache. */
     res = cuddCacheLookup2Zdd(zdd, zdd_subset1_aux, P, zvar);
diff -Nru a/cudd/cuddZddSymm.c b/cudd/cuddZddSymm.c
--- a/cudd/cuddZddSymm.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddZddSymm.c	2024-05-03 15:06:21.838493208 +0200
@@ -89,7 +89,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddZddSymm.c,v 1.29 2004/08/13 18:04:54 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddZddSymm.c,v 1.1.2.1 2010-02-04 10:41:16 nusmv Exp $";
 #endif
 
 extern int   	*zdd_entry;
@@ -204,7 +204,14 @@
     int 	TotalRefCount = 0;
     int 	symm_found;
 
+    /* NuSMV: add begin */
+#if 0
+    /* NuSMV: add end */
     empty = table->zero;
+    /* NuSMV: add begin */
+#endif
+    empty = DD_FALSE(table);
+    /* NuSMV: add end */
 
     yindex = table->invpermZ[y];
     for (i = table->subtableZ[x].slots - 1; i >= 0; i--) {
@@ -1485,6 +1492,11 @@
     int		i, temp, gxtop, gxbot, gybot, yprev;
     int		swapx, swapy;
 
+    /* NuSMV: add begin */
+    swapy = 0;
+    swapx = 0;
+    /* NuSMV: add end */
+
 #ifdef DD_DEBUG
     assert(x < y);	/* we assume that x < y */
 #endif
@@ -1589,6 +1601,10 @@
     int	       size;
     int        i, temp, gxtop, gxbot, gybot, yprev;
 
+    /* NuSMV: add begin */
+    size = 0;
+    /* NuSMV: add end */
+
 #ifdef DD_DEBUG
     assert(x < y);	/* we assume that x < y */
 #endif
diff -Nru a/cudd/cuddZddUtil.c b/cudd/cuddZddUtil.c
--- a/cudd/cuddZddUtil.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/cuddZddUtil.c	2024-05-03 15:06:21.838493208 +0200
@@ -89,7 +89,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddZddUtil.c,v 1.24 2004/08/13 18:04:54 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddZddUtil.c,v 1.1.2.1 2010-02-04 10:41:16 nusmv Exp $";
 #endif
 
 /*---------------------------------------------------------------------------*/
@@ -214,7 +214,7 @@
   int  n,
   int  pr)
 {
-    DdNode	*empty = DD_ZERO(zdd);
+    DdNode	*empty = DD_FALSE(zdd);
     int		nodes;
     double	minterms;
     int		retval = 1;
@@ -278,6 +278,10 @@
     int i;
     int nvars;
 
+    /* NuSMV: begin add */
+    abort(); /* NOT USED BY NUSMV */
+    /* NuSMV: begin end */
+
     /* Sanity Check. */
     if (zdd == NULL || f == NULL) return(NULL);
 
@@ -292,7 +296,16 @@
     gen->type = CUDD_GEN_ZDD_PATHS;
     gen->status = CUDD_GEN_EMPTY;
     gen->gen.cubes.cube = NULL;
+    /* NuSMV: added begin */
+#if 0
+    /* NuSMV: added end */
     gen->gen.cubes.value = DD_ZERO_VAL;
+    /* NuSMV: added begin */
+#endif
+    {
+      gen->gen.cubes.value = cuddV(DD_FALSE(zdd));
+    }
+    /* NuSMV: added end */
     gen->stack.sp = 0;
     gen->stack.stack = NULL;
     gen->node = NULL;
@@ -329,7 +342,7 @@
 	    gen->gen.cubes.cube[Cudd_Regular(top)->index] = 0;
 	    next = cuddE(Cudd_Regular(top));
 	    gen->stack.stack[gen->stack.sp] = Cudd_Not(next); gen->stack.sp++;
-	} else if (Cudd_Regular(top) == DD_ZERO(zdd)) {
+	} else if (Cudd_Regular(top) == DD_FALSE(zdd)) {
 	    /* Backtrack. */
 	    while (1) {
 		if (gen->stack.sp == 1) {
@@ -415,7 +428,7 @@
 	    gen->gen.cubes.cube[Cudd_Regular(top)->index] = 0;
 	    next = cuddE(Cudd_Regular(top));
 	    gen->stack.stack[gen->stack.sp] = Cudd_Not(next); gen->stack.sp++;
-	} else if (Cudd_Regular(top) == DD_ZERO(zdd)) {
+	} else if (Cudd_Regular(top) == DD_FALSE(zdd)) {
 	    /* Backtrack. */
 	    while (1) {
 		if (gen->stack.sp == 1) {
@@ -560,7 +573,10 @@
     int		i, j;
     int		slots;
     DdNodePtr	*nodelist;
-    long	refAddr, diff, mask;
+    /* NuSMV: add begin */
+    ptrint	refAddr, diff, mask;
+      /* WAS: long	refAddr, diff, mask; */
+    /* NuSMV: add end */
 
     /* Build a bit array with the support of f. */
     sorted = ALLOC(int,nvars);
@@ -606,16 +622,25 @@
     */
 
     /* Find the bits that are different. */
-    refAddr = (long) f[0];
+    /* NuSMV: add begin */
+    refAddr = (ptrint) f[0];
+      /* WAS: refAddr = (long) f[0]; */
+    /* NuSMV: add end */
     diff = 0;
     gen = st_init_gen(visited);
     while (st_gen(gen, &scan, NULL)) {
-	diff |= refAddr ^ (long) scan;
+      /* NuSMV: add begin */
+	diff |= refAddr ^ (ptrint) scan;
+          /* WAS: diff |= refAddr ^ (long) scan; */
+        /* NuSMV: add end */
     }
     st_free_gen(gen);
 
     /* Choose the mask. */
-    for (i = 0; (unsigned) i < 8 * sizeof(long); i += 4) {
+    /* NuSMV: add begin */
+    for (i = 0; (unsigned) i < 8 * sizeof(ptrint); i += 4) {
+        /* WAS: for (i = 0; (unsigned) i < 8 * sizeof(long); i += 4) { */
+      /* NuSMV: add end */
 	mask = (1 << i) - 1;
 	if (diff <= mask) break;
     }
@@ -685,9 +710,20 @@
 		scan = nodelist[j];
 		while (scan != NULL) {
 		    if (st_is_member(visited,(char *) scan)) {
-			retval = fprintf(fp,"\"%lx\";\n", (unsigned long)
-					 ((mask & (long) scan) /
+                      /* NuSMV: add begin */
+#if NUSMV_SIZEOF_VOID_P == 8
+			retval = fprintf(fp,"\"%lx\";\n", (ptruint)
+					 ((mask & (ptrint) scan) /
 					  sizeof(DdNode)));
+#else
+			retval = fprintf(fp,"\"%x\";\n", (ptruint)
+                     ((mask & (ptrint) scan) /
+                      sizeof(DdNode)));
+#endif
+                        /* WAS: retval = fprintf(fp,"\"%lx\";\n", (unsigned long)
+					 ((mask & (long) scan) /
+					  sizeof(DdNode))); */
+                      /* NuSMV: add end */
 			if (retval == EOF) goto failure;
 		    }
 		    scan = scan->next;
@@ -708,8 +744,19 @@
 	scan = nodelist[j];
 	while (scan != NULL) {
 	    if (st_is_member(visited,(char *) scan)) {
-		retval = fprintf(fp,"\"%lx\";\n", (unsigned long)
-				 ((mask & (long) scan) / sizeof(DdNode)));
+              /* NuSMV: add begin */
+#if NUSMV_SIZEOF_VOID_P == 8
+	      retval = fprintf(fp,"\"%lx\";\n", (ptruint)
+	                  ((mask & (ptrint) scan) /
+                      sizeof(DdNode)));
+#else
+	      retval = fprintf(fp,"\"%x\";\n", (ptruint)
+                     ((mask & (ptrint) scan) /
+                      sizeof(DdNode)));
+#endif
+                /* WAS: retval = fprintf(fp,"\"%lx\";\n", (unsigned long)
+				 ((mask & (long) scan) / sizeof(DdNode))); */
+              /* NuSMV: add end */
 		if (retval == EOF) goto failure;
 	    }
 	    scan = scan->next;
@@ -727,9 +774,19 @@
 	    retval = fprintf(fp,"\"  %s  \"", onames[i]);
 	}
 	if (retval == EOF) goto failure;
+        /* NuSMV: add begin */
+#if NUSMV_SIZEOF_VOID_P == 8
 	retval = fprintf(fp," -> \"%lx\" [style = solid];\n",
-			 (unsigned long) ((mask & (long) f[i]) /
+			 (ptruint) ((mask & (ptrint) f[i]) /
 					  sizeof(DdNode)));
+#else
+	retval = fprintf(fp," -> \"%x\" [style = solid];\n",
+             (ptruint) ((mask & (ptrint) f[i]) /
+                      sizeof(DdNode)));
+#endif
+          /* WAS: retval = fprintf(fp,"\"%lx\";\n", (unsigned long)
+				 ((mask & (long) scan) / sizeof(DdNode))); */
+        /* NuSMV: add end */
 	if (retval == EOF) goto failure;
     }
 
@@ -742,21 +799,66 @@
 		scan = nodelist[j];
 		while (scan != NULL) {
 		    if (st_is_member(visited,(char *) scan)) {
-			retval = fprintf(fp,
-			    "\"%lx\" -> \"%lx\";\n",
-			    (unsigned long) ((mask & (long) scan) /
-					     sizeof(DdNode)),
-			    (unsigned long) ((mask & (long) cuddT(scan)) /
-					     sizeof(DdNode)));
-			if (retval == EOF) goto failure;
-			retval = fprintf(fp,
+                      /* NuSMV: add begin */
+#if NUSMV_SIZEOF_VOID_P == 8
+		      retval = fprintf(fp,
+                                       "\"%lx\" -> \"%lx\";\n",
+                                       (ptruint) ((mask & (ptrint) scan) /
+                                                  sizeof(DdNode)),
+                                       (ptruint) ((mask & (ptrint) cuddT(scan)) /
+                                                  sizeof(DdNode)));
+#else
+		      retval = fprintf(fp,
+                                       "\"%x\" -> \"%x\";\n",
+                                       (ptruint) ((mask & (ptrint) scan) /
+                                                  sizeof(DdNode)),
+                                       (ptruint) ((mask & (ptrint) cuddT(scan)) /
+                                                  sizeof(DdNode)));
+#endif
+                      /* WAS: retval = fprintf(fp,
+                                  "\"%lx\" -> \"%lx\";\n",
+                                  (unsigned long) ((mask & (long) scan) /
+                                  sizeof(DdNode)),
+                                  (unsigned long) ((mask & (long) cuddT(scan)) /
+                                  sizeof(DdNode)));
+                                  if (retval == EOF) goto failure;
+                                  retval = fprintf(fp,
+                                  "\"%lx\" -> \"%lx\" [style = dashed];\n",
+                                  (unsigned long) ((mask & (long) scan)
+                                  / sizeof(DdNode)),
+                                  (unsigned long) ((mask & (long)
+                                  cuddE(scan)) /
+                                  sizeof(DdNode))); */
+                      /* NuSMV: add end */
+
+		      if (retval == EOF) goto failure;
+                      /* NuSMV: add begin */
+#if NUSMV_SIZEOF_VOID_P == 8
+		      retval = fprintf(fp,
+					 "\"%lx\" -> \"%lx\" [style = dashed];\n",
+					 (ptruint) ((mask & (ptrint) scan)
+							  / sizeof(DdNode)),
+					 (ptruint) ((mask & (ptrint)
+							   cuddE(scan)) /
+							  sizeof(DdNode)));
+#else
+		      retval = fprintf(fp,
+                     "\"%x\" -> \"%x\" [style = dashed];\n",
+                     (ptruint) ((mask & (ptrint) scan)
+                              / sizeof(DdNode)),
+                     (ptruint) ((mask & (ptrint)
+                               cuddE(scan)) /
+                              sizeof(DdNode)));
+#endif
+                        /* WAS: retval = fprintf(fp,
 					 "\"%lx\" -> \"%lx\" [style = dashed];\n",
 					 (unsigned long) ((mask & (long) scan)
 							  / sizeof(DdNode)),
 					 (unsigned long) ((mask & (long)
 							   cuddE(scan)) /
-							  sizeof(DdNode)));
-			if (retval == EOF) goto failure;
+							  sizeof(DdNode))); */
+                      /* NuSMV: add end */
+		      if (retval == EOF) goto failure;
 		    }
 		    scan = scan->next;
 		}
@@ -771,10 +873,23 @@
 	scan = nodelist[j];
 	while (scan != NULL) {
 	    if (st_is_member(visited,(char *) scan)) {
-		retval = fprintf(fp,"\"%lx\" [label = \"%g\"];\n",
+              /* NuSMV: add begin */
+#if NUSMV_SIZEOF_VOID_P == 8
+              retval = fprintf(fp,"\"%lx\" [label = \"%g\"];\n",
+                               (ptruint) ((mask & (ptrint) scan) /
+                                          sizeof(DdNode)),
+                               (double)(ptruint)  cuddV(scan));
+#else
+                 retval = fprintf(fp,"\"%x\" [label = \"%g\"];\n",
+                                  (ptruint) ((mask & (ptrint) scan) /
+                                             sizeof(DdNode)),
+                                  (double) (ptruint) cuddV(scan));
+#endif
+       /* WAS: retval = fprintf(fp,"\"%lx\" [label = \"%g\"];\n",
 				 (unsigned long) ((mask & (long) scan) /
 						  sizeof(DdNode)),
-				 cuddV(scan));
+				 cuddV(scan)); */
+                 /* NuSMV: add end */
 		if (retval == EOF) goto failure;
 	    }
 	    scan = scan->next;
@@ -859,7 +974,7 @@
 {
     DdNode	*n;
     int		T, E;
-    DdNode	*base = DD_ONE(zdd);
+    DdNode	*base = DD_TRUE(zdd);
     
     if (f == NULL)
 	return(0);
@@ -874,9 +989,12 @@
     if (st_insert(t, (char *) f, NULL) == ST_OUT_OF_MEM)
 	return(0);
 
-#if SIZEOF_VOID_P == 8
+#if NUSMV_SIZEOF_VOID_P == 8
     (void) fprintf(zdd->out, "ID = 0x%lx\tindex = %d\tr = %d\t",
-	(unsigned long)f / (unsigned long) sizeof(DdNode), f->index, f->ref);
+    /* NuSMV: add begin */
+	(ptruint)f / (ptruint) sizeof(DdNode), f->index, f->ref);
+      /* WAS: (unsigned long)f / (unsigned long) sizeof(DdNode), f->index, f->ref); */
+    /* NuSMV: add end */
 #else
     (void) fprintf(zdd->out, "ID = 0x%x\tindex = %d\tr = %d\t",
 	(unsigned)f / (unsigned) sizeof(DdNode), f->index, f->ref);
@@ -887,9 +1005,13 @@
         (void) fprintf(zdd->out, "T = %d\t\t", (n == base));
 	T = 1;
     } else {
-#if SIZEOF_VOID_P == 8
-        (void) fprintf(zdd->out, "T = 0x%lx\t", (unsigned long) n /
-		       (unsigned long) sizeof(DdNode));
+#if NUSMV_SIZEOF_VOID_P == 8
+      /* NuSMV: add begin */
+        (void) fprintf(zdd->out, "T = 0x%lx\t", (ptruint) n /
+		       (ptruint) sizeof(DdNode));
+          /* WAS: (void) fprintf(zdd->out, "T = 0x%lx\t", (unsigned long) n /
+		       (unsigned long) sizeof(DdNode)); */
+        /* NuSMV: add end */
 #else
         (void) fprintf(zdd->out, "T = 0x%x\t", (unsigned) n / (unsigned) sizeof(DdNode));
 #endif
@@ -901,9 +1023,13 @@
         (void) fprintf(zdd->out, "E = %d\n", (n == base));
 	E = 1;
     } else {
-#if SIZEOF_VOID_P == 8
-        (void) fprintf(zdd->out, "E = 0x%lx\n", (unsigned long) n /
-		      (unsigned long) sizeof(DdNode));
+#if NUSMV_SIZEOF_VOID_P == 8
+      /* NuSMV: add begin */
+        (void) fprintf(zdd->out, "E = 0x%lx\n", (ptruint) n /
+		      (ptruint) sizeof(DdNode));
+        /* WAS: (void) fprintf(zdd->out, "E = 0x%lx\n", (unsigned long) n /
+		      (unsigned long) sizeof(DdNode)); */
+      /* NuSMV: add end */
 #else
         (void) fprintf(zdd->out, "E = 0x%x\n", (unsigned) n / (unsigned) sizeof(DdNode));
 #endif
@@ -939,7 +1065,7 @@
 {
     DdNode	*Nv, *Nnv;
     int		i, v;
-    DdNode	*base = DD_ONE(zdd);
+    DdNode	*base = DD_TRUE(zdd);
 
     if (Cudd_IsConstant(node)) {
 	if (node == base) {
@@ -1011,7 +1137,7 @@
 {
     DdNode	*Nv, *Nnv;
     int		i, v;
-    DdNode	*base = DD_ONE(zdd);
+    DdNode	*base = DD_TRUE(zdd);
 
     if (Cudd_IsConstant(node)) {
 	if (node == base) {
diff -Nru a/cudd/doc/node4.html b/cudd/doc/node4.html
--- a/cudd/doc/node4.html	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/doc/node4.html	2024-05-03 15:06:21.841826578 +0200
@@ -335,15 +335,15 @@
 When using 64-bit pointers, there is normally no memory advantage from
 using short int's instead of int's in a DdNode. Therefore, increments
 and decrements are not saturating in that case. What option is in
-effect depends on two macros, SIZEOF_VOID_P<A NAME="912"></A>
-and SIZEOF_INT<A NAME="913"></A>, defined in the external
+effect depends on two macros, NUSMV_SIZEOF_VOID_P<A NAME="912"></A>
+and NUSMV_SIZEOF_INT<A NAME="913"></A>, defined in the external
 header<A NAME="914"></A> file (<EM>cudd.h</EM><A NAME="916"></A>). The
 increments and decrements of the reference counts are performed using
 two macros: <A NAME="tex2html138"
   HREF="cuddAllDet.html#cuddSatInc"><EM>cuddSatInc</EM></A><A NAME="1655"></A> and <A NAME="tex2html139"
   HREF="cuddAllDet.html#cuddSatDec"><EM>  cuddSatDec</EM></A><A NAME="1657"></A>, whose definitions depend on
-SIZEOF_VOID_P<A NAME="923"></A> and
-SIZEOF_INT<A NAME="924"></A>.
+NUSMV_SIZEOF_VOID_P<A NAME="923"></A> and
+NUSMV_SIZEOF_INT<A NAME="924"></A>.
 
 <P>
 
diff -Nru a/cudd/doc/node8.html b/cudd/doc/node8.html
--- a/cudd/doc/node8.html	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/doc/node8.html	2024-05-03 15:06:21.841826578 +0200
@@ -753,10 +753,10 @@
 </DL>
 <DT><STRONG>SISDIR</STRONG>
 <DD><A HREF="node3.html#679">Using the CUDD Package</A>
-<DT><STRONG>SIZEOF_INT</STRONG>
+<DT><STRONG>NUSMV_SIZEOF_INT</STRONG>
 <DD><A HREF="node4.html#913">Saturating Increments and Decrements</A>
  | <A HREF="node4.html#924">Saturating Increments and Decrements</A>
-<DT><STRONG>SIZEOF_VOID_P</STRONG>
+<DT><STRONG>NUSMV_SIZEOF_VOID_P</STRONG>
 <DD><A HREF="node4.html#912">Saturating Increments and Decrements</A>
  | <A HREF="node4.html#923">Saturating Increments and Decrements</A>
 <DT><STRONG>statistical counters</STRONG>
diff -Nru a/cudd/Makefile b/cudd/Makefile
--- a/cudd/Makefile	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/Makefile	2024-05-03 15:06:21.835159836 +0200
@@ -1,4 +1,4 @@
-# $Id$
+# $Id: Makefile,v 1.1.2.1 2010-02-04 10:41:15 nusmv Exp $
 #
 #    Cudd - DD package
 #---------------------------
@@ -43,16 +43,16 @@
 
 # files for the package
 P	= cudd
-PSRC	= cuddAPI.c cuddAddAbs.c cuddAddApply.c cuddAddFind.c cuddAddIte.c \
-	  cuddAddInv.c cuddAddNeg.c cuddAddWalsh.c cuddAndAbs.c \
-	  cuddAnneal.c cuddApa.c cuddApprox.c cuddBddAbs.c cuddBddCorr.c \
+PSRC	= cuddAPI.c cuddAddOp.c cuddAddFind.c cuddAddIte.c \
+	  cuddAndAbs.c cuddBddOp.c \
+	  cuddAnneal.c cuddApprox.c cuddBddAbs.c cuddBddCorr.c \
 	  cuddBddIte.c cuddBridge.c cuddCache.c cuddCheck.c cuddClip.c \
 	  cuddCof.c cuddCompose.c cuddDecomp.c cuddEssent.c \
 	  cuddExact.c cuddExport.c cuddGenCof.c cuddGenetic.c \
-	  cuddGroup.c cuddHarwell.c cuddInit.c cuddInteract.c \
+	  cuddGroup.c cuddInit.c cuddInteract.c \
 	  cuddLCache.c cuddLevelQ.c \
-	  cuddLinear.c cuddLiteral.c cuddMatMult.c cuddPriority.c \
-	  cuddRead.c cuddRef.c cuddReorder.c cuddSat.c cuddSign.c \
+	  cuddLinear.c cuddLiteral.c \
+	  cuddRef.c cuddReorder.c cuddSat.c cuddSign.c \
 	  cuddSolve.c cuddSplit.c cuddSubsetHB.c cuddSubsetSP.c cuddSymmetry.c \
 	  cuddTable.c cuddUtil.c cuddWindow.c cuddZddCount.c cuddZddFuncs.c \
 	  cuddZddGroup.c cuddZddIsop.c cuddZddLin.c cuddZddMisc.c \
@@ -121,4 +122,4 @@
 
 distclean: clean
 	rm -f $(TARGET) $(TARGETu) lib*.a lib$(P).b llib-l$(P).ln \
-	*.bak *~ tags .gdb_history *.qv *.qx
+	*.bak *~ tags TAGS .gdb_history *.qv *.qx
diff -Nru a/cudd/testcudd.c b/cudd/testcudd.c
--- a/cudd/testcudd.c	2016-01-20 23:04:27.000000000 +0100
+++ b/cudd/testcudd.c	2024-05-03 15:06:21.845159949 +0200
@@ -65,7 +65,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: testcudd.c,v 1.16 2004/08/13 18:04:54 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: testcudd.c,v 1.1.2.1 2010-02-04 10:41:17 nusmv Exp $";
 #endif
 
 static const char *onames[] = { "C", "M" }; /* names of functions to be dumped */
@@ -106,7 +106,7 @@
     char *dfile;	/* file for DD dump */
     DdNode *dfunc[2];	/* addresses of the functions to be dumped */
     DdManager *dd;	/* pointer to DD manager */
-    DdNode *one;	/* fast access to constant function */
+    DdNode *_true;	/* fast access to constant function */
     DdNode *M;
     DdNode **x;		/* pointers to variables */
     DdNode **y;		/* pointers to variables */
@@ -264,7 +264,7 @@
 
     /* Initialize manager and provide easy reference to terminals. */
     dd = Cudd_Init(nvars,0,nslots,cacheSize,maxMemory);
-    one = DD_ONE(dd);
+    _true = DD_TRUE(dd);
     dd->groupcheck = (Cudd_AggregationType) groupcheck;
     if (autodyn) Cudd_AutodynEnable(dd,CUDD_REORDER_SAME);
 
@@ -301,7 +301,7 @@
 	if (ny > maxny) maxny = ny;
 
 	/* Build cube of negated y's. */
-	ycube = DD_ONE(dd);
+	ycube = DD_TRUE(dd);
 	Cudd_Ref(ycube);
 	for (i = maxny - 1; i >= 0; i--) {
 	    DdNode *tmpp;
@@ -428,7 +428,7 @@
 
 	/* Test Cudd_bddIteConstant and Cudd_bddLeq. */
 	if (!Cudd_bddLeq(dd,shortP,C)) exit(2);
-	if (Cudd_bddIteConstant(dd,Cudd_Not(shortP),one,C) != one) exit(2);
+	if (Cudd_bddIteConstant(dd,Cudd_Not(shortP),_true,C) != _true) exit(2);
 	Cudd_RecursiveDeref(dd, shortP);
 
 	if (profile) {
@@ -705,8 +705,8 @@
     DdNode *walsh1, *walsh2, *wtw;
     DdNode **x, **v, **z;
     int i, retval;
-    DdNode *one = DD_ONE(dd);
-    DdNode *zero = DD_ZERO(dd);
+    DdNode *_true = DD_TRUE(dd);
+    DdNode *_false = DD_FALSE(dd);
 
     if (N > 3) {
 	x = ALLOC(DdNode *,N);
@@ -714,9 +714,9 @@
 	z = ALLOC(DdNode *,N);
 
 	for (i = N-1; i >= 0; i--) {
-	    Cudd_Ref(x[i]=cuddUniqueInter(dd,3*i,one,zero));
-	    Cudd_Ref(v[i]=cuddUniqueInter(dd,3*i+1,one,zero));
-	    Cudd_Ref(z[i]=cuddUniqueInter(dd,3*i+2,one,zero));
+	    Cudd_Ref(x[i]=cuddUniqueInter(dd,3*i,_true,_false));
+	    Cudd_Ref(v[i]=cuddUniqueInter(dd,3*i+1,_true,_false));
+	    Cudd_Ref(z[i]=cuddUniqueInter(dd,3*i+2,_true,_false));
 	}
 	Cudd_Ref(walsh1 = Cudd_addWalsh(dd,v,z,N));
 	if (pr>0) {(void) printf("walsh1"); Cudd_PrintDebug(dd,walsh1,2*N,pr);}
@@ -852,11 +852,17 @@
 	(void) printf("Testing iterator on nodes:\n");
 	Cudd_ForeachNode(dd,M,gen,node) {
 	    if (Cudd_IsConstant(node)) {
-#if SIZEOF_VOID_P == 8
+#if NUSMV_SIZEOF_VOID_P == 8
+              /* NuSMV: add begin */
 		(void) printf("ID = 0x%lx\tvalue = %-9g\n",
+			      (ptruint) node /
+			      (ptruint) sizeof(DdNode),
+			      Cudd_V(node));
+                /* WAS: (void) printf("ID = 0x%lx\tvalue = %-9g\n",
 			      (unsigned long) node /
 			      (unsigned long) sizeof(DdNode),
-			      Cudd_V(node));
+			      Cudd_V(node)); */
+              /* NuSMV: add end */
 #else
 		(void) printf("ID = 0x%x\tvalue = %-9g\n",
 			      (unsigned int) node /
@@ -864,11 +870,17 @@
 			      Cudd_V(node));
 #endif
 	    } else {
-#if SIZEOF_VOID_P == 8
+#if NUSMV_SIZEOF_VOID_P == 8
+              /* NuSMV: add begin */
 		(void) printf("ID = 0x%lx\tindex = %d\tr = %d\n",
+			      (ptruint) node /
+			      (ptruint) sizeof(DdNode),
+			      node->index, node->ref);
+                /* WAS: (void) printf("ID = 0x%lx\tindex = %d\tr = %d\n",
 			      (unsigned long) node /
 			      (unsigned long) sizeof(DdNode),
-			      node->index, node->ref);
+			      node->index, node->ref); */
+              /* NuSMV: add end */
 #else
 		(void) printf("ID = 0x%x\tindex = %d\tr = %d\n",
 			      (unsigned int) node /
@@ -981,7 +993,7 @@
   DdNode *f,
   int pr)
 {
-    DdNode **vars, *minBdd, *zero, *scan;
+    DdNode **vars, *minBdd, *_false, *scan;
     int i;
     int d;
     int *minterm;
@@ -1007,7 +1019,7 @@
 	return(0);
     }
     scan = minBdd;
-    zero = Cudd_Not(DD_ONE(dd));
+    _false = Cudd_Not(DD_TRUE(dd));
     while (!Cudd_IsConstant(scan)) {
 	DdNode *R = Cudd_Regular(scan);
 	DdNode *T = Cudd_T(R);
@@ -1016,7 +1028,7 @@
 	    T = Cudd_Not(T);
 	    E = Cudd_Not(E);
 	}
-	if (T == zero) {
+	if (T == _false) {
 	    minterm[R->index] = 0;
 	    scan = E;
 	} else {
diff -Nru a/dddmp/dddmpLoad.c b/dddmp/dddmpLoad.c
--- a/dddmp/dddmpLoad.c	2016-01-20 23:04:27.000000000 +0100
+++ b/dddmp/dddmpLoad.c	2024-05-03 15:06:21.845159949 +0200
@@ -915,11 +915,11 @@
         if (idT==0 && idE==0) {
           /* leaf node: a constant */
           if (strcmp(buf, "1") == 0) {
-            pnodes[i] = Cudd_ReadOne (ddMgr);       
+            pnodes[i] = Cudd_ReadTrue (ddMgr);       
           } else {
             /* this is an ADD constant ! */
             if (strcmp(buf, "0") == 0) {
-              pnodes[i] = Cudd_ReadZero (ddMgr);       
+              pnodes[i] = Cudd_ReadFalse (ddMgr);       
             } else {
               addConstant = atof(buf);
               pnodes[i] = Cudd_addConst (ddMgr,
@@ -962,7 +962,7 @@
         switch (code.V) {
         case DDDMP_TERMINAL:     
           /* only 1 terminal presently supported */    
-          pnodes[i] = Cudd_ReadOne (ddMgr);       
+          pnodes[i] = Cudd_ReadTrue (ddMgr);       
           continue; 
           break;
         case DDDMP_RELATIVE_1:
diff -Nru a/dddmp/dddmpLoadCnf.c b/dddmp/dddmpLoadCnf.c
--- a/dddmp/dddmpLoadCnf.c	2016-01-20 23:04:27.000000000 +0100
+++ b/dddmp/dddmpLoadCnf.c	2024-05-03 15:06:21.845159949 +0200
@@ -895,15 +895,15 @@
 
   rel = DDDMP_ALLOC (DdNode *, Hdr->nClausesCnf);
 
-  cubeBddVar = Cudd_ReadOne (ddMgr);
-  cubeCnfVar = Cudd_ReadOne (ddMgr);
-  cubeAllVar = Cudd_ReadOne (ddMgr);
+  cubeBddVar = Cudd_ReadTrue (ddMgr);
+  cubeCnfVar = Cudd_ReadTrue (ddMgr);
+  cubeAllVar = Cudd_ReadTrue (ddMgr);
   Cudd_Ref (cubeBddVar);
   Cudd_Ref (cubeCnfVar);
   Cudd_Ref (cubeAllVar);
 
   for (i=0; i<Hdr->nClausesCnf; i++) {
-    rel[i] = Cudd_Not (Cudd_ReadOne (ddMgr));
+    rel[i] = Cudd_Not (Cudd_ReadTrue (ddMgr));
     Cudd_Ref (rel[i]);
     j=0;
     while ((var1 = cnfTable[i][j++]) != 0) {
@@ -975,7 +975,7 @@
       toLine = Hdr->rootids[i+1];
     }
 
-    tmp1 = Cudd_ReadOne (ddMgr);
+    tmp1 = Cudd_ReadTrue (ddMgr);
     Cudd_Ref (tmp1);  
     for (j=fromLine; j<toLine; j++) {
       tmp2 = Cudd_bddAnd (ddMgr, rel[j], tmp1);
@@ -1003,7 +1003,7 @@
    */
 
 #if DDDMP_DEBUG_CNF
-  cubeBddVar = Cudd_ReadOne (ddMgr);
+  cubeBddVar = Cudd_ReadTrue (ddMgr);
   Cudd_Ref (cubeBddVar);
   for (i=0; i<Hdr->nsuppvars; i++) {
     lit = Cudd_bddIthVar (ddMgr, Hdr->ids[i]);
diff -Nru a/dddmp/dddmpStoreAdd.c b/dddmp/dddmpStoreAdd.c
--- a/dddmp/dddmpStoreAdd.c	2016-01-20 23:04:27.000000000 +0100
+++ b/dddmp/dddmpStoreAdd.c	2024-05-03 15:06:21.845159949 +0200
@@ -871,7 +871,7 @@
 
   if (Cudd_IsConstant(f)) {
 
-    if (f == Cudd_ReadOne(ddMgr)) {
+    if (f == Cudd_ReadTrue(ddMgr)) {
       if ((varnames != NULL) || (outids != NULL)) {
         retValue = fprintf (fp, "%d T 1 0 0\n", idf);
       } else {
@@ -885,7 +885,7 @@
       }
     }
 
-    if (f == Cudd_ReadZero(ddMgr)) {
+    if (f == Cudd_ReadFalse(ddMgr)) {
       if ((varnames != NULL) || (outids != NULL)) {
         retValue = fprintf (fp, "%d T 0 0 0\n", idf);
       } else {
diff -Nru a/dddmp/dddmpStoreBdd.c b/dddmp/dddmpStoreBdd.c
--- a/dddmp/dddmpStoreBdd.c	2016-01-20 23:04:27.000000000 +0100
+++ b/dddmp/dddmpStoreBdd.c	2024-05-03 15:06:21.845159949 +0200
@@ -888,7 +888,7 @@
 
   if (Cudd_IsConstant(f)) {
 
-    if (f == Cudd_ReadOne(ddMgr)) {
+    if (f == Cudd_ReadTrue(ddMgr)) {
       if ((varnames != NULL) || (outids != NULL)) {
         retValue = fprintf (fp, "%d T 1 0 0\n", idf);
       } else {
@@ -902,7 +902,7 @@
       }
     }
 
-    if (f == Cudd_ReadZero(ddMgr)) {
+    if (f == Cudd_ReadFalse(ddMgr)) {
       if ((varnames != NULL) || (outids != NULL)) {
         retValue = fprintf (fp, "%d T 0 0 0\n", idf);
       } else {
@@ -1044,7 +1044,7 @@
     } 
   }
 
-  if (T == DD_ONE(ddMgr)) {
+  if (T == DD_TRUE(ddMgr)) {
     code.T = DDDMP_TERMINAL;
   } else {
     /* compute displacement */
@@ -1060,7 +1060,7 @@
     }
   }
 
-  if (E == DD_ONE(ddMgr)) {
+  if (E == DD_TRUE(ddMgr)) {
     code.E = DDDMP_TERMINAL;
   } else {
     /* compute displacement */
diff -Nru a/dddmp/dddmpStoreMisc.c b/dddmp/dddmpStoreMisc.c
--- a/dddmp/dddmpStoreMisc.c	2016-01-20 23:04:27.000000000 +0100
+++ b/dddmp/dddmpStoreMisc.c	2024-05-03 15:06:21.845159949 +0200
@@ -662,17 +662,23 @@
       "Error during file store.", failure);
 
     if (Cudd_IsComplement(f[i])) {
-#if SIZEOF_VOID_P == 8
+#if NUSMV_SIZEOF_VOID_P == 8
       retValue = fprintf (fp, "(NOT node%lx))\n",
-        (unsigned long) f[i] / (unsigned long) sizeof(DdNode));
+                          /* NuSMV: add begin */
+        (ptruint) f[i] / (ptruint) sizeof(DdNode));
+        /* WAS: (unsigned long) f[i] / (unsigned long) sizeof(DdNode)); */
+      /* NuSMV: add end */
 #else
       retValue = fprintf (fp, "(NOT node%x))\n",
         (unsigned) f[i] / (unsigned) sizeof(DdNode));
 #endif
     } else {
-#if SIZEOF_VOID_P == 8
+#if NUSMV_SIZEOF_VOID_P == 8
       retValue = fprintf (fp, "node%lx)\n",
-        (unsigned long) f[i] / (unsigned long) sizeof(DdNode));
+                          /* NuSMV: add begin */
+        (ptruint) f[i] / (ptruint) sizeof(DdNode));
+        /* WAS: (unsigned long) f[i] / (unsigned long) sizeof(DdNode)); */
+      /* NuSMV: add end */
 #else
       retValue = fprintf (fp, "node%x)\n",
         (unsigned) f[i] / (unsigned) sizeof(DdNode));
@@ -750,11 +756,14 @@
   }
 
   /* Check for special case: If constant node, generate constant 1. */
-  if (f == DD_ONE (ddMgr)) {
-#if SIZEOF_VOID_P == 8
+  if (f == DD_TRUE (ddMgr)) {
+#if NUSMV_SIZEOF_VOID_P == 8
     retValue = fprintf (fp,
       "(OR node%lx vss vdd)\n",
-      (unsigned long) f / (unsigned long) sizeof(DdNode));
+                        /* NuSMV: add begin */
+      (ptruint) f / (ptruint) sizeof(DdNode));
+      /* WAS: (unsigned long) f / (unsigned long) sizeof(DdNode)); */
+    /* NuSMV: add end */
 #else
     retValue = fprintf (fp,
       "(OR node%x vss vdd)\n",
@@ -768,15 +777,18 @@
   }
 
   /*
-   *  Check whether this is an ADD. We deal with 0-1 ADDs, but not
+   *  Check whether this is an ADD. We deal with FALSE-TRUE ADDs, but not
    *  with the general case.
    */
 
-  if (f == DD_ZERO(ddMgr)) {
-#if SIZEOF_VOID_P == 8
+  if (f == DD_FALSE(ddMgr)) {
+#if NUSMV_SIZEOF_VOID_P == 8
     retValue = fprintf (fp,
       "(AND node%lx vss vdd)\n",
-       (unsigned long) f / (unsigned long) sizeof(DdNode));
+                        /* NuSMV: add begin */
+       (ptruint) f / (ptruint) sizeof(DdNode));
+      /* WAS: (unsigned long) f / (unsigned long) sizeof(DdNode)); */
+    /* NuSMV: add end */
 #else
     retValue = fprintf (fp,
       "(AND node%x vss vdd)\n",
@@ -806,9 +818,12 @@
   }
 
   /* Write multiplexer taking complement arc into account. */
-#if SIZEOF_VOID_P == 8
+#if NUSMV_SIZEOF_VOID_P == 8
   retValue = fprintf (fp, "(OR node%lx (AND ",
-    (unsigned long) f / (unsigned long) sizeof(DdNode));
+                      /* NuSMV: add begin */
+    (ptruint) f / (ptruint) sizeof(DdNode));
+    /* WAS: (unsigned long) f / (unsigned long) sizeof(DdNode)); */
+  /* NuSMV: add end */
 #else
   retValue = fprintf (fp, "(OR node%x (AND ",
     (unsigned) f / (unsigned) sizeof(DdNode));
@@ -826,9 +841,12 @@
     return(0);
   }
 
-#if SIZEOF_VOID_P == 8
+#if NUSMV_SIZEOF_VOID_P == 8
   retValue = fprintf (fp, "node%lx) (AND (NOT ",
-    (unsigned long) T / (unsigned long) sizeof(DdNode));
+                      /* NuSMV: add begin */
+    (ptruint) T / (ptruint) sizeof(DdNode));
+    /* WAS: (unsigned long) T / (unsigned long) sizeof(DdNode)); */
+  /* NuSMV: add end */
 #else
   retValue = fprintf (fp, "node%x) (AND (NOT ",
     (unsigned) T / (unsigned) sizeof(DdNode));
@@ -846,13 +864,19 @@
     return(0);
   }
 
-#if SIZEOF_VOID_P == 8
+#if NUSMV_SIZEOF_VOID_P == 8
   if (Cudd_IsComplement(cuddE(f))) {
     retValue = fprintf (fp, ") (NOT node%lx)))\n",
-      (unsigned long) E / (unsigned long) sizeof(DdNode));
+                        /* NuSMV: add begin */
+      (ptruint) E / (ptruint) sizeof(DdNode));
+      /* WAS: (unsigned long) E / (unsigned long) sizeof(DdNode)); */
+    /* NuSMV: add end */
   } else {
     retValue = fprintf (fp, ") node%lx))\n",
-      (unsigned long) E / (unsigned long) sizeof(DdNode));
+                        /* NuSMV: add begin */
+      (ptruint) E / (ptruint) sizeof(DdNode));
+      /* WAS: (unsigned long) E / (unsigned long) sizeof(DdNode)); */
+    /* NuSMV: add end */
   }
 #else
   if (Cudd_IsComplement(cuddE(f))) {
@@ -1064,18 +1088,24 @@
   for (i = 0; i < n; i++) {
     if (outputNames == NULL) {
       retValue = fprintf(fp,
-#if SIZEOF_VOID_P == 8
+#if NUSMV_SIZEOF_VOID_P == 8
         ".names node%lx outNode%d\n",
-        (unsigned long) f[i] / (unsigned long) sizeof(DdNode), i);
+                         /* NuSMV: add begin */
+        (ptruint) f[i] / (ptruint) sizeof(DdNode), i);
+        /* WAS: (unsigned long) f[i] / (unsigned long) sizeof(DdNode), i); */
+      /* NuSMV: add end */
 #else
 	".names node%x outNode%d\n",
         (unsigned) f[i] / (unsigned) sizeof(DdNode), i);
 #endif
     } else {
       retValue = fprintf(fp,
-#if SIZEOF_VOID_P == 8
+#if NUSMV_SIZEOF_VOID_P == 8
         ".names node%lx %s\n",
-        (unsigned long) f[i] / (unsigned long) sizeof(DdNode), outputNames[i]);
+                         /* NuSMV: add begin */
+        (ptruint) f[i] / (ptruint) sizeof(DdNode), outputNames[i]);
+        /* WAS: (unsigned long) f[i] / (unsigned long) sizeof(DdNode), outputNames[i]); */
+      /* NuSMV: add end */
 #else
         ".names node%x %s\n",
         (unsigned) f[i] / (unsigned) sizeof(DdNode), outputNames[i]);
@@ -1151,10 +1181,13 @@
   }
 
   /* Check for special case: If constant node, generate constant 1. */
-  if (f == DD_ONE(ddMgr)) {
-#if SIZEOF_VOID_P == 8
+  if (f == DD_TRUE(ddMgr)) {
+#if NUSMV_SIZEOF_VOID_P == 8
     retValue = fprintf(fp, ".names node%lx\n1\n",
-      (unsigned long) f / (unsigned long) sizeof(DdNode));
+                       /* NuSMV: add begin */
+      (ptruint) f / (ptruint) sizeof(DdNode));
+      /* WAS: (unsigned long) f / (unsigned long) sizeof(DdNode)); */
+    /* NuSMV: add end */
 #else
     retValue = fprintf(fp, ".names node%x\n1\n",
       (unsigned) f / (unsigned) sizeof(DdNode));
@@ -1166,13 +1199,16 @@
     }
   }
 
-  /* Check whether this is an ADD. We deal with 0-1 ADDs, but not
+  /* Check whether this is an ADD. We deal with FALSE-TRUE ADDs, but not
   ** with the general case.
   */
-  if (f == DD_ZERO(ddMgr)) {
-#if SIZEOF_VOID_P == 8
+  if (f == DD_FALSE(ddMgr)) {
+#if NUSMV_SIZEOF_VOID_P == 8
     retValue = fprintf(fp, ".names node%lx\n",
-      (unsigned long) f / (unsigned long) sizeof(DdNode));
+                       /* NuSMV: add begin */
+      (ptruint) f / (ptruint) sizeof(DdNode));
+      /* WAS: (unsigned long) f / (unsigned long) sizeof(DdNode)); */
+    /* NuSMV: add end */
 #else
     retValue = fprintf(fp, ".names node%x\n",
       (unsigned) f / (unsigned) sizeof(DdNode));
@@ -1205,18 +1241,31 @@
     return(0);
   }
 
-#if SIZEOF_VOID_P == 8
+#if NUSMV_SIZEOF_VOID_P == 8
+  /* NuSMV: add begin */
   if (Cudd_IsComplement(cuddE(f))) {
     retValue = fprintf(fp," node%lx node%lx node%lx\n11- 1\n0-0 1\n",
-      (unsigned long) T / (unsigned long) sizeof(DdNode),
-      (unsigned long) E / (unsigned long) sizeof(DdNode),
-      (unsigned long) f / (unsigned long) sizeof(DdNode));
+      (ptruint) T / (ptruint) sizeof(DdNode),
+      (ptruint) E / (ptruint) sizeof(DdNode),
+      (ptruint) f / (ptruint) sizeof(DdNode));
   } else {
     retValue = fprintf(fp," node%lx node%lx node%lx\n11- 1\n0-1 1\n",
-      (unsigned long) T / (unsigned long) sizeof(DdNode),
-      (unsigned long) E / (unsigned long) sizeof(DdNode),
-      (unsigned long) f / (unsigned long) sizeof(DdNode));
-  }
+      (ptruint) T / (ptruint) sizeof(DdNode),
+      (ptruint) E / (ptruint) sizeof(DdNode),
+      (ptruint) f / (ptruint) sizeof(DdNode));
+  }
+    /* WAS:  if (Cudd_IsComplement(cuddE(f))) {
+             retValue = fprintf(fp," node%lx node%lx node%lx\n11- 1\n0-0 1\n",
+             (unsigned long) T / (unsigned long) sizeof(DdNode),
+             (unsigned long) E / (unsigned long) sizeof(DdNode),
+             (unsigned long) f / (unsigned long) sizeof(DdNode));
+             } else {
+             retValue = fprintf(fp," node%lx node%lx node%lx\n11- 1\n0-1 1\n",
+             (unsigned long) T / (unsigned long) sizeof(DdNode),
+             (unsigned long) E / (unsigned long) sizeof(DdNode),
+             (unsigned long) f / (unsigned long) sizeof(DdNode));
+             } */
+  /* NuSMV: add end */
 #else
   if (Cudd_IsComplement(cuddE(f))) {
     retValue = fprintf(fp," node%x node%x node%x\n11- 1\n0-0 1\n",
@@ -1430,17 +1479,23 @@
       "Error during file store.", failure);
 
     if (Cudd_IsComplement(f[i])) {
-#if SIZEOF_VOID_P == 8
+#if NUSMV_SIZEOF_VOID_P == 8
       retValue = fprintf (fp, "!node%lx\n",
-        (unsigned long) f[i] / (unsigned long) sizeof(DdNode));
+                          /* NuSMV: add begin */
+        (ptruint) f[i] / (ptruint) sizeof(DdNode));
+        /* WAS: (unsigned long) f[i] / (unsigned long) sizeof(DdNode)); */
+      /* NuSMV: add end */
 #else
       retValue = fprintf (fp, "!node%x\n",
         (unsigned) f[i] / (unsigned) sizeof(DdNode));
 #endif
     } else {
-#if SIZEOF_VOID_P == 8
+#if NUSMV_SIZEOF_VOID_P == 8
       retValue = fprintf (fp, "node%lx\n",
-        (unsigned long) f[i] / (unsigned long) sizeof(DdNode));
+                          /* NuSMV: add begin */
+        (ptruint) f[i] / (ptruint) sizeof(DdNode));
+        /* WAS: (unsigned long) f[i] / (unsigned long) sizeof(DdNode)); */
+      /* NuSMV: add end */
 #else
       retValue = fprintf (fp, "node%x\n",
         (unsigned) f[i] / (unsigned) sizeof(DdNode));
@@ -1518,11 +1573,14 @@
   }
 
   /* Check for special case: If constant node, generate constant 1. */
-  if (f == DD_ONE (ddMgr)) {
-#if SIZEOF_VOID_P == 8
+  if (f == DD_TRUE (ddMgr)) {
+#if NUSMV_SIZEOF_VOID_P == 8
     retValue = fprintf (fp,
       "node%lx := 1;\n",
-      (unsigned long) f / (unsigned long) sizeof(DdNode));
+                        /* NuSMV: add begin */
+      (ptruint) f / (ptruint) sizeof(DdNode));
+      /* WAS: (unsigned long) f / (unsigned long) sizeof(DdNode)); */
+    /* NuSMV: add end */
 #else
     retValue = fprintf (fp,
       "node%x := 1;\n",
@@ -1536,15 +1594,18 @@
   }
 
   /*
-   *  Check whether this is an ADD. We deal with 0-1 ADDs, but not
+   *  Check whether this is an ADD. We deal with FALSE-TRUE ADDs, but not
    *  with the general case.
    */
 
-  if (f == DD_ZERO(ddMgr)) {
-#if SIZEOF_VOID_P == 8
+  if (f == DD_FALSE(ddMgr)) {
+#if NUSMV_SIZEOF_VOID_P == 8
     retValue = fprintf (fp,
       "node%lx := 0;\n",
-       (unsigned long) f / (unsigned long) sizeof(DdNode));
+                        /* NuSMV: add begin */
+       (ptruint) f / (ptruint) sizeof(DdNode));
+      /* WAS: (unsigned long) f / (unsigned long) sizeof(DdNode)); */
+    /* NuSMV: add end */
 #else
     retValue = fprintf (fp,
       "node%x := 0;\n",
@@ -1574,9 +1635,12 @@
   }
 
   /* Write multiplexer taking complement arc into account. */
-#if SIZEOF_VOID_P == 8
+#if NUSMV_SIZEOF_VOID_P == 8
   retValue = fprintf (fp, "node%lx := ",
-    (unsigned long) f / (unsigned long) sizeof(DdNode));
+                      /* NuSMV: add begin */
+    (ptruint) f / (ptruint) sizeof(DdNode));
+    /* WAS: (unsigned long) f / (unsigned long) sizeof(DdNode)); */
+  /* NuSMV: add end */
 #else
   retValue = fprintf (fp, "node%x := ",
     (unsigned) f / (unsigned) sizeof(DdNode));
@@ -1594,9 +1658,12 @@
     return(0);
   }
 
-#if SIZEOF_VOID_P == 8
+#if NUSMV_SIZEOF_VOID_P == 8
   retValue = fprintf (fp, "& node%lx | ",
-    (unsigned long) T / (unsigned long) sizeof(DdNode));
+                      /* NuSMV: add begin */
+    (ptruint) T / (ptruint) sizeof(DdNode));
+    /* WAS: (unsigned long) T / (unsigned long) sizeof(DdNode)); */
+  /* NuSMV: add end */
 #else
   retValue = fprintf (fp, "& node%x | ",
     (unsigned) T / (unsigned) sizeof(DdNode));
@@ -1614,13 +1681,19 @@
     return(0);
   }
 
-#if SIZEOF_VOID_P == 8
+#if NUSMV_SIZEOF_VOID_P == 8
   if (Cudd_IsComplement(cuddE(f))) {
     retValue = fprintf (fp, "& !node%lx\n",
-      (unsigned long) E / (unsigned long) sizeof(DdNode));
+                        /* NuSMV: add begin */
+      (ptruint) E / (ptruint) sizeof(DdNode));
+      /* WAS: (unsigned long) E / (unsigned long) sizeof(DdNode)); */
+    /* NuSMV: add end */
   } else {
     retValue = fprintf (fp, "& node%lx\n",
-      (unsigned long) E / (unsigned long) sizeof(DdNode));
+                        /* NuSMV: add begin */
+      (ptruint) E / (ptruint) sizeof(DdNode));
+      /* WAS: (unsigned long) E / (unsigned long) sizeof(DdNode)); */
+    /* NuSMV: add end */
   }
 #else
   if (Cudd_IsComplement(cuddE(f))) {
diff -Nru a/dddmp/Makefile b/dddmp/Makefile
--- a/dddmp/Makefile	2016-01-20 23:04:27.000000000 +0100
+++ b/dddmp/Makefile	2024-05-03 15:06:21.845159949 +0200
@@ -82,9 +82,9 @@
 # For Solaris, BSD should not be replaced by UNIX100.
 #XCFLAGS	= -DHAVE_IEEE_754 -DUNIX100 -DEPD_BIG_ENDIAN
 # New native compiler for the Alphas; 64-bit pointers. 
-#XCFLAGS	= -g3 -O4 -std -DBSD -DHAVE_IEEE_754 -ieee_with_no_inexact -tune host -DSIZEOF_VOID_P=8 -DSIZEOF_LONG=8
+#XCFLAGS	= -g3 -O4 -std -DBSD -DHAVE_IEEE_754 -ieee_with_no_inexact -tune host -DNUSMV_SIZEOF_VOID_P=8 -DNUSMV_SIZEOF_LONG=8
 # New native compiler for the Alphas; 32-bit pointers.
-#XCFLAGS	= -g3 -O4 -std -DBSD -DHAVE_IEEE_754 -ieee_with_no_inexact -tune host -xtaso -DSIZEOF_LONG=8
+#XCFLAGS	= -g3 -O4 -std -DBSD -DHAVE_IEEE_754 -ieee_with_no_inexact -tune host -xtaso -DNUSMV_SIZEOF_LONG=8
 #  Windows95/98/NT/XP with Cygwin tools
 #XCFLAGS	= -mcpu=pentiumpro -malign-double -DHAVE_IEEE_754 -DHAVE_GETRLIMIT=0 -DRLIMIT_DATA_DEFAULT=67108864
 
diff -Nru a/dddmp/testdddmp.c b/dddmp/testdddmp.c
--- a/dddmp/testdddmp.c	2016-01-20 23:04:27.000000000 +0100
+++ b/dddmp/testdddmp.c	2024-05-03 15:06:21.848493320 +0200
@@ -467,7 +467,7 @@
 
   ReadInt (DDDMP_MESSAGE_BDD, &i);
 
-  operandBdd[i] = Cudd_ReadOne (ddMgr);
+  operandBdd[i] = Cudd_ReadTrue (ddMgr);
 
   return (DDDMP_SUCCESS);
 }
@@ -497,7 +497,7 @@
 
   ReadInt (DDDMP_MESSAGE_BDD, &i);
 
-  one = Cudd_ReadOne(ddMgr);
+  one = Cudd_ReadTrue(ddMgr);
   operandBdd[i] = Cudd_Not(one);
 
   return (DDDMP_SUCCESS);
@@ -576,10 +576,10 @@
   }
 
   /* Cubes and BDD creation */
-  f = Cudd_Not (Cudd_ReadOne (ddMgr));
+  f = Cudd_Not (Cudd_ReadTrue (ddMgr));
   for (i=0; i<nc; i++)
     {
-    g = Cudd_ReadOne (ddMgr);
+    g = Cudd_ReadTrue (ddMgr);
     for (j=0; j<nv; j++)
       {
       if ( ((float) rand())/((float) RAND_MAX) > 0.5 ) {
diff -Nru a/epd/epd.c b/epd/epd.c
--- a/epd/epd.c	2016-01-20 23:04:27.000000000 +0100
+++ b/epd/epd.c	2024-05-03 15:06:21.848493320 +0200
@@ -44,7 +44,7 @@
   ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   POSSIBILITY OF SUCH DAMAGE.]
 
-  Revision    [$Id: epd.c,v 1.10 2004/08/13 18:20:30 fabio Exp $]
+  Revision    [$Id: epd.c,v 1.1.2.1 2010-02-04 10:41:19 nusmv Exp $]
 
 ******************************************************************************/
 
@@ -137,6 +137,11 @@
   int		exponent;
   char		*pos;
 
+  /* NuSMV: add begin */
+  exponent = 0;
+  value = 0;
+  /* NuSMV: add end */
+
   if (IsNanDouble(epd->type.value)) {
     sprintf(str, "NaN");
     return;
diff -Nru a/epd/epd.h b/epd/epd.h
--- a/epd/epd.h	2016-01-20 23:04:27.000000000 +0100
+++ b/epd/epd.h	2024-05-03 15:06:21.848493320 +0200
@@ -44,7 +44,7 @@
   ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   POSSIBILITY OF SUCH DAMAGE.]
 
-  Revision    [$Id: epd.h,v 1.9 2004/08/13 18:20:30 fabio Exp $]
+  Revision    [$Id: epd.h,v 1.1.2.1 2010-02-04 10:41:19 nusmv Exp $]
 
 ******************************************************************************/
 
diff -Nru a/epd/Makefile b/epd/Makefile
--- a/epd/Makefile	2016-01-20 23:04:27.000000000 +0100
+++ b/epd/Makefile	2024-05-03 15:06:21.848493320 +0200
@@ -1,4 +1,4 @@
-# $Id$
+# $Id: Makefile,v 1.1.2.1 2010-02-04 10:41:19 nusmv Exp $
 #
 # epd -- extended precision
 #---------------------------------------------------------------------------
@@ -61,4 +62,4 @@
 	rm -f *.o *.u .pure *.warnings
 
 distclean: clean
-	rm -f lib*.a lib$(P).b llib-l$(P).ln tags *~ *.bak *.qv *.qx
+	rm -f lib*.a lib$(P).b llib-l$(P).ln TAGS tags *~ *.bak *.qv *.qx
diff -Nru a/Makefile b/Makefile
--- a/Makefile	2016-01-20 23:04:27.000000000 +0100
+++ b/Makefile	2024-05-03 15:06:21.835159836 +0200
@@ -1,8 +1,13 @@
-# $Id$
+# $Id: Makefile,v 1.1.2.1 2010-02-04 10:41:15 nusmv Exp $
 #
 # Makefile for the CUDD distribution kit 
 #---------------------------------------------------------------------------
 
+# NuSMV: added begin
+# replaced every occurence of make with $(MAKE) to make it possible to
+# execute it in systems in which you have only the gmake installed.
+# NuSMV: added end
+
 # Beginning of the configuration section. These symbol definitions can
 # be overridden from the command line.
 
@@ -62,15 +67,15 @@
 #  Linux
 #
 # Gcc 2.8.1 or higher on i686.
-XCFLAGS	= -mcpu=pentiumpro -malign-double -DHAVE_IEEE_754 -DBSD
+#XCFLAGS	= -mcpu=pentiumpro -malign-double -DHAVE_IEEE_754 -DBSD
 # Gcc 3.2.2 or higher on i686.
-#XCFLAGS	= -mcpu=pentium4 -malign-double -DHAVE_IEEE_754 -DBSD
+XCFLAGS	= -mcpu=pentium4 -malign-double -DHAVE_IEEE_754 -DBSD -DNUSMV_SIZEOF_VOID_P=4 -DNUSMV_SIZEOF_LONG=4 -DNUSMV_SIZEOF_INT=4
 # Icc on i686.
 #XCFLAGS	= -ansi -align -ip -DHAVE_IEEE_754 -DBSD
 # Gcc on ia64.
-#XCFLAGS	= -DHAVE_IEEE_754 -DBSD -DSIZEOF_VOID_P=8 -DSIZEOF_LONG=8
+#XCFLAGS	= -DHAVE_IEEE_754 -DBSD -DNUSMV_SIZEOF_VOID_P=8 -DNUSMV_SIZEOF_LONG=8
 # Icc/ecc on ia64.
-#XCFLAGS = -ansi -DBSD -DHAVE_IEEE_754 -DSIZEOF_VOID_P=8 -DSIZEOF_LONG=8
+#XCFLAGS = -ansi -DBSD -DHAVE_IEEE_754 -DNUSMV_SIZEOF_VOID_P=8 -DNUSMV_SIZEOF_LONG=8
 #
 #==========================
 #  Solaris
@@ -113,15 +118,15 @@
 # are proposed here.
 #
 # Old native compiler for the Alphas; 64-bit pointers.
-#XCFLAGS	= -DBSD -DHAVE_IEEE_754 -ieee_with_no_inexact -tune host -DSIZEOF_VOID_P=8 -DSIZEOF_LONG=8
+#XCFLAGS	= -DBSD -DHAVE_IEEE_754 -ieee_with_no_inexact -tune host -DNUSMV_SIZEOF_VOID_P=8 -DNUSMV_SIZEOF_LONG=8
 # Old native compiler for the Alphas; 32-bit pointers.
-#XCFLAGS	= -DBSD -DHAVE_IEEE_754 -ieee_with_no_inexact -tune host -xtaso -DSIZEOF_LONG=8
+#XCFLAGS	= -DBSD -DHAVE_IEEE_754 -ieee_with_no_inexact -tune host -xtaso -DNUSMV_SIZEOF_LONG=8
 # New native compiler for the Alphas; 64-bit pointers. 
-#XCFLAGS	= -g3 -O4 -std -DBSD -DHAVE_IEEE_754 -ieee_with_no_inexact -tune host -DSIZEOF_VOID_P=8 -DSIZEOF_LONG=8
+#XCFLAGS	= -g3 -O4 -std -DBSD -DHAVE_IEEE_754 -ieee_with_no_inexact -tune host -DNUSMV_SIZEOF_VOID_P=8 -DNUSMV_SIZEOF_LONG=8
 # New native compiler for the Alphas; 32-bit pointers.
-#XCFLAGS	= -g3 -O4 -std -DBSD -DHAVE_IEEE_754 -ieee_with_no_inexact -tune host -xtaso -DSIZEOF_LONG=8
+#XCFLAGS	= -g3 -O4 -std -DBSD -DHAVE_IEEE_754 -ieee_with_no_inexact -tune host -xtaso -DNUSMV_SIZEOF_LONG=8
 # gcc for the Alphas: compile without HAVE_IEEE_754.
-#XCFLAGS	= -DBSD -DSIZEOF_VOID_P=8 -DSIZEOF_LONG=8
+#XCFLAGS	= -DBSD -DNUSMV_SIZEOF_VOID_P=8 -DNUSMV_SIZEOF_LONG=8
 #
 #==========================
 #
@@ -194,8 +199,10 @@
 IDIR	= $(DDWDIR)/include
 INCLUDE = -I$(IDIR)
 
-BDIRS	= cudd dddmp mtr st util epd
-DIRS	= $(BDIRS) nanotrav
+# BDIRS	= cudd dddmp mtr st util epd
+BDIRS	= cudd mtr st util epd
+# DIRS	= $(BDIRS) nanotrav
+DIRS	= $(BDIRS)
 
 #------------------------------------------------------------------------
 
@@ -219,8 +226,9 @@
 	@for dir in $(DIRS); do \
 		(cd $$dir; \
 		echo Making $$dir ...; \
-		make CC=$(CC) RANLIB=$(RANLIB) MFLAG= MNEMLIB= ICFLAGS="$(ICFLAGS)" XCFLAGS="$(XCFLAGS)" DDDEBUG="$(DDDEBUG)" MTRDEBUG="$(MTRDEBUG)" LDFLAGS="$(LDFLAGS)" PURE="$(PURE)" EXE="$(EXE)" )\
+		$(MAKE) CC=$(CC) RANLIB=$(RANLIB) MFLAG= MNEMLIB= ICFLAGS="$(ICFLAGS)" XCFLAGS="$(XCFLAGS)" DDDEBUG="$(DDDEBUG)" MTRDEBUG="$(MTRDEBUG)" LDFLAGS="$(LDFLAGS)" PURE="$(PURE)" EXE="$(EXE)" )\
 	done
+	sh ./setup.sh
 
 nanotrav: build
 
@@ -229,15 +237,16 @@
 	@for dir in mnemosyne $(DIRS); do \
 		(cd $$dir; \
 		echo Making $$dir ...; \
-		make CC=$(CC) RANLIB=$(RANLIB) MFLAG=$(MFLAG) MNEMLIB=$(MNEMLIB) ICFLAGS="$(ICFLAGS)" XCFLAGS="$(XCFLAGS)" DDDEBUG="$(DDDEBUG)" MTRDEBUG="$(MTRDEBUG)" LDFLAGS="$(LDFLAGS)" EXE="$(EXE)" )\
+		$(MAKE) CC=$(CC) RANLIB=$(RANLIB) MFLAG=$(MFLAG) MNEMLIB=$(MNEMLIB) ICFLAGS="$(ICFLAGS)" XCFLAGS="$(XCFLAGS)" DDDEBUG="$(DDDEBUG)" MTRDEBUG="$(MTRDEBUG)" LDFLAGS="$(LDFLAGS)" EXE="$(EXE)" )\
 	done
+	sh ./setup.sh
 
 optimize_dec:
 	sh ./setup.sh
 	@for dir in $(DIRS); do \
 		(cd $$dir; \
 		echo Making $$dir ...; \
-		make CC=$(CC) RANLIB=$(RANLIB) XCFLAGS="$(XCFLAGS)" LDFLAGS="$(LDFLAGS)" optimize_dec )\
+		$(MAKE) CC=$(CC) RANLIB=$(RANLIB) XCFLAGS="$(XCFLAGS)" LDFLAGS="$(LDFLAGS)" optimize_dec )\
 	done
 
 lint:
@@ -245,73 +254,79 @@
 	@for dir in $(DIRS) obj; do \
 		(cd $$dir; \
 		echo Making lint in $$dir ...; \
-		make CC=$(CC) lint )\
+		$(MAKE) CC=$(CC) lint )\
 	done
+	sh ./setup.sh
 
 tags:
 	sh ./setup.sh
 	@for dir in $(DIRS) obj; do \
 		(cd $$dir; \
 		echo Making tags in $$dir ...; \
-		make CC=$(CC) tags )\
+		$(MAKE) CC=$(CC) tags )\
 	done
+	etags -i `pwd`/cudd/TAGS -i `pwd`/mtr/TAGS -i `pwd`/epd/TAGS -i `pwd`/util/TAGS -i `pwd`/st/TAGS
+	sh ./setup.sh
 
 all:
 	sh ./setup.sh
 	@for dir in $(DIRS); do \
 		(cd $$dir; \
 		echo Making all in $$dir ...; \
-		make CC=$(CC) RANLIB=$(RANLIB) MFLAG= MNEMLIB= ICFLAGS="$(ICFLAGS)" XCFLAGS="$(XCFLAGS)" DDDEBUG="$(DDDEBUG)" MTRDEBUG="$(MTRDEBUG)" LDFLAGS="$(LDFLAGS)" PURE="$(PURE)" EXE="$(EXE)" all )\
+		$(MAKE) CC=$(CC) RANLIB=$(RANLIB) MFLAG= MNEMLIB= ICFLAGS="$(ICFLAGS)" XCFLAGS="$(XCFLAGS)" DDDEBUG="$(DDDEBUG)" MTRDEBUG="$(MTRDEBUG)" LDFLAGS="$(LDFLAGS)" PURE="$(PURE)" EXE="$(EXE)" all )\
 	done
+	sh ./setup.sh
 
 testcudd:
 	sh ./setup.sh
 	@for dir in util st mtr epd; do \
 		(cd $$dir; \
 		echo Making $$dir ...; \
-		make CC=$(CC) RANLIB=$(RANLIB) MFLAG= MNEMLIB= ICFLAGS="$(ICFLAGS)" XCFLAGS="$(XCFLAGS)" DDDEBUG="$(DDDEBUG)" MTRDEBUG="$(MTRDEBUG)" LDFLAGS="$(LDFLAGS)" PURE="$(PURE)" EXE="$(EXE)" )\
+		$(MAKE) CC=$(CC) RANLIB=$(RANLIB) MFLAG= MNEMLIB= ICFLAGS="$(ICFLAGS)" XCFLAGS="$(XCFLAGS)" DDDEBUG="$(DDDEBUG)" MTRDEBUG="$(MTRDEBUG)" LDFLAGS="$(LDFLAGS)" PURE="$(PURE)" EXE="$(EXE)" )\
 	done
+	sh ./setup.sh
 	@(cd cudd; \
 	echo Making testcudd ...; \
-	make CC=$(CC) RANLIB=$(RANLIB) MFLAG= MNEMLIB= ICFLAGS="$(ICFLAGS)" XCFLAGS="$(XCFLAGS)" DDDEBUG="$(DDDEBUG)" MTRDEBUG="$(MTRDEBUG)" LDFLAGS="$(LDFLAGS)" PURE="$(PURE)" EXE="$(EXE)" testcudd$(EXE) )
+	$(MAKE) CC=$(CC) RANLIB=$(RANLIB) MFLAG= MNEMLIB= ICFLAGS="$(ICFLAGS)" XCFLAGS="$(XCFLAGS)" DDDEBUG="$(DDDEBUG)" MTRDEBUG="$(MTRDEBUG)" LDFLAGS="$(LDFLAGS)" PURE="$(PURE)" EXE="$(EXE)" testcudd$(EXE) )
 
 objlib:
 	sh ./setup.sh
 	@for dir in $(BDIRS); do \
 		(cd $$dir; \
 		echo Making $$dir ...; \
-		make CC=$(CC) RANLIB=$(RANLIB) MFLAG= MNEMLIB= ICFLAGS="$(ICFLAGS)" XCFLAGS="$(XCFLAGS)" DDDEBUG="$(DDDEBUG)" MTRDEBUG="$(MTRDEBUG)" LDFLAGS="$(LDFLAGS)" PURE="$(PURE)" EXE="$(EXE)" )\
+		$(MAKE) CC=$(CC) RANLIB=$(RANLIB) MFLAG= MNEMLIB= ICFLAGS="$(ICFLAGS)" XCFLAGS="$(XCFLAGS)" DDDEBUG="$(DDDEBUG)" MTRDEBUG="$(MTRDEBUG)" LDFLAGS="$(LDFLAGS)" PURE="$(PURE)" EXE="$(EXE)" )\
 	done
+	sh ./setup.sh
 	@(cd obj; \
 	echo Making obj ...; \
-	make CPP=$(CPP) CPPFLAGS=$(CPPFLAGS) RANLIB=$(RANLIB) MFLAG= MNEMLIB= ICFLAGS="$(ICFLAGS)" XCFLAGS="$(XCFLAGS)" DDDEBUG="$(DDDEBUG)" MTRDEBUG="$(MTRDEBUG)" LDFLAGS="$(LDFLAGS)" PURE="$(PURE)" EXE="$(EXE)" )
+	$(MAKE) CPP=$(CPP) CPPFLAGS=$(CPPFLAGS) RANLIB=$(RANLIB) MFLAG= MNEMLIB= ICFLAGS="$(ICFLAGS)" XCFLAGS="$(XCFLAGS)" DDDEBUG="$(DDDEBUG)" MTRDEBUG="$(MTRDEBUG)" LDFLAGS="$(LDFLAGS)" PURE="$(PURE)" EXE="$(EXE)" )
 
 testobj: objlib
 	@(cd obj; \
 	echo Making testobj ...; \
-	make CPP=$(CPP) CPPFLAGS=$(CPPFLAGS) RANLIB=$(RANLIB) MFLAG= MNEMLIB= ICFLAGS="$(ICFLAGS)" XCFLAGS="$(XCFLAGS)" DDDEBUG="$(DDDEBUG)" MTRDEBUG="$(MTRDEBUG)" LDFLAGS="$(LDFLAGS)" PURE="$(PURE)" EXE="$(EXE)" testobj$(EXE) )
+	$(MAKE) CPP=$(CPP) CPPFLAGS=$(CPPFLAGS) RANLIB=$(RANLIB) MFLAG= MNEMLIB= ICFLAGS="$(ICFLAGS)" XCFLAGS="$(XCFLAGS)" DDDEBUG="$(DDDEBUG)" MTRDEBUG="$(MTRDEBUG)" LDFLAGS="$(LDFLAGS)" PURE="$(PURE)" EXE="$(EXE)" testobj$(EXE) )
 
 testdddmp: build
 	@(cd dddmp; \
 	echo Making testdddmp ...; \
-	make CC=$(CC) RANLIB=$(RANLIB) MFLAG= MNEMLIB= ICFLAGS="$(ICFLAGS)" XCFLAGS="$(XCFLAGS)" DDDEBUG="$(DDDEBUG)" MTRDEBUG="$(MTRDEBUG)" LDFLAGS="$(LDFLAGS)" PURE="$(PURE)" EXE="$(EXE)" testdddmp$(EXE) )
+	$(MAKE) CC=$(CC) RANLIB=$(RANLIB) MFLAG= MNEMLIB= ICFLAGS="$(ICFLAGS)" XCFLAGS="$(XCFLAGS)" DDDEBUG="$(DDDEBUG)" MTRDEBUG="$(MTRDEBUG)" LDFLAGS="$(LDFLAGS)" PURE="$(PURE)" EXE="$(EXE)" testdddmp$(EXE) )
 
 testmtr: build
 	@(cd mtr; \
 	echo Making testmtr ...; \
-	make CC=$(CC) RANLIB=$(RANLIB) MFLAG= MNEMLIB= ICFLAGS="$(ICFLAGS)" XCFLAGS="$(XCFLAGS)" DDDEBUG="$(DDDEBUG)" MTRDEBUG="$(MTRDEBUG)" LDFLAGS="$(LDFLAGS)" PURE="$(PURE)" EXE="$(EXE)" testmtr$(EXE) )
+	$(MAKE) CC=$(CC) RANLIB=$(RANLIB) MFLAG= MNEMLIB= ICFLAGS="$(ICFLAGS)" XCFLAGS="$(XCFLAGS)" DDDEBUG="$(DDDEBUG)" MTRDEBUG="$(MTRDEBUG)" LDFLAGS="$(LDFLAGS)" PURE="$(PURE)" EXE="$(EXE)" testmtr$(EXE) )
 
 clean:
 	@for dir in mnemosyne $(DIRS) obj; do	\
 	    (cd $$dir; 	\
 	     echo Cleaning $$dir ...; \
-	     make -s clean	) \
+	     $(MAKE) -s clean	) \
 	done
 
 distclean:
 	@for dir in mnemosyne $(DIRS) obj; do	\
 	    (cd $$dir; 	\
 	     echo Cleaning $$dir ...; \
-	     make -s EXE="$(EXE)" distclean	) \
+	     $(MAKE) -s EXE="$(EXE)" distclean	) \
 	done
 	sh ./shutdown.sh
diff -Nru a/mnemosyne/mnemosyne.c b/mnemosyne/mnemosyne.c
--- a/mnemosyne/mnemosyne.c	2016-01-20 23:04:27.000000000 +0100
+++ b/mnemosyne/mnemosyne.c	2024-05-03 15:06:21.848493320 +0200
@@ -96,11 +96,20 @@
 	FILE	*log;
 	int	fd;
 
-	long	nalloc;		/* count of allocations */
-	long	nrlloc;		/* count of re-allocations */
-	long	nfree;		/* count of frees */
-	long	nbfree;		/* count of bad frees */
-	long	ninuse;		/* known allocated memory in use */
+  /* NuSMV: add begin */
+	long long	nalloc;		/* count of allocations */
+	long long	nrlloc;		/* count of re-allocations */
+	long long	nfree;		/* count of frees */
+	long long	nbfree;		/* count of bad frees */
+	long long	ninuse;		/* known allocated memory in use */
+    /* WAS: 	long	nalloc;		count of allocations
+                long	nrlloc;		count of re-allocations
+                long	nfree;		count of frees
+                long	nbfree;		count of bad frees
+                long	ninuse;		known allocated memory in use
+    */
+  /* NuSMV: add end */
+
 	float	avgsiz;		/* average malloc size */
 
 	/* one entry per pointer returned by malloc */
@@ -287,7 +296,10 @@
 	register struct	ptr	*p;
 
 	/* this probably give simply terrible hash performance */
-	p = map.phash[(unsigned long)ptr % HASHSIZ];
+        /* NuSMV: add begin */
+	p = map.phash[(ptruint)ptr % HASHSIZ];
+          /* WAS: p = map.phash[(unsigned long)ptr % HASHSIZ]; */
+        /* NuSMV: add end */
 	while(p != (struct ptr *)0) {
 		if(ptr == p->ptr)
 			return(p);
@@ -440,8 +452,8 @@
 		}
 
 		/* link it in */
-		p->next = map.phash[(unsigned long)ptr % HASHSIZ];
-		map.phash[(unsigned long)ptr % HASHSIZ] = p;
+		p->next = map.phash[(ptruint)ptr % HASHSIZ];
+		map.phash[(ptruint)ptr % HASHSIZ] = p;
 	}
 
 	/* if we get to here (hazoo! hazaa!) both 's' and 'p' are OK */
diff -Nru a/mtr/Makefile b/mtr/Makefile
--- a/mtr/Makefile	2016-01-20 23:04:27.000000000 +0100
+++ b/mtr/Makefile	2024-05-03 15:06:21.848493320 +0200
@@ -1,4 +1,4 @@
-# $Id: Makefile,v 1.2 1994/10/03 23:30:34 fabio Exp fabio $
+# $Id: Makefile,v 1.1.2.1 2010-02-04 10:41:20 nusmv Exp $
 #
 #    mtr - multiway-branching tree package
 #---------------------------
@@ -93,4 +94,4 @@
 
 distclean: clean
 	rm -f $(TARGET) $(TARGETu) lib*.a lib$(P).b llib-l$(P).ln \
-	*.bak *~ tags *.qv *.qx
+	*.bak *~ tags TAGS *.qv *.qx
diff -Nru a/mtr/mtrBasic.c b/mtr/mtrBasic.c
--- a/mtr/mtrBasic.c	2016-01-20 23:04:27.000000000 +0100
+++ b/mtr/mtrBasic.c	2024-05-03 15:06:21.848493320 +0200
@@ -81,7 +81,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] MTR_UNUSED = "$Id: mtrBasic.c,v 1.12 2004/08/13 18:15:11 fabio Exp $";
+static char rcsid[] MTR_UNUSED = "$Id: mtrBasic.c,v 1.1.2.1 2010-02-04 10:41:20 nusmv Exp $";
 #endif
 
 /*---------------------------------------------------------------------------*/
@@ -424,11 +424,17 @@
 {
     if (node == NULL) return;
     (void) fprintf(stdout,
-#if SIZEOF_VOID_P == 8
+#if NUSMV_SIZEOF_VOID_P == 8
     "N=0x%-8lx C=0x%-8lx Y=0x%-8lx E=0x%-8lx P=0x%-8lx F=%x L=%d S=%d\n",
-    (unsigned long) node, (unsigned long) node->child,
-    (unsigned long) node->younger, (unsigned long) node->elder,
-    (unsigned long) node->parent, node->flags, node->low, node->size);
+    /* NuSMV: add begin */
+    (util_ptruint) node, (util_ptruint) node->child,
+    (util_ptruint) node->younger, (util_ptruint) node->elder,
+    (util_ptruint) node->parent, node->flags, node->low, node->size);
+      /* WAS: (unsigned long) node, (unsigned long) node->child,
+              (unsigned long) node->younger, (unsigned long) node->elder,
+              (unsigned long) node->parent, node->flags, node->low, node->size); */
+    /* NuSMV: add end */
+
 #else
     "N=0x%-8x C=0x%-8x Y=0x%-8x E=0x%-8x P=0x%-8x F=%x L=%d S=%d\n",
     (unsigned) node, (unsigned) node->child,
diff -Nru a/mtr/mtrGroup.c b/mtr/mtrGroup.c
--- a/mtr/mtrGroup.c	2016-01-20 23:04:27.000000000 +0100
+++ b/mtr/mtrGroup.c	2024-05-03 15:06:21.848493320 +0200
@@ -80,7 +80,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] MTR_UNUSED = "$Id: mtrGroup.c,v 1.16 2004/08/13 18:15:11 fabio Exp $";
+static char rcsid[] MTR_UNUSED = "$Id: mtrGroup.c,v 1.1.2.1 2010-02-04 10:41:20 nusmv Exp $";
 #endif
 
 /*---------------------------------------------------------------------------*/
@@ -296,7 +296,11 @@
 
     /* Here last != NULL and low + size <= last->low + last->size. */
     if (low + size - 1 >= (unsigned int) last->low &&
-	low + size < (unsigned int) (last->low + last->size)) {
+        /* NuSmv change begins */
+	/* low + size <= (unsigned int) (last->low + last->size)) { */
+	low + size <  (unsigned int) (last->low + last->size)) {
+        /* Backporing from 2.5.0, closing mantis issue 0003936 */
+        /* NuSmv change ends */
 	/* Trying to cut an existing group: not allowed. */
 	return(NULL);
     }
@@ -360,8 +364,39 @@
 
     parent = group->parent;
 
-    if (parent == NULL) return(NULL);
-    if (MTR_TEST(group,MTR_TERMINAL) || group->child == NULL) return(NULL);
+    if (parent == NULL) return(NULL); 
+
+#if 1 
+    /* NuSmv change begins */
+    if (MTR_TEST(group,MTR_TERMINAL) || group->child == NULL) {
+      if (group->younger != NULL) {
+	group->younger->elder = group->elder;
+      }
+      if (group->elder != NULL) {
+	group->elder->younger = group->younger;
+      }
+
+      if (parent->child == group) { 
+	if (group->elder != NULL) {
+	  fprintf(stderr, "FAILING GROUP: low=%d, idx=%d, size=%d\n", 
+		  group->low, group->index, group->size);
+	  fprintf(stderr, "Elder that should be null: low=%d, idx=%d, size=%d\n", 
+		  group->elder->low, group->elder->index, group->elder->size);
+
+	  assert(0);
+	  assert(0);
+	}
+	parent->child = group->younger;
+      }
+      
+      Mtr_DeallocNode(group);
+
+      return parent;
+    }
+    /* NuSmv change ends */
+#else
+    if (MTR_TEST(group,MTR_TERMINAL) || group->child == NULL) return NULL; 
+#endif
 
     /* Make all children of group children of its parent, and make
     ** last point to the last child of group. */
@@ -714,3 +749,4 @@
     return(1);
 
 } /* end of mtrShiftHL */
+
diff -Nru a/mtr/mtr.h b/mtr/mtr.h
--- a/mtr/mtr.h	2016-01-20 23:04:27.000000000 +0100
+++ b/mtr/mtr.h	2024-05-03 15:06:21.848493320 +0200
@@ -52,7 +52,7 @@
   ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   POSSIBILITY OF SUCH DAMAGE.]
 
-  Revision    [$Id: mtr.h,v 1.13 2004/08/13 18:15:11 fabio Exp $]
+  Revision    [$Id: mtr.h,v 1.1.2.1 2010-02-04 10:41:20 nusmv Exp $]
 
 ******************************************************************************/
 
@@ -62,6 +62,13 @@
 /*---------------------------------------------------------------------------*/
 /* Nested includes                                                           */
 /*---------------------------------------------------------------------------*/
+#include <stdio.h>
+
+/* NuSMV: added begin */
+#if HAVE_CONFIG_H
+# include "nusmv-config.h"
+#endif
+/* NuSMV: added end */
 
 #ifdef __cplusplus
 extern "C" {
@@ -71,19 +78,12 @@
 /* Constant declarations                                                     */
 /*---------------------------------------------------------------------------*/
 
-#ifndef SIZEOF_VOID_P
-#define SIZEOF_VOID_P 4
-#endif
-#ifndef SIZEOF_INT
-#define SIZEOF_INT 4
-#endif
-
 #undef CONST
-#if defined(__STDC__) || defined(__cplusplus)
+#if defined(__STDC__) || defined(__cplusplus) || defined(_MSC_VER)
 #define CONST           const
-#else /* !(__STDC__ || __cplusplus) */
+#else /* !(__STDC__ || __cplusplus || defined(_MSC_VER))*/
 #define CONST
-#endif /* !(__STDC__ || __cplusplus) */
+#endif /* !(__STDC__ || __cplusplus || defined(_MSC_VER))*/
 
 #if defined(__GNUC__)
 #define MTR_INLINE __inline__
@@ -96,7 +96,7 @@
 #define MTR_INLINE
 #define MTR_UNUSED
 #endif
- 
+
 /* Flag definitions */
 #define MTR_DEFAULT	0x00000000
 #define MTR_TERMINAL 	0x00000001
@@ -108,13 +108,19 @@
 ** machines one can cast a value to (int) without generating a negative
 ** number.
 */
-#if SIZEOF_VOID_P == 8 && SIZEOF_INT == 4
+#if NUSMV_SIZEOF_VOID_P == 8 && NUSMV_SIZEOF_INT == 4
 #define MTR_MAXHIGH	(((MtrHalfWord) ~0) >> 1)
 #else
 #define MTR_MAXHIGH	((MtrHalfWord) ~0)
 #endif
 
 
+/* NuSMV: added begin */
+#if !defined(NUSMV_SIZEOF_VOID_P) || !defined(NUSMV_SIZEOF_LONG) || !defined(NUSMV_SIZEOF_INT)
+#error Constants NUSMV_SIZEOF_VOID_P, NUSMV_SIZEOF_LONG and NUSMV_SIZEOF_INT must be defined
+#endif
+/* NuSMV: added end */
+
 /*---------------------------------------------------------------------------*/
 /* Stucture declarations                                                     */
 /*---------------------------------------------------------------------------*/
@@ -124,7 +130,7 @@
 /* Type declarations                                                         */
 /*---------------------------------------------------------------------------*/
 
-#if SIZEOF_VOID_P == 8 && SIZEOF_INT == 4
+#if NUSMV_SIZEOF_VOID_P == 8 && NUSMV_SIZEOF_INT == 4
 typedef unsigned int   MtrHalfWord;
 #else
 typedef unsigned short MtrHalfWord;
diff -Nru a/mtr/mtrInt.h b/mtr/mtrInt.h
--- a/mtr/mtrInt.h	2016-01-20 23:04:27.000000000 +0100
+++ b/mtr/mtrInt.h	2024-05-03 15:06:21.848493320 +0200
@@ -44,7 +44,7 @@
   ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   POSSIBILITY OF SUCH DAMAGE.]
 
-  Revision    [$Id: mtrInt.h,v 1.2 2004/08/13 18:15:12 fabio Exp $]
+  Revision    [$Id: mtrInt.h,v 1.1.2.1 2010-02-04 10:41:20 nusmv Exp $]
 
 ******************************************************************************/
 
diff -Nru a/mtr/testmtr.c b/mtr/testmtr.c
--- a/mtr/testmtr.c	2016-01-20 23:04:27.000000000 +0100
+++ b/mtr/testmtr.c	2024-05-03 15:06:21.848493320 +0200
@@ -54,7 +54,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] MTR_UNUSED = "$Id: testmtr.c,v 1.3 2004/08/13 18:15:12 fabio Exp $";
+static char rcsid[] MTR_UNUSED = "$Id: testmtr.c,v 1.1.2.1 2010-02-04 10:41:20 nusmv Exp $";
 #endif
 
 /*---------------------------------------------------------------------------*/
diff -Nru a/nanotrav/bnet.c b/nanotrav/bnet.c
--- a/nanotrav/bnet.c	2016-01-20 23:04:27.000000000 +0100
+++ b/nanotrav/bnet.c	2024-05-03 15:06:21.848493320 +0200
@@ -67,7 +67,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] UTIL_UNUSED = "$Id: bnet.c,v 1.24 2004/08/13 18:28:28 fabio Exp fabio $";
+static char rcsid[] UTIL_UNUSED = "$Id: bnet.c,v 1.1.2.1 2010-02-04 10:41:20 nusmv Exp $";
 #endif
 
 static	char	BuffLine[MAXLENGTH];
@@ -655,9 +655,9 @@
 
     if (nd->type == BNET_CONSTANT_NODE) {
 	if (nd->f == NULL) { /* constant 0 */
-	    func = Cudd_ReadLogicZero(dd);
+	    func = Cudd_ReadLogicFalse(dd);
 	} else { /* either constant depending on the polarity */
-	    func = Cudd_ReadOne(dd);
+	    func = Cudd_ReadTrue(dd);
 	}
 	Cudd_Ref(func);
     } else if (nd->type == BNET_INPUT_NODE ||
@@ -678,7 +678,7 @@
 	func = nd->dd;
     } else { /* type == BNET_INTERNAL_NODE or BNET_OUTPUT_NODE */
 	/* Initialize the sum to logical 0. */
-	func = Cudd_ReadLogicZero(dd);
+	func = Cudd_ReadLogicFalse(dd);
 	Cudd_Ref(func);
 
 	/* Build a term for each line of the table and add it to the
@@ -1797,7 +1797,7 @@
     if (nlines != 0) return(0);
 
     /* Initialize the exclusive sum to logical 0. */
-    func = Cudd_ReadLogicZero(dd);
+    func = Cudd_ReadLogicFalse(dd);
     Cudd_Ref(func);
 
     /* Scan the inputs. */
diff -Nru a/nanotrav/bnet.h b/nanotrav/bnet.h
--- a/nanotrav/bnet.h	2016-01-20 23:04:27.000000000 +0100
+++ b/nanotrav/bnet.h	2024-05-03 15:06:21.848493320 +0200
@@ -44,7 +44,7 @@
   ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   POSSIBILITY OF SUCH DAMAGE.]
 
-  Revision    [$Id: bnet.h,v 1.12 2004/08/13 18:28:28 fabio Exp fabio $]
+  Revision    [$Id: bnet.h,v 1.1.2.1 2010-02-04 10:41:20 nusmv Exp $]
 
 ******************************************************************************/
 
diff -Nru a/nanotrav/chkMterm.c b/nanotrav/chkMterm.c
--- a/nanotrav/chkMterm.c	2016-01-20 23:04:27.000000000 +0100
+++ b/nanotrav/chkMterm.c	2024-05-03 15:06:21.848493320 +0200
@@ -75,7 +75,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] UTIL_UNUSED = "$Id: chkMterm.c,v 1.7 2004/08/13 18:28:28 fabio Exp fabio $";
+static char rcsid[] UTIL_UNUSED = "$Id: chkMterm.c,v 1.1.2.1 2010-02-04 10:41:20 nusmv Exp $";
 #endif
 
 /*---------------------------------------------------------------------------*/
diff -Nru a/nanotrav/main.c b/nanotrav/main.c
--- a/nanotrav/main.c	2016-01-20 23:04:27.000000000 +0100
+++ b/nanotrav/main.c	2024-05-03 15:06:21.848493320 +0200
@@ -71,7 +71,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] UTIL_UNUSED = "$Id: main.c,v 1.38 2004/08/13 18:28:28 fabio Exp fabio $";
+static char rcsid[] UTIL_UNUSED = "$Id: main.c,v 1.1.2.1 2010-02-04 10:41:20 nusmv Exp $";
 #endif
 
 static  char    buffer[BUFLENGTH];
@@ -302,7 +302,7 @@
 	sharingSize = Cudd_SharingSize(decomp, Cudd_ReadSize(dd));
 	(void) fprintf(stdout, "Decomposition Size: %d components %d nodes\n",
 		       Cudd_ReadSize(dd), sharingSize);
-	product = Cudd_ReadOne(dd);
+	product = Cudd_ReadTrue(dd);
 	Cudd_Ref(product);
 	for (i = 0; i < Cudd_ReadSize(dd); i++) {
 	    DdNode *intermediate = Cudd_bddAnd(dd, product, decomp[i]);
diff -Nru a/nanotrav/Makefile b/nanotrav/Makefile
--- a/nanotrav/Makefile	2016-01-20 23:04:27.000000000 +0100
+++ b/nanotrav/Makefile	2024-05-03 15:06:21.848493320 +0200
@@ -1,4 +1,4 @@
-# $Id: Makefile,v 1.12 1999/08/31 19:10:05 fabio Exp fabio $
+# $Id: Makefile,v 1.1.2.1 2010-02-04 10:41:20 nusmv Exp $
 #
 # nanotrav: simple FSM traversal program
 #---------------------------------------------------------------------------
@@ -36,8 +36,8 @@
 
 SRC	= main.c bnet.c ntr.c ntrHeap.c ntrBddTest.c ntrMflow.c ntrZddTest.c \
 	  ntrShort.c chkMterm.c ucbqsort.c
-HDR	= bnet.h ntr.h $(WHERE)/include/dddmp.h $(WHERE)/include/cudd.h \
-	$(WHERE)/include/cuddInt.h
+HDR	= bnet.h ntr.h $(INCLUDE)/dddmp.h $(INCLUDE)/cudd.h \
+	$(INCLUDE)/cuddInt.h
 
 OBJ	= $(SRC:.c=.o)
 UBJ	= $(SRC:.c=.u)
diff -Nru a/nanotrav/nanotrav.1 b/nanotrav/nanotrav.1
--- a/nanotrav/nanotrav.1	2016-01-20 23:04:27.000000000 +0100
+++ b/nanotrav/nanotrav.1	2024-05-03 15:06:21.848493320 +0200
@@ -1,4 +1,4 @@
-.\" $Id: nanotrav.1,v 1.22 2004/03/06 03:42:09 fabio Exp fabio $
+.\" $Id: nanotrav.1,v 1.1.2.1 2010-02-04 10:41:20 nusmv Exp $
 .\"
 .TH NANOTRAV 1 "18 June 2002" "Release 0.11"
 .SH NAME
diff -Nru a/nanotrav/ntrBddTest.c b/nanotrav/ntrBddTest.c
--- a/nanotrav/ntrBddTest.c	2016-01-20 23:04:27.000000000 +0100
+++ b/nanotrav/ntrBddTest.c	2024-05-03 15:06:21.848493320 +0200
@@ -66,7 +66,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] UTIL_UNUSED = "$Id: ntrBddTest.c,v 1.20 2004/08/13 18:28:28 fabio Exp fabio $";
+static char rcsid[] UTIL_UNUSED = "$Id: ntrBddTest.c,v 1.1.2.1 2010-02-04 10:41:20 nusmv Exp $";
 #endif
 
 /*---------------------------------------------------------------------------*/
@@ -1440,7 +1440,7 @@
 	(void) printf("T-d    ");
 	Cudd_PrintDebug(dd, f, nvars, pr);
     }
-    one = Cudd_ReadOne(dd);
+    one = Cudd_ReadTrue(dd);
 
     /* Test Cudd_bddApproxConjDecomp */
     nA = Cudd_bddApproxConjDecomp(dd,f,&A);
@@ -2090,6 +2090,7 @@
     } else {
 	int d, *minterm;
 	int nvars = Cudd_ReadSize(dd);
+#warning [AMa] Check false context
 	DdNode *scan, *zero;
 	DdNode *minBdd = Cudd_bddPickOneMinterm(dd,cubeN,vars,nvars);
 	if (minBdd == NULL) {
@@ -2104,7 +2105,7 @@
 	    return(0);
 	}
 	scan = minBdd;
-	zero = Cudd_Not(DD_ONE(dd));
+	zero = Cudd_Not(DD_TRUE(dd));
 	while (!Cudd_IsConstant(scan)) {
 	    DdNode *R = Cudd_Regular(scan);
 	    DdNode *T = Cudd_T(R);
@@ -2189,7 +2190,7 @@
 	}
     }
     verify = Cudd_bddVectorCompose(dd,f,vector);
-    if (verify != Cudd_ReadOne(dd)) {
+    if (verify != Cudd_ReadTrue(dd)) {
 	(void) fprintf(stdout, "Verification failed!\n");
 	return(0);
     }
diff -Nru a/nanotrav/ntr.c b/nanotrav/ntr.c
--- a/nanotrav/ntr.c	2016-01-20 23:04:27.000000000 +0100
+++ b/nanotrav/ntr.c	2024-05-03 15:06:21.848493320 +0200
@@ -67,7 +67,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] UTIL_UNUSED = "$Id: ntr.c,v 1.25 2004/08/13 18:28:28 fabio Exp fabio $";
+static char rcsid[] UTIL_UNUSED = "$Id: ntr.c,v 1.1.2.1 2010-02-04 10:41:20 nusmv Exp $";
 #endif
 
 static const char *onames[] = { "T", "R" };	/* names of functions to be dumped */
@@ -391,7 +391,7 @@
     }
 
     /* Create partitioned transition relation from network. */
-    TR->xw = Cudd_ReadOne(dd);
+    TR->xw = Cudd_ReadTrue(dd);
     Cudd_Ref(TR->xw);
     for (i = 0; i < net->nlatches; i++) {
 	if (!st_lookup(net->hash,net->latches[i][1],&node)) {
@@ -466,10 +466,10 @@
     if (abspcubes == NULL) goto endgame;
 
     for (i = 0; i < net->nlatches; i++) {
-	absicubes[i] = Cudd_ReadOne(dd);
+	absicubes[i] = Cudd_ReadTrue(dd);
 	Cudd_Ref(absicubes[i]);
     }
-    preiabs = Cudd_ReadOne(dd);
+    preiabs = Cudd_ReadTrue(dd);
     Cudd_Ref(preiabs);
 
     for (i = 0; i < net->npis; i++) {
@@ -533,7 +533,7 @@
     /* Reinitialize the cube of variables to be quantified before
     ** image computation. */
     Cudd_RecursiveDeref(dd,preiabs);
-    preiabs = Cudd_ReadOne(dd);
+    preiabs = Cudd_ReadTrue(dd);
     Cudd_Ref(preiabs);
 
     if (option->imageClip != 1.0) {
@@ -541,9 +541,9 @@
     }
 
     /* Collapse transition relation. */
-    T = Cudd_ReadOne(dd);
+    T = Cudd_ReadTrue(dd);
     Cudd_Ref(T);
-    mnscube = Cudd_ReadOne(dd);
+    mnscube = Cudd_ReadTrue(dd);
     Cudd_Ref(mnscube);
     for (i = 0; i < net->nlatches; i++) {
 	/* Eliminate the primary inputs that do not appear in other parts. */
@@ -815,7 +815,7 @@
     if (option->traverse == FALSE || net->nlatches == 0) return(1);
     (void) printf("Building transition relation. Time = %s\n",
 		  util_print_time(util_cpu_time() - option->initialTime));
-    one = Cudd_ReadOne(dd);
+    one = Cudd_ReadTrue(dd);
     zero = Cudd_Not(one);
 
     /* Build transition relation and initial states. */
@@ -975,7 +975,7 @@
     if (option->scc == FALSE || net->nlatches == 0) return(1);
     (void) printf("Building transition relation. Time = %s\n",
 		  util_print_time(util_cpu_time() - option->initialTime));
-    one = Cudd_ReadOne(dd);
+    one = Cudd_ReadTrue(dd);
     zero = Cudd_Not(one);
 
     /* Build transition relation and initial states. */
@@ -1401,7 +1401,7 @@
 	res = Dddmp_cuddBddLoad(dd, DDDMP_VAR_MATCHIDS, NULL, NULL, NULL,
 				DDDMP_MODE_DEFAULT, option->loadfile, NULL);
     } else {
-	one = Cudd_ReadOne(dd);
+	one = Cudd_ReadTrue(dd);
 	Cudd_Ref(res = one);
 
 	if (net->nlatches == 0) return(res);
@@ -1471,7 +1471,7 @@
     DdNode *x;
     char c[2];
 
-    cube = Cudd_ReadOne(dd);
+    cube = Cudd_ReadTrue(dd);
     if (net->nlatches == 0) {
 	Cudd_Ref(cube);
 	return(cube);
@@ -1585,7 +1585,7 @@
     y = TR->y;
     ns = TR->nlatches;
 
-    one = Cudd_ReadOne(dd);
+    one = Cudd_ReadTrue(dd);
     zero = Cudd_Not(one);
     retval = Cudd_SetVarMap(dd,x,y,ns);
 
@@ -1775,7 +1775,7 @@
     DdNode *res, *w, *one;
     int i;
 
-    one = Cudd_ReadOne(dd);
+    one = Cudd_ReadTrue(dd);
     Cudd_Ref(res = one);
 
     for (i = n-1; i >= 0; i--) {
@@ -2554,7 +2554,7 @@
 
     nparts = T->nparts;
     nvars = Cudd_ReadSize(dd);
-    one = Cudd_ReadOne(dd);
+    one = Cudd_ReadTrue(dd);
 
     /* Reinitialize the abstraction cubes. */
     Cudd_RecursiveDeref(dd,T->preiabs);
diff -Nru a/nanotrav/ntr.h b/nanotrav/ntr.h
--- a/nanotrav/ntr.h	2016-01-20 23:04:27.000000000 +0100
+++ b/nanotrav/ntr.h	2024-05-03 15:06:21.848493320 +0200
@@ -44,7 +44,7 @@
   ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   POSSIBILITY OF SUCH DAMAGE.]
 
-  Revision    [$Id: ntr.h,v 1.26 2004/08/13 18:28:28 fabio Exp fabio $]
+  Revision    [$Id: ntr.h,v 1.1.2.1 2010-02-04 10:41:20 nusmv Exp $]
 
 ******************************************************************************/
 
@@ -143,9 +143,15 @@
     int		locGlob;	/* build global or local BDDs */
     int		progress;	/* report output names while building BDDs */
     int		cacheSize;	/* computed table initial size */
-    unsigned long maxMemory;	/* target maximum memory */
-    unsigned long maxMemHard;	/* maximum allowed memory */
-    unsigned int maxLive;	/* maximum number of nodes */
+  /* NuSMV: add begin */
+    ptruint     maxMemory;	/* target maximum memory */
+    ptruint     maxMemHard;	/* maximum allowed memory */
+    ptruint     maxLive;	/* maximum number of nodes */
+    /* WAS: unsigned long maxMemory;	target maximum memory
+            unsigned long maxMemHard;	maximum allowed memory
+            unsigned int maxLive;	maximum number of nodes */
+  /* NuSMV: add end */
+
     int		slots;		/* unique subtable initial slots */
     int		ordering;	/* FANIN DFS ... */
     char	*orderPiPs;	/* file for externally provided order */
diff -Nru a/nanotrav/ntrHeap.c b/nanotrav/ntrHeap.c
--- a/nanotrav/ntrHeap.c	2016-01-20 23:04:27.000000000 +0100
+++ b/nanotrav/ntrHeap.c	2024-05-03 15:06:21.848493320 +0200
@@ -68,7 +68,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] UTIL_UNUSED = "$Id: ntrHeap.c,v 1.5 2004/08/13 18:28:28 fabio Exp fabio $";
+static char rcsid[] UTIL_UNUSED = "$Id: ntrHeap.c,v 1.1.2.1 2010-02-04 10:41:20 nusmv Exp $";
 #endif
 
 /*---------------------------------------------------------------------------*/
diff -Nru a/nanotrav/ntrMflow.c b/nanotrav/ntrMflow.c
--- a/nanotrav/ntrMflow.c	2016-01-20 23:04:27.000000000 +0100
+++ b/nanotrav/ntrMflow.c	2024-05-03 15:06:21.848493320 +0200
@@ -83,7 +83,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] UTIL_UNUSED = "$Id: ntrMflow.c,v 1.6 2004/08/13 18:28:28 fabio Exp fabio $";
+static char rcsid[] UTIL_UNUSED = "$Id: ntrMflow.c,v 1.1.2.1 2010-02-04 10:41:20 nusmv Exp $";
 #endif
 
 static DdNode *xcube, *ycube, *zcube;
@@ -196,7 +196,7 @@
     U   = ALLOC(DdNode *, ((unsigned) MAXLAYER));
     neW = ALLOC(DdNode *, ((unsigned) MAXLAYER));
 
-    one = Cudd_ReadOne(bdd);
+    one = Cudd_ReadTrue(bdd);
     zero = Cudd_Not(one);
 
     /* Initialize xcube, ycube, and zcube (for abstractions). */
@@ -456,7 +456,7 @@
 
     pr = stats->pr;
 
-    one = Cudd_ReadOne(bdd);
+    one = Cudd_ReadTrue(bdd);
     zero = Cudd_Not(one);
 
     /* The useful edges of the last layer are all the empty edges into
@@ -635,7 +635,7 @@
 
     pr = stats->pr;
 
-    one = Cudd_ReadOne(bdd);
+    one = Cudd_ReadTrue(bdd);
     zero = Cudd_Not(one);
 
     /*Uout(x,y)=U^m(x,y)*/
@@ -775,7 +775,7 @@
 
     pr = stats->pr;
 
-    one = Cudd_ReadOne(bdd);
+    one = Cudd_ReadTrue(bdd);
     zero = Cudd_Not(one);
 
     /*Uout(x,y)=U^m(x,y)*/
@@ -908,7 +908,7 @@
 
     pr = stats->pr;
 
-    one = Cudd_ReadOne(bdd);
+    one = Cudd_ReadTrue(bdd);
     zero = Cudd_Not(one);
 
     /* Build priority function. */
@@ -1069,7 +1069,7 @@
 
     pr = stats->pr;
 
-    one = Cudd_ReadOne(bdd);
+    one = Cudd_ReadTrue(bdd);
     zero = Cudd_Not(one);
 
     if (l == 0) {
@@ -1221,7 +1221,7 @@
 
     pr = stats->pr;
 
-    one = Cudd_ReadOne(bdd);
+    one = Cudd_ReadTrue(bdd);
     zero = Cudd_Not(one);
 
     /*Uout(x,y)=U^m(x,y)*/
@@ -1340,7 +1340,7 @@
 
     pr = stats->pr;
 
-    one = Cudd_ReadOne(bdd);
+    one = Cudd_ReadTrue(bdd);
     zero = Cudd_Not(one);
 
     /*Uout(x,y)=U^m(x,y)*/
@@ -1461,7 +1461,7 @@
 
     pr = stats->pr;
 
-    one = Cudd_ReadOne(bdd);
+    one = Cudd_ReadTrue(bdd);
     zero = Cudd_Not(one);
 
     /* Build priority function. */
diff -Nru a/nanotrav/ntrShort.c b/nanotrav/ntrShort.c
--- a/nanotrav/ntrShort.c	2016-01-20 23:04:27.000000000 +0100
+++ b/nanotrav/ntrShort.c	2024-05-03 15:06:21.851826692 +0200
@@ -66,7 +66,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] UTIL_UNUSED = "$Id: ntrShort.c,v 1.4 2004/08/13 18:28:28 fabio Exp fabio $";
+static char rcsid[] UTIL_UNUSED = "$Id: ntrShort.c,v 1.1.2.1 2010-02-04 10:41:20 nusmv Exp $";
 #endif
 
 /*---------------------------------------------------------------------------*/
@@ -147,13 +147,13 @@
     q = Cudd_BddToAdd(dd,TR->part[0]);
     Cudd_Ref(q);
     /* ...replacing zeroes with infinities... */
-    r = Cudd_addIte(dd,q,Cudd_ReadOne(dd),Cudd_ReadPlusInfinity(dd));
+    r = Cudd_addIte(dd,q,Cudd_ReadTrue(dd),Cudd_ReadPlusInfinity(dd));
     Cudd_Ref(r);
     Cudd_RecursiveDeref(dd,q);
     /* ...and zeroing the diagonal. */
     q = Cudd_addXeqy(dd,nvars,xadd,yadd);
     Cudd_Ref(q);
-    edges = Cudd_addIte(dd,q,Cudd_ReadZero(dd),r);
+    edges = Cudd_addIte(dd,q,Cudd_ReadFalse(dd),r);
     Cudd_Ref(edges);
     Cudd_RecursiveDeref(dd,r);
     Cudd_RecursiveDeref(dd,q);
@@ -299,7 +299,7 @@
 
     /* The initial states are at distance 0. The other states are
     ** initially at infinite distance. */
-    V = Cudd_addIte(dd,source,Cudd_ReadZero(dd),Cudd_ReadPlusInfinity(dd));
+    V = Cudd_addIte(dd,source,Cudd_ReadFalse(dd),Cudd_ReadPlusInfinity(dd));
     Cudd_Ref(V);
 
     /* Selective trace algorithm.  For the next update, only consider the
@@ -393,9 +393,9 @@
 	nodes = 1000000000;
     else
 	nodes = 1 << vars;
-
-    one = DD_ONE(dd);
-    zero = DD_ZERO(dd);
+#warning [AMa] Check if 0/1 are ok
+    one = DD_TRUE(dd);
+    zero = DD_FALSE(dd);
     Cudd_Ref(R = D);                        /* make copy of original matrix */
 
     /* Extract pivot row and column from D */
@@ -485,7 +485,7 @@
     int neg;
     long start_time;
 
-    zero = Cudd_ReadZero(dd);
+    zero = Cudd_ReadFalse(dd);
     /* Make a working copy of the original matrix. */
     R = D;
     Cudd_Ref(R);
diff -Nru a/nanotrav/ntrZddTest.c b/nanotrav/ntrZddTest.c
--- a/nanotrav/ntrZddTest.c	2016-01-20 23:04:27.000000000 +0100
+++ b/nanotrav/ntrZddTest.c	2024-05-03 15:06:21.851826692 +0200
@@ -66,7 +66,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] UTIL_UNUSED = "$Id: ntrZddTest.c,v 1.14 2004/08/13 18:28:28 fabio Exp fabio $";
+static char rcsid[] UTIL_UNUSED = "$Id: ntrZddTest.c,v 1.1.2.1 2010-02-04 10:41:20 nusmv Exp $";
 #endif
 
 /*---------------------------------------------------------------------------*/
diff -Nru a/nanotrav/README b/nanotrav/README
--- a/nanotrav/README	2016-01-20 23:04:27.000000000 +0100
+++ b/nanotrav/README	2024-05-03 15:06:21.848493320 +0200
@@ -1,4 +1,4 @@
-$Id: README,v 1.8 1997/01/23 07:33:22 fabio Exp fabio $
+$Id: README,v 1.1.2.1 2010-02-04 10:41:20 nusmv Exp $
 
 WHAT IS NANOTRAV
 ================
diff -Nru a/nanotrav/tst.sh b/nanotrav/tst.sh
--- a/nanotrav/tst.sh	2016-01-20 23:04:27.000000000 +0100
+++ b/nanotrav/tst.sh	2024-05-03 15:06:21.851826692 +0200
@@ -1,6 +1,6 @@
 #! /bin/sh
 #
-# $Id: tst.sh,v 1.2 1998/05/03 08:41:38 fabio Exp fabio $
+# $Id: tst.sh,v 1.1.2.1 2010-02-04 10:41:20 nusmv Exp $
 #
 ./nanotrav -p 1 -cover C17.blif > C17.tst
 ./nanotrav -p 1 -ordering dfs -autodyn -automethod sifting -reordering sifting -drop C880.blif > C880.tst
diff -Nru a/nanotrav/ucbqsort.c b/nanotrav/ucbqsort.c
--- a/nanotrav/ucbqsort.c	2016-01-20 23:04:27.000000000 +0100
+++ b/nanotrav/ucbqsort.c	2024-05-03 15:06:21.851826692 +0200
@@ -5,7 +5,7 @@
 #endif
 
 #ifndef lint
-static char rcsid[] UNUSED = "$Id: ucbqsort.c,v 1.4 2004/01/01 07:06:06 fabio Exp fabio $";
+static char rcsid[] UNUSED = "$Id: ucbqsort.c,v 1.1.2.1 2010-02-04 10:41:20 nusmv Exp $";
 #endif
 
 /* @(#)qsort.c	4.2 (Berkeley) 3/9/83 */
diff -Nru a/obj/cuddObj.cc b/obj/cuddObj.cc
--- a/obj/cuddObj.cc	2016-01-20 23:04:27.000000000 +0100
+++ b/obj/cuddObj.cc	2024-05-03 15:06:21.851826692 +0200
@@ -53,7 +53,7 @@
 // ---------------------------------------------------------------------------
 
 #ifndef lint
-static char rcsid[] UTIL_UNUSED = "$Id: cuddObj.cc,v 1.9 2004/08/24 19:56:19 fabio Exp fabio $";
+static char rcsid[] UTIL_UNUSED = "$Id: cuddObj.cc,v 1.1.2.1 2010-02-04 10:41:21 nusmv Exp $";
 #endif
 
 // ---------------------------------------------------------------------------
diff -Nru a/obj/cuddObj.hh b/obj/cuddObj.hh
--- a/obj/cuddObj.hh	2016-01-20 23:04:27.000000000 +0100
+++ b/obj/cuddObj.hh	2024-05-03 15:06:21.851826692 +0200
@@ -46,7 +46,7 @@
   ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
   POSSIBILITY OF SUCH DAMAGE.]
 
-  Revision    [$Id: cuddObj.hh,v 1.8 2004/08/24 19:56:19 fabio Exp fabio $]
+  Revision    [$Id: cuddObj.hh,v 1.1.2.1 2010-02-04 10:41:21 nusmv Exp $]
 
 ******************************************************************************/
 
diff -Nru a/obj/testobj.cc b/obj/testobj.cc
--- a/obj/testobj.cc	2016-01-20 23:04:27.000000000 +0100
+++ b/obj/testobj.cc	2024-05-03 15:06:21.851826692 +0200
@@ -54,7 +54,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] UTIL_UNUSED = "$Id: testobj.cc,v 1.5 2004/08/13 18:11:07 fabio Exp fabio $";
+static char rcsid[] UTIL_UNUSED = "$Id: testobj.cc,v 1.1.2.1 2010-02-04 10:41:21 nusmv Exp $";
 #endif
 
 /*---------------------------------------------------------------------------*/
diff -Nru a/README b/README
--- a/README	2016-01-20 23:04:27.000000000 +0100
+++ b/README	2024-05-03 15:06:21.835159836 +0200
@@ -1,4 +1,4 @@
-$Id$
+$Id: README,v 1.1.2.1 2010-02-04 10:41:15 nusmv Exp $
 
 This directory contains a set of packages that allow you to build a toy
 application based on the CUDD package.
diff -Nru a/setup.sh b/setup.sh
--- a/setup.sh	2016-01-20 23:04:27.000000000 +0100
+++ b/setup.sh	2024-05-03 15:06:21.851826692 +0200
@@ -1,18 +1,38 @@
 #! /bin/sh
-CREATE="ln -s"
-if test -d include
-  then
-    :
-  else
-    mkdir include
-    cd include
-    $CREATE ../cudd/cudd.h .
-    $CREATE ../cudd/cuddInt.h .
-    $CREATE ../epd/epd.h .
-    $CREATE ../dddmp/dddmp.h .
-    $CREATE ../mtr/mtr.h .
-    $CREATE ../obj/cuddObj.hh .
-    $CREATE ../st/st.h .
-    $CREATE ../util/util.h .
-    $CREATE ../mnemosyne/mnemosyne.h .
+
+CREATE="ln -f -s"
+
+HEADERS="cudd/cudd.h cudd/cuddInt.h dddmp/dddmp.h mtr/mtr.h st/st.h \
+    util/util.h ../epd/epd.h obj/cuddObj.hh mnemosyne/mnemosyne.h"
+
+LIBS="cudd/libcudd.a mtr/libmtr.a st/libst.a util/libutil.a"
+INCLUDE_DIR=include/cudd
+
+printf "Setting up cudd...  "
+if [ ! -d $INCLUDE_DIR ]; then
+    mkdir -p $INCLUDE_DIR
 fi
+cd $INCLUDE_DIR
+for file in $HEADERS; do
+    if [ ! -h `basename $file` ] && [ -f ../../$file ]; then 
+	$CREATE ../../$file .
+    fi
+done 
+cd -
+
+
+if [ ! -d lib ]; then 
+    mkdir lib
+fi
+cd lib
+for file in $LIBS; do
+    if [ ! -h `basename $file` ] && [ -f ../$file ]; then 
+	$CREATE ../$file .
+    fi
+done 
+if [ -f libutil.a ]; then
+    mv libutil.a libcudd_util.a
+fi
+cd ..
+
+printf "Done\n"
diff -Nru a/shutdown.sh b/shutdown.sh
--- a/shutdown.sh	2016-01-20 23:04:27.000000000 +0100
+++ b/shutdown.sh	2024-05-03 15:06:21.851826692 +0200
@@ -1,2 +1,2 @@
 #! /bin/sh
-rm -rf include *.bak *~
+rm -rf lib/* include *.bak *~
diff -Nru a/sis/cuddBdd.h b/sis/cuddBdd.h
--- a/sis/cuddBdd.h	2016-01-20 23:04:27.000000000 +0100
+++ b/sis/cuddBdd.h	2024-05-03 15:06:21.851826692 +0200
@@ -30,7 +30,7 @@
   "AS IS" BASIS, AND THE UNIVERSITY OF COLORADO HAS NO OBLIGATION TO PROVIDE
   MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.]
 
-  Revision    [$Id: cuddBdd.h,v 1.2 1996/07/30 20:42:04 bobbie Exp $]
+  Revision    [$Id: cuddBdd.h,v 1.1.2.1 2010-02-04 10:41:21 nusmv Exp $]
 
 ******************************************************************************/
 
@@ -320,7 +320,7 @@
 extern bdd_t *bdd_minimize (bdd_t *, bdd_t *);
 extern bdd_t *bdd_minimize_with_params (bdd_t *, bdd_t *, bdd_min_match_type_t, boolean, boolean, boolean);
 extern bdd_t *bdd_not (bdd_t *);
-extern bdd_t *bdd_one (bdd_manager *);
+extern bdd_t *bdd_true (bdd_manager *);
 extern bdd_t *bdd_or (bdd_t *, bdd_t *, boolean, boolean);
 extern bdd_t *bdd_smooth (bdd_t *, array_t *);
 extern bdd_t *bdd_substitute (bdd_t *, array_t *, array_t *);
@@ -328,7 +328,7 @@
 extern bdd_t *bdd_top_var (bdd_t *);
 extern bdd_t *bdd_xnor (bdd_t *, bdd_t *);
 extern bdd_t *bdd_xor (bdd_t *, bdd_t *);
-extern bdd_t *bdd_zero (bdd_manager *);
+extern bdd_t *bdd_false (bdd_manager *);
 
 /*
  * Queries about BDD Formulas
diff -Nru a/sis/cuddBddPort.c b/sis/cuddBddPort.c
--- a/sis/cuddBddPort.c	2016-01-20 23:04:27.000000000 +0100
+++ b/sis/cuddBddPort.c	2024-05-03 15:06:21.851826692 +0200
@@ -72,7 +72,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddBddPort.c,v 1.11 1996/05/08 06:13:08 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddBddPort.c,v 1.1.2.1 2010-02-04 10:41:21 nusmv Exp $";
 #endif
 
 /*---------------------------------------------------------------------------*/
@@ -188,12 +188,12 @@
 {
     DdNode *var;
     DdManager *dd = (DdManager *) mgr;
-    DdNode *one = DD_ONE(dd);
+    DdNode *_true = DD_TRUE(dd);
 
     if (dd->size >= CUDD_MAXINDEX -1) return(NULL);
     do {
 	dd->reordered = 0;
-	var = cuddUniqueInter(dd,dd->size,one,Cudd_Not(one));
+	var = cuddUniqueInter(dd,dd->size,_true,Cudd_Not(_true));
     } while (dd->reordered == 1);
 
     if (var == NULL) return(NULL);
@@ -244,7 +244,7 @@
 {
     DdNode *var;
     DdManager *dd = (DdManager *) mgr;
-    DdNode *one = DD_ONE(dd);
+    DdNode *one = DD_TRUE(dd);
 
     if (variable_ID >= CUDD_MAXINDEX -1) return(NULL);
     do {
@@ -377,7 +377,7 @@
     ** in the array before calling the procedure.
     */
     mgr = (DdManager *)f->mgr;
-    Cudd_Ref(cube = DD_ONE(mgr));
+    Cudd_Ref(cube = DD_TRUE(mgr));
     for (i = 0; i < array_n(smoothing_vars); i++) {
 	variable = array_fetch(bdd_t *,smoothing_vars,i);
 
@@ -507,7 +507,7 @@
     ** in the array before calling the procedure.
     */
     mgr = f->mgr;
-    Cudd_Ref(cube = DD_ONE(mgr));
+    Cudd_Ref(cube = DD_TRUE(mgr));
     for (i = 0; i < array_n(quantifying_vars); i++) {
 	variable = array_fetch(bdd_t *,quantifying_vars,i);
 
@@ -573,7 +573,7 @@
     }
     dd = f->mgr;
 
-    cube = DD_ONE(dd);
+    cube = DD_TRUE(dd);
     cuddRef(cube);
     for (i = nvars - 1; i >= 0; i--) {
 	DdNode *tmpp;
@@ -726,16 +726,17 @@
   SideEffects []
 
 ******************************************************************************/
+#warning [AMa] Rename this function to bdd_true?
 bdd_t *
-bdd_one(mgr)
+bdd_true(mgr)
 bdd_manager *mgr;
 {
     DdNode *result;
 
-    Cudd_Ref(result = DD_ONE((DdManager *)mgr));
+    Cudd_Ref(result = DD_TRUE((DdManager *)mgr));
     return(bdd_construct_bdd_t((DdManager *)mgr,result));
 
-} /* end of bdd_one */
+} /* end of bdd_true */
 
 
 /**Function********************************************************************
@@ -804,7 +805,7 @@
     ** in the array before calling the procedure.
     */
     mgr = f->mgr;
-    Cudd_Ref(cube = DD_ONE(mgr));
+    Cudd_Ref(cube = DD_TRUE(mgr));
     for (i = 0; i < array_n(smoothing_vars); i++) {
 	variable = array_fetch(bdd_t *,smoothing_vars,i);
 
@@ -1025,16 +1026,17 @@
   SideEffects []
 
 ******************************************************************************/
+#warning [AMa] Rename this function to bdd_false?
 bdd_t *
-bdd_zero(mgr)
+bdd_false(mgr)
 bdd_manager *mgr;
 {
     DdNode *result;
 
-    Cudd_Ref(result = Cudd_Not(DD_ONE((mgr))));
+    Cudd_Ref(result = Cudd_Not(DD_TRUE((mgr))));
     return(bdd_construct_bdd_t(mgr,result));
 
-} /* end of bdd_zero */
+} /* end of bdd_false */
 
 
 /**Function********************************************************************
@@ -1092,9 +1094,9 @@
 boolean phase;
 {
     if (phase) {
-	return(f->node == DD_ONE(f->mgr));
+	return(f->node == DD_TRUE(f->mgr));
     } else {
-	return(f->node == Cudd_Not(DD_ONE(f->mgr)));
+	return(f->node == Cudd_Not(DD_TRUE(f->mgr)));
     }
 
 } /* end of bdd_is_tautology */
diff -Nru a/sis/cuddPwPt.c b/sis/cuddPwPt.c
--- a/sis/cuddPwPt.c	2016-01-20 23:04:27.000000000 +0100
+++ b/sis/cuddPwPt.c	2024-05-03 15:06:21.851826692 +0200
@@ -12,8 +12,8 @@
   equivalent functionality are provided here.
 	External procedures included in this file:
 		<ul>
-		<li> cmu_bdd_zero()
-		<li> cmu_bdd_one()
+		<li> cmu_bdd_false()
+		<li> cmu_bdd_true()
 		<li> cmu_bdd_if_index()
 		</ul>
 	Internal procedures included in this module:
@@ -53,7 +53,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] DD_UNUSED = "$Id: cuddPwPt.c,v 1.3 1997/01/18 19:43:19 fabio Exp $";
+static char rcsid[] DD_UNUSED = "$Id: cuddPwPt.c,v 1.1.2.1 2010-02-04 10:41:21 nusmv Exp $";
 #endif
 
 /*---------------------------------------------------------------------------*/
@@ -87,12 +87,12 @@
 
 ******************************************************************************/
 bdd_node *
-cmu_bdd_one(dd)
+cmu_bdd_true(dd)
 bdd_manager *dd;
 {
     return((bdd_node *)((DdManager *)dd)->one);
 
-} /* end of cmu_bdd_one */
+} /* end of cmu_bdd_true */
 
 
 /**Function********************************************************************
@@ -108,12 +108,12 @@
 
 ******************************************************************************/
 bdd_node *
-cmu_bdd_zero(dd)
+cmu_bdd_false(dd)
 bdd_manager *dd;
 {
     return((bdd_node *)Cudd_Not(((DdManager *)dd)->one));
 
-} /* end of cmu_bdd_zero */
+} /* end of cmu_bdd_false */
 
 
 /**Function********************************************************************
diff -Nru a/sis/st.c b/sis/st.c
--- a/sis/st.c	2016-01-20 23:04:27.000000000 +0100
+++ b/sis/st.c	2024-05-03 15:06:21.851826692 +0200
@@ -12,8 +12,14 @@
 #include "st.h"
 
 #define ST_NUMCMP(x,y) ((x) != (y))
-#define ST_NUMHASH(x,size) (ABS((long)x)%(size))
-#define ST_PTRHASH(x,size) ((int)((unsigned long)(x)>>2)%size)
+
+/* NuSMV: add begin */
+#define ST_NUMHASH(x,size) (ABS((ptruint)x)%(size))
+#define ST_PTRHASH(x,size) ((int)((ptruint)(x)>>2)%size)
+  /* WAS: #define ST_NUMHASH(x,size) (ABS((long)x)%(size))
+          #define ST_PTRHASH(x,size) ((int)((unsigned long)(x)>>2)%size)  */
+/* NuSMV: add end */
+
 #define EQUAL(func, x, y) \
     ((((func) == st_numcmp) || ((func) == st_ptrcmp)) ?\
       (ST_NUMCMP((x),(y)) == 0) : ((*func)((x), (y)) == 0))
@@ -519,7 +525,7 @@
     return 1;
 }
 
-
+#warning [AMi] Why long*?? We should use ptrint* instead...
 int 
 st_gen_int(st_generator *gen, char **key_p, long *value_p)
 {
diff -Nru a/st/Makefile b/st/Makefile
--- a/st/Makefile	2016-01-20 23:04:27.000000000 +0100
+++ b/st/Makefile	2024-05-03 15:06:21.851826692 +0200
@@ -1,4 +1,4 @@
-# $Id: Makefile,v 1.3 2004/01/01 06:53:06 fabio Exp fabio $
+# $Id: Makefile,v 1.1.2.1 2010-02-04 10:41:21 nusmv Exp $
 #
 # st -- hash table package
 #---------------------------------------------------------------------------
@@ -61,4 +62,4 @@
 	rm -f *.o *.u .pure *.warnings
 
 distclean: clean
-	rm -f lib*.a lib$(P).b llib-l$(P).ln tags *~ *.bak *.qv *.qx
+	rm -f lib*.a lib$(P).b llib-l$(P).ln TAGS tags *~ *.bak *.qv *.qx
diff -Nru a/st/st.c b/st/st.c
--- a/st/st.c	2016-01-20 23:04:27.000000000 +0100
+++ b/st/st.c	2024-05-03 15:06:21.851826692 +0200
@@ -37,7 +37,7 @@
 /*---------------------------------------------------------------------------*/
 
 #ifndef lint
-static char rcsid[] UTIL_UNUSED = " $Id: st.c,v 1.11 2004/02/11 22:31:59 fabio Exp fabio $";
+static char rcsid[] UTIL_UNUSED = " $Id: st.c,v 1.1.2.1 2010-02-04 10:41:21 nusmv Exp $";
 #endif
 
 /*---------------------------------------------------------------------------*/
@@ -46,15 +46,21 @@
 
 #define ST_NUMCMP(x,y) ((x) != (y))
 
-#define ST_NUMHASH(x,size) (ABS((long)x)%(size))
+/* NuSMV: add begin */
+#define ST_NUMHASH(x,size) (ABS((util_ptrint)x)%(size))
+  /* WAS: #define ST_NUMHASH(x,size) (ABS((long)x)%(size)) */
+/* NuSMV: add end */
 
-#if SIZEOF_VOID_P == 8
+#if NUSMV_SIZEOF_VOID_P == 8
 #define st_shift 3
 #else
 #define st_shift 2
 #endif
 
-#define ST_PTRHASH(x,size) ((unsigned int)((unsigned long)(x)>>st_shift)%size)
+/* NuSMV: add begin */
+#define ST_PTRHASH(x,size) ((unsigned int)((util_ptruint)(x)>>st_shift)%size)
+  /* WAS: #define ST_PTRHASH(x,size) ((unsigned int)((unsigned long)(x)>>st_shift)%size) */
+/* NuSMV: add end */
 
 #define EQUAL(func, x, y) \
     ((((func) == st_numcmp) || ((func) == st_ptrcmp)) ?\
@@ -332,7 +338,10 @@
 	return 0;
     } else {
 	if (value != NIL(int)) {
-	    *value = (int) (long) ptr->record;
+          /* NuSMV: add begin */
+	    *value = (int) (util_ptrint) ptr->record;
+              /* WAS: *value = (int) (long) ptr->record; */
+            /* NuSMV: add end */
 	}
 	return 1;
     }
@@ -687,7 +696,10 @@
     }
 
     *last = ptr->next;
-    if (value != NIL(int)) *value = (int) (long) ptr->record;
+    /* NuSMV: add begin */
+    if (value != NIL(int)) *value = (int) (util_ptrint) ptr->record;
+      /* WAS: if (value != NIL(int)) *value = (int) (long) ptr->record; */
+    /* NuSMV: add end */
     *(char **)keyp = ptr->key;
     FREE(ptr);
     table->num_entries--;
@@ -969,7 +981,10 @@
     }
     *(char **)key_p = gen->entry->key;
     if (value_p != NIL(int)) {
-   	*value_p = (int) (long) gen->entry->record;
+      /* NuSMV: add begin */
+   	*value_p = (int) (util_ptrint) gen->entry->record;
+          /* WAS: *value_p = (int) (long) gen->entry->record; */
+        /* NuSMV: add end */
     }
     gen->entry = gen->entry->next;
     return 1;
diff -Nru a/st/st.h b/st/st.h
--- a/st/st.h	2016-01-20 23:04:27.000000000 +0100
+++ b/st/st.h	2024-05-03 15:06:21.851826692 +0200
@@ -15,7 +15,7 @@
 
   Copyright   []
 
-  Revision    [$Id: st.h,v 1.10 2004/01/02 07:40:31 fabio Exp fabio $]
+  Revision    [$Id: st.h,v 1.1.2.1 2010-02-04 10:41:21 nusmv Exp $]
 
 ******************************************************************************/
 
diff -Nru a/util/cpu_stats.c b/util/cpu_stats.c
--- a/util/cpu_stats.c	2016-01-20 23:04:27.000000000 +0100
+++ b/util/cpu_stats.c	2024-05-03 15:06:21.851826692 +0200
@@ -1,9 +1,10 @@
 /* LINTLIBRARY */
 
+#include <stdio.h>
 #include "util.h"
 
 
-#ifdef BSD
+#if defined(BSD) && !defined(__CYGWIN__) && !defined(__MINGW32__) && !defined(__MAC_OS_X__) && !defined(_MSC_VER)
 #include <sys/types.h>
 #include <sys/time.h>
 #include <sys/resource.h>
@@ -18,10 +19,15 @@
 
 #endif
 
-void
-util_print_cpu_stats(FILE *fp)
+
+void util_print_cpu_stats(FILE *fp)
 {
-#ifdef BSD
+  /* NuSMV: removed begin */
+  /* #ifdef BSD */
+  /* NuSMV: removed end */
+  /* NuSMV: added begin */
+  #if defined(BSD) && !defined(__CYGWIN__) && !defined(__MINGW32__) && !defined(__MAC_OS_X__) && !defined(_MSC_VER)
+  /* NuSMV: added end */
     struct rusage rusage;
     struct rlimit rlp;
     int text, data, vm_limit, vm_soft_limit;
@@ -54,8 +60,16 @@
     (void) fprintf(fp, "Runtime Statistics\n");
     (void) fprintf(fp, "------------------\n");
     (void) fprintf(fp, "Machine name: %s\n", hostname);
+    /* NuSMV: added begin */
+#if 0
+    /* NuSMV: added end */
     (void) fprintf(fp, "User time   %6.1f seconds\n", user);
     (void) fprintf(fp, "System time %6.1f seconds\n\n", system);
+    /* NuSMV: added begin */
+#endif
+    (void) fprintf(fp, "User time   %6.3f seconds\n", user);
+    (void) fprintf(fp, "System time %6.3f seconds\n\n", system);
+    /* NuSMV: added end */
 
     text = (int) (rusage.ru_ixrss / scale + 0.5);
     data = (int) ((rusage.ru_idrss + rusage.ru_isrss) / scale + 0.5);
diff -Nru a/util/cpu_time.c b/util/cpu_time.c
--- a/util/cpu_time.c	2016-01-20 23:04:27.000000000 +0100
+++ b/util/cpu_time.c	2024-05-03 15:06:21.851826692 +0200
@@ -8,12 +8,16 @@
 #define BSD
 #endif
 
-#ifdef BSD
+#if defined BSD && !defined __MINGW32__ && !defined(_MSC_VER)
 #include <sys/types.h>
 #include <sys/time.h>
 #include <sys/resource.h>
 #endif
 
+#if defined __MINGW32__ || defined(_MSC_VER)
+#include <time.h>
+#endif
+
 #if defined(UNIX60) || defined(UNIX100) || defined(__CYGWIN32__)
 #include <sys/types.h>
 #include <sys/times.h>
@@ -30,21 +34,36 @@
  *   util_cpu_time -- return a long which represents the elapsed processor
  *   time in milliseconds since some constant reference
  */
-long 
-util_cpu_time()
+long util_cpu_time()
 {
     long t = 0;
 
-#ifdef BSD
+#if defined BSD && ! defined __MINGW32__ && !defined(_MSC_VER)
     struct rusage rusage;
     (void) getrusage(RUSAGE_SELF, &rusage);
     t = (long) rusage.ru_utime.tv_sec*1000 + rusage.ru_utime.tv_usec/1000;
+    (void) getrusage(RUSAGE_CHILDREN, &rusage);
+    t += (long) rusage.ru_utime.tv_sec*1000 + rusage.ru_utime.tv_usec/1000;
+#endif
+
+#if (defined(__MINGW32__) || defined(_MSC_VER)) && !defined(UNDER_CE)
+    t = (long) (((double) clock()) / CLOCKS_PER_SEC * 1000);
+#endif
+
+#if defined __MINGW32__ && defined UNDER_CE
+    {
+      long ltime;
+      (void) time(&ltime);
+      t = ltime * 1000;
+    }
 #endif
 
 #ifdef IBMPC
-    long ltime;
-    (void) time(&ltime);
-    t = ltime * 1000;
+    {
+      long ltime;
+      (void) time(&ltime);
+      t = ltime * 1000;
+    }
 #endif
 
 #ifdef UNIX60			/* times() with 60 Hz resolution */
diff -Nru a/util/datalimit.c b/util/datalimit.c
--- a/util/datalimit.c	2016-01-20 23:04:27.000000000 +0100
+++ b/util/datalimit.c	2024-05-03 15:06:21.851826692 +0200
@@ -1,4 +1,4 @@
-/* $Id: datalimit.c,v 1.4 2003/08/01 16:25:20 fabio Exp fabio $ */
+/* $Id: datalimit.c,v 1.1.2.1 2010-02-04 10:41:22 nusmv Exp $ */
 
 #ifndef HAVE_SYS_RESOURCE_H
 #define HAVE_SYS_RESOURCE_H 1
@@ -10,7 +10,7 @@
 #define HAVE_GETRLIMIT 1
 #endif
 
-#if HAVE_SYS_RESOURCE_H == 1
+#if HAVE_SYS_RESOURCE_H == 1 && !defined(__MINGW32__) && !defined(_MSC_VER)
 #if HAVE_SYS_TIME_H == 1
 #include <sys/time.h>
 #endif
@@ -31,20 +31,21 @@
 
 EXTERN long getSoftDataLimit(void);
 
-long
-getSoftDataLimit(void)
+long getSoftDataLimit(void)
 {
-#if HAVE_SYS_RESOURCE_H == 1 && HAVE_GETRLIMIT == 1 && defined(RLIMIT_DATA)
-    struct rlimit rl;
-    int result;
+#if defined(__MINGW32__)
+  return RLIMIT_DATA_DEFAULT;
 
-    result = getrlimit(RLIMIT_DATA, &rl);
-    if (result != 0 || rl.rlim_cur == RLIM_INFINITY)
-	return((long) RLIMIT_DATA_DEFAULT);
-    else
-	return((long) rl.rlim_cur);
+#elif HAVE_SYS_RESOURCE_H == 1 && HAVE_GETRLIMIT == 1 && defined(RLIMIT_DATA)
+	struct rlimit rl;
+	long result;
+
+	result = (long) getrlimit(RLIMIT_DATA, &rl);
+	if (result != 0 || rl.rlim_cur == RLIM_INFINITY) {
+		return((long) RLIMIT_DATA_DEFAULT);
+	}
+	else return((long) rl.rlim_cur);
 #else
-    return((long) RLIMIT_DATA_DEFAULT);
+	return((long) RLIMIT_DATA_DEFAULT);
 #endif
-
 } /* end of getSoftDataLimit */
diff -Nru a/util/getopt.c b/util/getopt.c
--- a/util/getopt.c	2016-01-20 23:04:27.000000000 +0100
+++ b/util/getopt.c	2024-05-03 15:06:21.851826692 +0200
@@ -15,58 +15,58 @@
  *  Purpose: get option letter from argv.
  */
 
-char *util_optarg;	/* Global argument pointer. */
-int util_optind = 0;	/* Global argv index. */
+/* char *util_optarg;	/\* Global argument pointer. *\/ */
+/* int util_optind = 0;	/\* Global argv index. *\/ */
 static char *scan;
 
 
-void
-util_getopt_reset()
-{
-    util_optarg = 0;
-    util_optind = 0;
-    scan = 0;
-}
+/* void */
+/* util_getopt_reset() */
+/* { */
+/*     util_optarg = 0; */
+/*     util_optind = 0; */
+/*     scan = 0; */
+/* } */
 
 
 
-int 
-util_getopt(int argc, char *argv[], char *optstring)
-{
-    register int c;
-    register char *place;
-
-    util_optarg = NIL(char);
-
-    if (scan == NIL(char) || *scan == '\0') {
-	if (util_optind == 0) util_optind++;
-	if (util_optind >= argc) return EOF;
-	place = argv[util_optind];
-	if (place[0] != '-' || place[1] == '\0') return EOF;
-	util_optind++;
-	if (place[1] == '-' && place[2] == '\0') return EOF;
-	scan = place+1;
-    }
-
-    c = *scan++;
-    place = strchr(optstring, c);
-    if (place == NIL(char) || c == ':') {
-	(void) fprintf(stderr, "%s: unknown option %c\n", argv[0], c);
-	return '?';
-    }
-    if (*++place == ':') {
-	if (*scan != '\0') {
-	    util_optarg = scan;
-	    scan = NIL(char);
-	} else {
-	    if (util_optind >= argc) {
-		(void) fprintf(stderr, "%s: %c requires an argument\n", 
-		    argv[0], c);
-		return '?';
-	    }
-	    util_optarg = argv[util_optind];
-	    util_optind++;
-	}
-    }
-    return c;
-}
+/* int */
+/* util_getopt(int argc, char *argv[], char *optstring) */
+/* { */
+/*     register int c; */
+/*     register char *place; */
+
+/*     util_optarg = NIL(char); */
+
+/*     if (scan == NIL(char) || *scan == '\0') { */
+/* 	if (util_optind == 0) util_optind++; */
+/* 	if (util_optind >= argc) return EOF; */
+/* 	place = argv[util_optind]; */
+/* 	if (place[0] != '-' || place[1] == '\0') return EOF; */
+/* 	util_optind++; */
+/* 	if (place[1] == '-' && place[2] == '\0') return EOF; */
+/* 	scan = place+1; */
+/*     } */
+
+/*     c = *scan++; */
+/*     place = strchr(optstring, c); */
+/*     if (place == NIL(char) || c == ':') { */
+/* 	(void) fprintf(stderr, "%s: unknown option %c\n", argv[0], c); */
+/* 	return '?'; */
+/*     } */
+/*     if (*++place == ':') { */
+/* 	if (*scan != '\0') { */
+/* 	    util_optarg = scan; */
+/* 	    scan = NIL(char); */
+/* 	} else { */
+/* 	    if (util_optind >= argc) { */
+/* 		(void) fprintf(stderr, "%s: %c requires an argument\n", */
+/* 		    argv[0], c); */
+/* 		return '?'; */
+/* 	    } */
+/* 	    util_optarg = argv[util_optind]; */
+/* 	    util_optind++; */
+/* 	} */
+/*     } */
+/*     return c; */
+/* } */
diff -Nru a/util/Makefile b/util/Makefile
--- a/util/Makefile	2016-01-20 23:04:27.000000000 +0100
+++ b/util/Makefile	2024-05-03 15:06:21.851826692 +0200
@@ -1,4 +1,4 @@
-# $Id$
+# $Id: Makefile,v 1.1.2.1 2010-02-04 10:41:22 nusmv Exp $
 #
 # util -- miscellaneous utility routines
 #---------------------------------------------------------------------------
@@ -62,4 +63,4 @@
 	rm -f *.o *.u core *.warnings
 
 distclean: clean
-	rm -f lib$(P).a lib$(P).b llib-l$(P).ln tags *.bak *~ .pure
+	rm -f lib$(P).a lib$(P).b llib-l$(P).ln TAGS tags *.bak *~ .pure
diff -Nru a/util/pathsearch.c b/util/pathsearch.c
--- a/util/pathsearch.c	2016-01-20 23:04:27.000000000 +0100
+++ b/util/pathsearch.c	2024-05-03 15:06:21.851826692 +0200
@@ -8,7 +8,7 @@
 char *
 util_path_search(char *prog)
 {
-#ifdef UNIX
+#if defined(UNIX) && !defined(UNDER_CE)
     return util_file_search(prog, getenv("PATH"), (char *) "x");
 #else
     return util_file_search(prog, NIL(char), (char *) "x");
@@ -63,32 +63,31 @@
 }
 
 
-static int
-check_file(char *filename, char *mode)
+static int check_file(char *filename, char *mode)
 {
-#ifdef UNIX
-    int access_mode = /*F_OK*/ 0;
+#if defined(UNIX) && !defined(UNDER_CE)
+  int access_mode = /*F_OK*/ 0;
 
-    if (strcmp(mode, "r") == 0) {
-	access_mode = /*R_OK*/ 4;
-    } else if (strcmp(mode, "w") == 0) {
-	access_mode = /*W_OK*/ 2;
-    } else if (strcmp(mode, "x") == 0) {
-	access_mode = /*X_OK*/ 1;
-    }
-    return access(filename, access_mode) == 0;
+  if (strcmp(mode, "r") == 0) {
+    access_mode = /*R_OK*/ 4;
+  } else if (strcmp(mode, "w") == 0) {
+    access_mode = /*W_OK*/ 2;
+  } else if (strcmp(mode, "x") == 0) {
+    access_mode = /*X_OK*/ 1;
+  }
+  return access(filename, access_mode) == 0; 
 #else
-    FILE *fp;
-    int got_file;
+  FILE *fp;
+  int got_file;
 
-    if (strcmp(mode, "x") == 0) {
-	mode = "r";
-    }
-    fp = fopen(filename, mode);
-    got_file = (fp != 0);
-    if (fp != 0) {
-	(void) fclose(fp);
-    }
-    return got_file;
+  if (strcmp(mode, "x") == 0) {
+    mode = "r";
+  }
+  fp = fopen(filename, mode);
+  got_file = (fp != 0);
+  if (fp != 0) {
+    (void) fclose(fp);
+  }
+  return got_file;
 #endif
 }
diff -Nru a/util/pipefork.c b/util/pipefork.c
--- a/util/pipefork.c	2016-01-20 23:04:27.000000000 +0100
+++ b/util/pipefork.c	2024-05-03 15:06:21.851826692 +0200
@@ -1,13 +1,20 @@
 /*
  * Revision Control Information
  *
- * $Id: pipefork.c,v 1.6 2004/08/18 00:06:42 fabio Exp fabio $
+ * $Id: pipefork.c,v 1.1.2.1 2010-02-04 10:41:22 nusmv Exp $
  *
  */
 /* LINTLIBRARY */
 
 #include "util.h"
+
+#if !defined(__MINGW32__) && !defined(_MSC_VER)
 #include <sys/wait.h>
+#endif
+
+#if defined(__MINGW32__) && !defined(_MSC_VER)
+extern pid_t wait3 ARGS((int *statusp, int options, struct rusage *rusage));
+#endif
 
 /*
  * util_pipefork - fork a command and set up pipes to and from
@@ -22,72 +29,81 @@
  */
 
 /* ARGSUSED */
-int
-util_pipefork(
-  char **argv,		/* normal argv argument list */
-  FILE **toCommand,	/* pointer to the sending stream */
-  FILE **fromCommand,	/* pointer to the reading stream */
-  int *pid)
+int util_pipefork(char **argv,  /* normal argv argument list */
+          FILE **toCommand,  /* pointer to the sending stream */
+          FILE **fromCommand,  /* pointer to the reading stream */
+          int *pid)
 {
-#ifdef UNIX
+#if defined(UNIX) && !defined(__MINGW32__) && !defined(_MSC_VER)
     int forkpid, waitPid;
     int topipe[2], frompipe[2];
     char buffer[1024];
+
+/* 
+ * union wait removed since version 2.24
+ *  __GLIBC__ , __GLIBC_MINOR__ defined since version 6
+ */
+#   if (defined(__GNU_LIBRARY__) && __GNU_LIBRARY__ < 6) || (defined(__GLIBC__) \
+        && defined(__GLIBC_MINOR__) && __GLIBC__ <= 2 && __GLIBC_MINOR__ < 24)
+    union wait status;
+#   else  /* POSIX compliant */
     int status;
+#   endif
 
-    /* create the PIPES...
+    /* 
+     * create the PIPES...
      * fildes[0] for reading from command
      * fildes[1] for writing to command
      */
     (void) pipe(topipe);
     (void) pipe(frompipe);
 
-#ifdef __CYGWIN32__
+#   ifdef __CYGWIN32__
     if ((forkpid = fork()) == 0) {
-#else
+#   else
     if ((forkpid = vfork()) == 0) {
-#endif
-	/* child here, connect the pipes */
-	(void) dup2(topipe[0], fileno(stdin));
-	(void) dup2(frompipe[1], fileno(stdout));
-
-	(void) close(topipe[0]);
-	(void) close(topipe[1]);
-	(void) close(frompipe[0]);
-	(void) close(frompipe[1]);
-
-	(void) execvp(argv[0], argv);
-	(void) sprintf(buffer, "util_pipefork: can not exec %s", argv[0]);
-	perror(buffer);
-	(void) _exit(1);
+#   endif
+    /* child here, connect the pipes */
+        (void) dup2(topipe[0], fileno(stdin));
+        (void) dup2(frompipe[1], fileno(stdout));
+
+        (void) close(topipe[0]);
+        (void) close(topipe[1]);
+        (void) close(frompipe[0]);
+        (void) close(frompipe[1]);
+
+        (void) execvp(argv[0], argv);
+        (void) sprintf(buffer, "util_pipefork: can not exec %s", argv[0]);
+        perror(buffer);
+        (void) _exit(1);
     }
 
     if (pid) {
         *pid = forkpid;
     }
 
-#ifdef __CYGWIN32__
+#   ifdef __CYGWIN32__
     waitPid = waitpid(-1, &status, WNOHANG);
-#else
+#   else
     waitPid = wait3(&status, WNOHANG, NULL);
-#endif
+#   endif
 
     /* parent here, use slimey vfork() semantics to get return status */
     if (waitPid == forkpid && WIFEXITED(status)) {
-	return 0;
+        return 0;
     }
     if ((*toCommand = fdopen(topipe[1], "w")) == NULL) {
-	return 0;
+        return 0;
     }
     if ((*fromCommand = fdopen(frompipe[0], "r")) == NULL) {
-	return 0;
+        return 0;
     }
     (void) close(topipe[0]);
     (void) close(frompipe[1]);
     return 1;
 #else
-    (void) fprintf(stderr, 
-	"util_pipefork: not implemented on your operating system\n");
+    /* "RC: pipefork still not implemented for win32" */
+    (void) fprintf(stderr, "util_pipefork: not implemented on your operating system\n");
     return 0;
 #endif
 }
diff -Nru a/util/safe_mem.c b/util/safe_mem.c
--- a/util/safe_mem.c	2016-01-20 23:04:27.000000000 +0100
+++ b/util/safe_mem.c	2024-05-03 15:06:21.851826692 +0200
@@ -25,11 +25,11 @@
 extern "C" {
 #endif
 
-extern char *MMalloc(long);
-extern void MMout_of_memory(long);
-extern char *MMrealloc(char *, long);
+extern char *MMalloc(size_t);
+extern void MMout_of_memory(size_t);
+extern char *MMrealloc(char *, size_t);
 
-void (*MMoutOfMemory)(long) = MMout_of_memory;
+void (*MMoutOfMemory)(size_t) = MMout_of_memory;
 
 #ifdef __cplusplus
 }
@@ -38,28 +38,33 @@
 
 /* MMout_of_memory -- out of memory for lazy people, flush and exit */
 void 
-MMout_of_memory(long size)
+MMout_of_memory(size_t size)
 {
     (void) fflush(stdout);
-    (void) fprintf(stderr, "\nout of memory allocating %u bytes\n",
-		   (unsigned) size);
+    /* NuSMV: add begin */
+    (void) fprintf(stderr, "\nout of memory allocating %" PRIuPTR " bytes\n",
+                   (size_t) size);
+      /*WAS: (void) fprintf(stderr, "\nout of memory allocating %u bytes\n",
+                   (size_t) size); */
+    /* NuSMV: add end */
+
     exit(1);
 }
 
 
 char *
-MMalloc(long size)
+MMalloc(size_t size)
 {
     char *p;
 
 #ifdef IBMPC
     if (size > 65000L) {
-	if (MMoutOfMemory != (void (*)(long)) 0 ) (*MMoutOfMemory)(size);
+	if (MMoutOfMemory != (void (*)(size_t)) 0 ) (*MMoutOfMemory)(size);
 	return NIL(char);
     }
 #endif
     if (size == 0) size = sizeof(long);
-    if ((p = (char *) malloc((unsigned) size)) == NIL(char)) {
+    if ((p = (char *) malloc((size_t) size)) == NIL(char)) {
 	if (MMoutOfMemory != 0 ) (*MMoutOfMemory)(size);
 	return NIL(char);
     }
@@ -68,7 +73,7 @@
 
 
 char *
-MMrealloc(char *obj, long size)
+MMrealloc(char *obj, size_t size)
 {
     char *p;
 
@@ -80,7 +85,7 @@
 #endif
     if (obj == NIL(char)) return MMalloc(size);
     if (size <= 0) size = sizeof(long);
-    if ((p = (char *) realloc(obj, (unsigned) size)) == NIL(char)) {
+    if ((p = (char *) realloc(obj, (size_t) size)) == NIL(char)) {
 	if (MMoutOfMemory != 0 ) (*MMoutOfMemory)(size);
 	return NIL(char);
     }
diff -Nru a/util/state.c b/util/state.c
--- a/util/state.c	2016-01-20 23:04:27.000000000 +0100
+++ b/util/state.c	2024-05-03 15:06:21.851826692 +0200
@@ -11,7 +11,7 @@
 
 #else
 
-static char rcsid[] = "$Id: state.c,v 1.1 1997/11/04 22:38:50 fabio Exp $";
+static char rcsid[] = "$Id: state.c,v 1.1.2.1 2010-02-04 10:41:22 nusmv Exp $";
 
 #ifdef vax
 int util_restart_state[32];
diff -Nru a/util/strsav.c b/util/strsav.c
--- a/util/strsav.c	2016-01-20 23:04:27.000000000 +0100
+++ b/util/strsav.c	2024-05-03 15:06:21.851826692 +0200
@@ -8,7 +8,7 @@
  *  util_strsav -- save a copy of a string
  */
 char *
-util_strsav(char *s)
+util_strsav(const char *s)
 {
-    return strcpy(ALLOC(char, strlen(s)+1), s);
+  return s ? strcpy(ALLOC(char, strlen(s)+1), s) : NULL;
 }
diff -Nru a/util/texpand.c b/util/texpand.c
--- a/util/texpand.c	2016-01-20 23:04:27.000000000 +0100
+++ b/util/texpand.c	2024-05-03 15:06:21.851826692 +0200
@@ -3,58 +3,169 @@
 #include <stdio.h>
 #include "util.h"
 
-#ifdef BSD
+#if defined(BSD) && !defined(__MINGW32__) && !defined(_MSC_VER)
 #include <pwd.h>
 #endif
 
+/* NuSMV: add begin */
+static char* get_user_home(const char* username);
 
-char *
-util_tilde_expand(char *fname)
-{
-#ifdef BSD
-    struct passwd *userRecord;
-    char username[256], *filename;
-#ifndef _IBMR2
-    char *strcat (char *, const char *);
-#endif
-    register int i, j;
+#define HOME_LEN  256
+#define USER_LEN  256
 
-    filename = ALLOC(char, strlen(fname) + 256);
+/* Substitutes tilde, and '/' with '\\' under windows. 
+   Returned string must be destroyed */
+char* util_tilde_expand(char* fname)
+{
+  char username[USER_LEN];
+  char* filename = (char*) NULL;
+  char* home;
+  size_t len;
+  register int i, j;
+
+  len = strlen(fname) + HOME_LEN + USER_LEN;
+
+  filename = ALLOC(char, len);
+  assert(filename != (char*) NULL);
+  filename[0] = '\0';
+  i = 0;
+
+  if (fname[i] == '~') {
+    j = 0; ++i;
+    while ((fname[i] != '\0') && (fname[i] != '/') && (fname[i] != '\\')) {
+      username[j++] = fname[i++];
+    }
+    username[j] = '\0';
 
-    /* Clear the return string */
-    i = 0;
-    filename[0] = '\0';
-
-    /* Tilde? */
-    if (fname[0] == '~') {
-	j = 0;
-	i = 1;
-	while ((fname[i] != '\0') && (fname[i] != '/')) {
-	    username[j++] = fname[i++];
-	}
-	username[j] = '\0';
-
-	if (username[0] == '\0') {
-	    /* ~/ resolves to home directory of current user */
-	    if ((userRecord = getpwuid(getuid())) != 0) {
-		(void) strcat(filename, userRecord->pw_dir);
-	    } else {
-		i = 0;
-	    }
-	} else {
-	    /* ~user/ resolves to home directory of 'user' */
-	    if ((userRecord = getpwnam(username)) != 0) {
-		(void) strcat(filename, userRecord->pw_dir);
-	    } else {
-		i = 0;
-	    }
-	}
+    home = get_user_home(username);
+    if (strlen(home) > 0) {
+      strncpy(filename, home, (len-1) * sizeof(char));
+      len -= strlen(home);
+    }
+    else i = 0;
+    FREE(home);
+  }
+
+  /* Concantenate remaining portion of file name */
+  strncat(filename, fname + i, (len-1) * sizeof(char));
+  
+# if defined(__MINGW32__) || defined(_MSC_VER)
+  {
+    /* substitute all '/' with '\\' */
+    char* iter = filename;
+    while(*iter != '\0') {
+      if ((*iter) == '/') *iter='\\';
+      ++iter;
     }
+  }
+# endif /* __MINGW32__ */
+  
+  return filename;
+}
 
-    /* Concantenate remaining portion of file name */
-    (void) strcat(filename, fname + i);
-    return filename;
-#else
-    return strsav(fname);
-#endif
+
+/* Returns the user home path. If user is NULL, or the empty string,
+   then the current user is taken into account. An empty string is
+   returned if no home is found. String must be freed */
+static char* get_user_home(const char* username)
+{
+  char home[HOME_LEN];
+  char* var;
+
+  home[0] = '\0';
+  
+# if defined(BSD) && !defined(__MINGW32__) && !defined(_MSC_VER)
+  var = getenv("HOME");
+  if ((char*) NULL == var) return util_strsav("");
+
+  if (((char*) NULL != username) && ('\0' != username[0])) {
+    /* substitutes the given user within var */
+    int i;
+    int start_user_name;
+
+    /* gets rid of all final '/' */
+    for (i=strlen(var)-1; i>=0 && '/' == var[i]; --i);
+
+    /* continues searching the previous '/' */
+    for (; i>=0 && '/' != var[i]; --i);
+    start_user_name = i; /* notice that this can be -1 */
+    
+    /* copies 'til the '/' before the username */
+    strncpy(home, var, start_user_name+1); 
+    /* substitutes the username */
+    strncpy(home+start_user_name+1, username, HOME_LEN-start_user_name-1);
+    /* appends the terminator for safety */ 
+    home[HOME_LEN-start_user_name-2] = '\0';
+  }
+  else {
+    strncpy(home, var, HOME_LEN-1);
+     home[HOME_LEN-1] = '\0'; /* appends the terminator for safety */ 
+  }
+
+ # elif (defined(__MINGW32__) || defined(_MSC_VER)) && !defined(UNDER_CE) 
+   var = getenv("HOME");
+   if (var != (char*) NULL) {	
+     strncpy(home, var, (HOME_LEN-1) * sizeof(char));
+   } 
+   else {
+     var = getenv("USERPROFILE");
+     if (var != (char*) NULL) {
+       strncpy(home, var, (HOME_LEN-1) * sizeof(char));
+     }
+     else {
+       char* homepath;
+       homepath = getenv("HOMEPATH");
+       if (homepath != (char*) NULL) {
+	 char* drive;
+	 drive = getenv("HOMEDRIVE");
+	 if (drive != (char*) NULL) {
+	   snprintf(home, HOME_LEN-1, "%s\\%s", drive, homepath); 
+	 }
+       }
+     }
+   }
+   home[HOME_LEN-1] = '\0'; /* null terminates for safety */
+
+   if ((username != (char*) NULL) && (username[0] != '\0')) {
+     if (home[0] != '\0') {
+       /* tries to substitute the user name with the specified username */
+       char* curr_username;
+
+       curr_username = getenv("USERNAME");
+       if (curr_username == (char*) NULL) {
+	 /* tries to retrieve the user name from the home path */
+	 curr_username = strrchr(home, '\\');
+	 if (curr_username == (char*) NULL) curr_username = strrchr(home, '/');
+
+	 /* skips the '\\' or '/' */
+	 if (curr_username != (char*) NULL) ++curr_username; 
+       }
+       if (curr_username != (char*) NULL) {
+	 char* last = NULL;
+	 char* pos = home;
+	 /* searches for the username part */
+	 while(1) {
+	   pos = strstr(pos, curr_username); 
+	   if (pos != (char*) NULL) {
+	     last = pos;
+	     ++pos;
+	   }
+	   else break;
+	 }
+
+	 /* last contains here the position of curr_username, substitute */
+	 if (last != (char*) NULL) {
+	   strncpy(last, username, ((HOME_LEN-1) * sizeof(char)) - (last-home));
+	   home[HOME_LEN-1] = '\0'; /* terminates for safety */
+	 }
+       }
+     }
+   } /* username specified */
+
+ #elif defined(__MINGW32__) && defined(UNDER_CE)
+   return util_strsav("");
+ #endif
+
+   return util_strsav(home);
 }
+/* NuSMV: add end */
diff -Nru a/util/tmpfile.c b/util/tmpfile.c
--- a/util/tmpfile.c	2016-01-20 23:04:27.000000000 +0100
+++ b/util/tmpfile.c	2024-05-03 15:06:21.851826692 +0200
@@ -33,7 +33,7 @@
     return fp;
 }
 
-#else
+#elif !defined(_MSC_VER)
 
 FILE *
 tmpfile()
diff -Nru a/util/util.h b/util/util.h
--- a/util/util.h	2016-01-20 23:04:27.000000000 +0100
+++ b/util/util.h	2024-05-03 15:06:21.851826692 +0200
@@ -1,8 +1,66 @@
-/* $Id: util.h,v 1.7 2004/02/06 01:14:54 fabio Exp fabio $ */
+/* $Id: util.h,v 1.1.2.1 2010-02-04 10:41:22 nusmv Exp $ */
 
 #ifndef UTIL_H
 #define UTIL_H
 
+/* NuSMV: added begin */
+#if HAVE_CONFIG_H
+# include "nusmv-config.h"
+
+#elif defined (_MSC_VER)
+/* here the source code is compiled with MSVC */
+# if !defined (NUSMV_SIZEOF_VOID_P)
+#  if defined (_WIN64)
+#    define NUSMV_SIZEOF_VOID_P 8
+#  else
+#    define NUSMV_SIZEOF_VOID_P 4
+#  endif
+# endif
+# if !defined (NUSMV_SIZEOF_LONG)
+#  if defined (_WIN64)
+#    define NUSMV_SIZEOF_LONG 8
+#  else
+#    define NUSMV_SIZEOF_LONG 4
+#  endif
+# endif
+
+# if !defined (NUSMV_SIZEOF_INT)
+#  define NUSMV_SIZEOF_INT 4
+# endif
+#endif
+
+#ifndef EXTERN
+#   ifdef __cplusplus
+#	define EXTERN extern "C"
+#   else
+#	define EXTERN extern
+#   endif
+#endif
+#ifndef ARGS
+#   if defined(__STDC__) || defined(__cplusplus) || defined(_MSC_VER)
+#	define ARGS(protos)    protos          /* ANSI C */
+#   else /* !(__STDC__ || __cplusplus) || defined(_MSC_VER)*/
+#	define ARGS(protos)    ()              /* K&R C */
+#   endif /* !(__STDC__ || __cplusplus || defined(_MSC_VER)) */
+#endif
+#ifndef NULLARGS
+#   if defined(__STDC__) || defined(__cplusplus) || defined(_MSC_VER)
+#       define NULLARGS    (void)
+#   else
+#       define NULLARGS    ()
+#   endif
+#endif
+#ifndef const
+#   if !defined(__STDC__) && !defined(__cplusplus)
+#       define const
+#   endif
+#endif
+
+#if !defined(NUSMV_SIZEOF_VOID_P) || !defined(NUSMV_SIZEOF_LONG) || !defined(NUSMV_SIZEOF_INT)
+#error Constants NUSMV_SIZEOF_VOID_P, NUSMV_SIZEOF_LONG and NUSMV_SIZEOF_INT must be defined
+#endif
+/* NuSMV: added end */
+
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -19,27 +77,37 @@
 #   define UTIL_UNUSED
 #endif
 
-#ifndef SIZEOF_VOID_P
-#define SIZEOF_VOID_P 4
-#endif
-#ifndef SIZEOF_INT
-#define SIZEOF_INT 4
-#endif
-#ifndef SIZEOF_LONG
-#define SIZEOF_LONG 4
-#endif
-
-#if SIZEOF_VOID_P == 8 && SIZEOF_INT == 4
+/* NuSMV: add begin */
+#if NUSMV_SIZEOF_VOID_P == 8 && NUSMV_SIZEOF_INT == 4
+  #if NUSMV_SIZEOF_LONG == 8
 typedef long util_ptrint;
+typedef unsigned long util_ptruint;
+  #else
+typedef long long util_ptrint;
+typedef unsigned long long util_ptruint;
+  #endif
 #else
 typedef int util_ptrint;
+typedef unsigned int util_ptruint;
 #endif
+  /* WAS: #if NUSMV_SIZEOF_VOID_P == 8 && NUSMV_SIZEOF_INT == 4
+          typedef long util_ptrint;
+          typedef unsigned long util_ptruint;
+          #else
+          typedef int util_ptrint;
+          typedef unsigned int util_ptruint;
+          #endif */
+/* NuSMV: add end */
 
 /* #define USE_MM */		/* choose libmm.a as the memory allocator */
 
 /* these are too entrenched to get away with changing the name */
 #define strsav		util_strsav
+
+#if NUSMV_HAVE_UNISTD_H
 #include <unistd.h>
+#endif
+
 extern char *optarg;
 extern int optind, opterr;
 
@@ -76,9 +144,9 @@
  *	- when in doubt, delete the '#define USE_MM' above
  */
 #define ALLOC(type, num)	\
-    ((type *) MMalloc((long) sizeof(type) * (long) (num)))
+    ((type *) MMalloc(sizeof(type) * (size_t) (num)))
 #define REALLOC(type, obj, num)	\
-    ((type *) MMrealloc((char *) (obj), (long) sizeof(type) * (long) (num)))
+    ((type *) MMrealloc((char *) (obj), sizeof(type) * (size_t) (num)))
 #define FREE(obj)		\
     ((obj) ? (free((char *) (obj)), (obj) = 0) : 0)
 #endif
@@ -100,14 +168,19 @@
 
 
 /* Some machines fail to define some functions in stdio.h */
-#if !defined(__STDC__) && !defined(__cplusplus)
+#if !defined(__STDC__) && !defined(__cplusplus) && !defined(_MSC_VER)
 extern FILE *popen(), *tmpfile();
 extern int pclose();
 #endif
 
+/* snprintf is not available under MSVC */
+#if defined(_MSC_VER)
+#define snprintf \
+	sprintf_s
+#endif
 
 /* most machines don't give us a header file for these */
-#if (defined(__STDC__) || defined(__cplusplus) || defined(ultrix)) && !defined(MNEMOSYNE) || defined(__SVR4)
+#if (defined(__STDC__) || defined(__cplusplus) || defined(ultrix) || defined(_MSC_VER)) && !defined(MNEMOSYNE) || defined(__SVR4)
 # include <stdlib.h>
 #else
 # ifndef _IBMR2
@@ -124,7 +197,7 @@
 
 
 /* some call it strings.h, some call it string.h; others, also have memory.h */
-#if defined(__STDC__) || defined(__cplusplus) || defined(_IBMR2) || defined(ultrix)
+#if defined(__STDC__) || defined(__cplusplus) || defined(_IBMR2) || defined(ultrix) || defined(_MSC_VER)
 #include <string.h>
 #else
 /* ANSI C string.h -- 1/11/88 Draft Standard */
@@ -136,10 +209,11 @@
 #endif
 
 
-#ifdef __STDC__
+#if defined(__STDC__) || defined(_MSC_VER)
 #include <assert.h>
 #else
-#ifndef NDEBUG
+#if !defined(NDEBUG)
+#undef assert
 #define assert(ex) {\
     if (! (ex)) {\
 	(void) fprintf(stderr,\
@@ -149,7 +223,7 @@
 	abort();\
     }\
 }
-#else
+#elif !defined(assert)
 #define assert(ex) ;
 #endif
 #endif
@@ -173,35 +247,79 @@
 
 
 /* These arguably do NOT belong in util.h */
+/* NuSMV: added begin */
+#ifndef ABS
+/* NuSMV: added end */
 #define ABS(a)			((a) < 0 ? -(a) : (a))
+/* NuSMV: added begin */
+#endif
+#ifndef MAX
+/* NuSMV: added end */
 #define MAX(a,b)		((a) > (b) ? (a) : (b))
+/* NuSMV: added begin */
+#endif
+#ifndef MIN
+/* NuSMV: added end */
 #define MIN(a,b)		((a) < (b) ? (a) : (b))
+/* NuSMV: added begin */
+#endif
+/* NuSMV: added end */
+
+
+/* NuSMV: added begin */
+/**Macro**********************************************************************
+  Synopsis     [This is a portable prefix to print size_t valus with printf]
+  Description  [Use this prefix when printinf size_t values with printf.
+  Warning! This macro is not prefixed with '%']
+  SideEffects  []
+  SeeAlso      []
+******************************************************************************/
+#ifndef PRIuPTR
+# if !NUSMV_HAVE_INTTYPES_H
+#  if (defined __MINGW32__) || (defined __CYGWIN__)
+#   ifdef _WIN64
+#    define PRIuPTR "I64u"
+#   else
+#    define PRIuPTR "u"
+#   endif
+#  else
+#   if __WORDSIZE == 64
+#    define PRIuPTR "lu"
+#   else
+#    define PRIuPTR "u"
+#   endif
+#  endif
+# else /* HAVE_INTTYPES_H */
+#  include <inttypes.h>
+# endif
+#endif
+/* NuSMV: added end */
 
 
 #ifndef USE_MM
-extern char *MMalloc (long);
-extern void MMout_of_memory (long);
-extern void (*MMoutOfMemory) (long);
-extern char *MMrealloc (char *, long);
+extern char *MMalloc (size_t);
+extern void MMout_of_memory (size_t);
+extern void (*MMoutOfMemory) (size_t);
+extern char *MMrealloc (char *, size_t);
 #endif
 
 extern long util_cpu_time (void);
-extern int util_getopt (int, char **, char *);
-extern void util_getopt_reset (void);
+/* extern int util_getopt (int, char **, char *); */
+/* extern void util_getopt_reset (void); */
 extern char *util_path_search (char *);
 extern char *util_file_search (char *, char *, char *);
 extern int util_pipefork (char **, FILE **, FILE **, int *);
 extern void util_print_cpu_stats (FILE *);
 extern char *util_print_time (unsigned long);
 extern int util_save_image (char *, char *);
-extern char *util_strsav (char *);
+extern char *util_strsav (const char *);
 extern char *util_tilde_expand (char *);
 extern void util_restart (char *, char *, int);
 
 
 /* util_getopt() global variables (ack !) */
-extern int util_optind;
-extern char *util_optarg;
+/* extern int util_optind; */
+/* extern char *util_optarg; */
 
 extern long getSoftDataLimit (void);
 
